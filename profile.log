SCRIPT  /usr/share/nvim/runtime/scripts.vim
Sourced 2 times
Total time:   0.003080
 Self time:   0.003080

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2019 Jun 25
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    2              0.000015 if did_filetype()
                              finish
    2              0.000005 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    2              0.000023 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    2              0.000004 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    2              0.000046 let s:cpo_save = &cpo
    2              0.000046 set cpo&vim
                            
    2              0.000024 let s:line1 = getline(1)
                            
    2              0.000026 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
    2              0.000009 else
                              " File does not start with "#!".
                            
    2              0.000014   let s:line2 = getline(2)
    2              0.000010   let s:line3 = getline(3)
    2              0.000009   let s:line4 = getline(4)
    2              0.000010   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    2              0.000016   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    2              0.000098   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    2              0.000051   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    2              0.000015   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    2              0.000015   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    2              0.000028   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    2              0.000042   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    2              0.000238   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    2              0.000018   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    2              0.000061   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    2              0.000020   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    2              0.000021   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    2              0.000016   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    2              0.000015   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    2              0.000021   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    2              0.000018   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    2              0.000012   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    2              0.000040   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    2              0.000038   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    2              0.000027   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    2              0.000011   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    2              0.000012   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    2              0.000025   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    2              0.000021   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    2              0.000015   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    2              0.000066   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    2              0.000037   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    2              0.000024   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    2              0.000031   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    2              0.000023   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    2              0.000017   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    2              0.000017   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    2              0.000064   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    2              0.000080   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    2              0.000034   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    2              0.000018   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    2              0.000020   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    2              0.000028   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    2              0.000064   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    2              0.000017    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    2              0.000019   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
    2              0.000004   else
    2              0.000011     let s:lnum = 1
    2              0.000026     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    2              0.000007     endwhile
    2              0.000022     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    2              0.000073     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    2              0.000004     endif
    2              0.000010     unlet s:lnum
                            
    2              0.000004   endif
                            
    2              0.000013   unlet s:line2 s:line3 s:line4 s:line5
                            
    2              0.000004 endif
                            
                            " Restore 'cpoptions'
    2              0.000048 let &cpo = s:cpo_save
                            
    2              0.000021 unlet s:cpo_save s:line1

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/nerdtree.vim
Sourced 3 times
Total time:   0.004555
 Self time:   0.004555

count  total (s)   self (s)
    3              0.000047 let s:tree_up_dir_line = '.. (up a dir)'
    3              0.000104 syn match NERDTreeIgnore #\~#
    3              0.000081 exec 'syn match NERDTreeIgnore #\['.g:NERDTreeGlyphReadOnly.'\]#'
                            
                            "highlighting for the .. (up dir) line at the top of the tree
    3              0.000080 execute "syn match NERDTreeUp #\\V". s:tree_up_dir_line ."#"
                            
                            "quickhelp syntax elements
    3              0.000070 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*:#ms=s+2,me=e-1
    3              0.000049 syn match NERDTreeHelpKey #" \{1,2\}[^ ]*,#ms=s+2,me=e-1
    3              0.000048 syn match NERDTreeHelpTitle #" .*\~$#ms=s+2,me=e-1
    3              0.000042 syn match NERDTreeToggleOn #(on)#ms=s+1,he=e-1
    3              0.000040 syn match NERDTreeToggleOff #(off)#ms=e-3,me=e-1
    3              0.000045 syn match NERDTreeHelpCommand #" :.\{-}\>#hs=s+3
    3              0.000218 syn match NERDTreeHelp  #^".*# contains=NERDTreeHelpKey,NERDTreeHelpTitle,NERDTreeIgnore,NERDTreeToggleOff,NERDTreeToggleOn,NERDTreeHelpCommand
                            
                            "highlighting for sym links
    3              0.000117 syn match NERDTreeLinkTarget #->.*# containedin=NERDTreeDir,NERDTreeFile
    3              0.000072 syn match NERDTreeLinkFile #.* ->#me=e-3 containedin=NERDTreeFile
    3              0.000073 syn match NERDTreeLinkDir #.*/ ->#me=e-3 containedin=NERDTreeDir
                            
                            "highlighing for directory nodes and file nodes
    3              0.000074 syn match NERDTreeDirSlash #/# containedin=NERDTreeDir
                            
    3              0.000182 exec 'syn match NERDTreeClosable #' . escape(g:NERDTreeDirArrowCollapsible, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
    3              0.000141 exec 'syn match NERDTreeOpenable #' . escape(g:NERDTreeDirArrowExpandable, '~') . '\ze .*/# containedin=NERDTreeDir,NERDTreeFile'
                            
    3              0.000054 let s:dirArrows = escape(g:NERDTreeDirArrowCollapsible, '~]\-').escape(g:NERDTreeDirArrowExpandable, '~]\-')
    3              0.000064 exec 'syn match NERDTreeDir #[^'.s:dirArrows.' ].*/#'
    3              0.000127 syn match NERDTreeExecFile  #^ .*\*\($\| \)# contains=NERDTreeRO,NERDTreeBookmark
    3              0.000242 exec 'syn match NERDTreeFile  #^[^"\.'.s:dirArrows.'] *[^'.s:dirArrows.']*# contains=NERDTreeLink,NERDTreeRO,NERDTreeBookmark,NERDTreeExecFile'
                            
                            "highlighting for readonly files
    3              0.000162 exec 'syn match NERDTreeRO # *\zs.*\ze \['.g:NERDTreeGlyphReadOnly.'\]# contains=NERDTreeIgnore,NERDTreeBookmark,NERDTreeFile'
                            
    3              0.000130 syn match NERDTreeFlags #^ *\zs\[[^\]]*\]# containedin=NERDTreeFile,NERDTreeExecFile
    3              0.000072 syn match NERDTreeFlags #\[[^\]]*\]# containedin=NERDTreeDir
                            
                            "highlighing to conceal the delimiter around the file/dir name
    3              0.000028 if has("conceal")
    3              0.000099     exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# conceal containedin=ALL'
    3              0.000065     setlocal conceallevel=3 concealcursor=nvic
                            else
                                exec 'syn match NERDTreeNodeDelimiters #\%d' . char2nr(g:NERDTreeNodeDelimiter) . '# containedin=ALL'
                                hi! link NERDTreeNodeDelimiters Ignore
    3              0.000006 endif
                            
    3              0.000061 syn match NERDTreeCWD #^[</].*$#
                            
                            "highlighting for bookmarks
    3              0.000036 syn match NERDTreeBookmark # {.*}#hs=s+1
                            
                            "highlighting for the bookmarks table
    3              0.000038 syn match NERDTreeBookmarksLeader #^>#
    3              0.000081 syn match NERDTreeBookmarksHeader #^>-\+Bookmarks-\+$# contains=NERDTreeBookmarksLeader
    3              0.000073 syn match NERDTreeBookmarkName #^>.\{-} #he=e-1 contains=NERDTreeBookmarksLeader
    3              0.000109 syn match NERDTreeBookmark #^>.*$# contains=NERDTreeBookmarksLeader,NERDTreeBookmarkName,NERDTreeBookmarksHeader
                            
    3              0.000077 hi def link NERDTreePart Special
    3              0.000066 hi def link NERDTreePartFile Type
    3              0.000067 hi def link NERDTreeExecFile Title
    3              0.000057 hi def link NERDTreeDirSlash Identifier
                            
    3              0.000043 hi def link NERDTreeBookmarksHeader statement
    3              0.000042 hi def link NERDTreeBookmarksLeader ignore
    3              0.000046 hi def link NERDTreeBookmarkName Identifier
    3              0.000049 hi def link NERDTreeBookmark normal
                            
    3              0.000046 hi def link NERDTreeHelp String
    3              0.000047 hi def link NERDTreeHelpKey Identifier
    3              0.000047 hi def link NERDTreeHelpCommand Identifier
    3              0.000042 hi def link NERDTreeHelpTitle Macro
    3              0.000051 hi def link NERDTreeToggleOn Question
    3              0.000052 hi def link NERDTreeToggleOff WarningMsg
                            
    3              0.000046 hi def link NERDTreeLinkTarget Type
    3              0.000040 hi def link NERDTreeLinkFile Macro
    3              0.000039 hi def link NERDTreeLinkDir Macro
                            
    3              0.000051 hi def link NERDTreeDir Directory
    3              0.000052 hi def link NERDTreeUp Directory
    3              0.000050 hi def link NERDTreeFile Normal
    3              0.000041 hi def link NERDTreeCWD Statement
    3              0.000050 hi def link NERDTreeOpenable Directory
    3              0.000051 hi def link NERDTreeClosable Directory
    3              0.000043 hi def link NERDTreeIgnore ignore
    3              0.000050 hi def link NERDTreeRO WarningMsg
    3              0.000042 hi def link NERDTreeBookmark Statement
    3              0.000045 hi def link NERDTreeFlags Number
                            
    3              0.000080 hi def link NERDTreeCurrentNode Search

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/typescript.vim
Sourced 3 times
Total time:   0.102694
 Self time:   0.010398

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript
                            " Maintainer:   Herrington Darkholme
                            " Last Change:  2016-04-05
                            " Version:      1.0
                            " Changes:      Go to https:github.com/HerringtonDarkholme/yats.vim for recent changes.
                            " Origin:       https://github.com/othree/yajs
                            " Credits:      Kao Wei-Ko(othree), Jose Elera Campana, Zhao Yi, Claudio Fleiner, Scott Shattuck
                            "               (This file is based on their hard work), gumnos (From the #vim
                            "               IRC Channel in Freenode)
                            
                            
    3              0.000035 if !exists("main_syntax")
    3              0.000019   if exists("b:current_syntax")
                                finish
    3              0.000005   endif
    3              0.000028   let main_syntax = 'typescript'
    3              0.000005 endif
                            
                            " nextgroup doesn't contain objectLiteral, let outer region contains it
    3              0.000151 syntax region typescriptTypeCast matchgroup=typescriptTypeBrackets
                              \ start=/< \@!/ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptExpression
                              \ contained skipwhite oneline
                            
    3   0.092710   0.000415 runtime syntax/common.vim
                            
    3              0.000017 let b:current_syntax = "typescript"
    3              0.000014 if main_syntax == 'typescript'
    3              0.000007   unlet main_syntax
    3              0.000009 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/common.vim
Sourced 3 times
Total time:   0.092237
 Self time:   0.010704

count  total (s)   self (s)
                            " Define the default highlighting.
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000026 let did_typescript_hilink = 1
                            
    3              0.000012 syntax sync fromstart
    3              0.000079 command -nargs=+ HiLink hi def link <args>
                            
                            "Dollar sign is permitted anywhere in an identifier
    3              0.000167 setlocal iskeyword-=$
    3              0.000021 if main_syntax == 'typescript' || main_syntax == 'typescriptreact'
    3              0.000138   setlocal iskeyword+=$
                              " syntax cluster htmlJavaScript                 contains=TOP
    3              0.000004 endif
                            
                            " lowest priority on least used feature
    3              0.000103 syntax match   typescriptLabel                /[a-zA-Z_$]\k*:/he=e-1 contains=typescriptReserved nextgroup=@typescriptStatement skipwhite skipempty
                            
                            " other keywords like return,case,yield uses containedin
    3              0.000080 syntax region  typescriptBlock                 matchgroup=typescriptBraces start=/{/ end=/}/ contains=@typescriptStatement,@typescriptComments fold
                            
                            
    3   0.001569   0.000471 runtime syntax/basic/identifiers.vim
    3   0.001396   0.000434 runtime syntax/basic/literal.vim
    3   0.001171   0.000411 runtime syntax/basic/object.vim
                            
    3   0.001431   0.000474 runtime syntax/basic/symbols.vim
                            " runtime syntax/basic/reserved.vim
    3   0.002444   0.000451 runtime syntax/basic/keyword.vim
    3   0.002835   0.000460 runtime syntax/basic/doc.vim
    3   0.003008   0.000463 runtime syntax/basic/type.vim
                            
                            " extension
    3              0.000030 if get(g:, 'yats_host_keyword', 1)
    3   0.066091   0.000426   runtime syntax/yats.vim
    3              0.000004 endif
                            
                            " patch
    3   0.000788   0.000397 runtime syntax/basic/patch.vim
    3   0.001367   0.000362 runtime syntax/basic/members.vim
    3   0.001512   0.000356 runtime syntax/basic/class.vim
    3   0.001546   0.000424 runtime syntax/basic/cluster.vim
    3   0.001506   0.000353 runtime syntax/basic/function.vim
    3   0.000771   0.000422 runtime syntax/basic/decorator.vim
                            
    3              0.000025 if exists("did_typescript_hilink")
    3              0.000063   HiLink typescriptReserved             Error
                            
    3              0.000040   HiLink typescriptEndColons            Exception
    3              0.000051   HiLink typescriptSymbols              Normal
    3              0.000038   HiLink typescriptBraces               Function
    3              0.000040   HiLink typescriptParens               Normal
    3              0.000035   HiLink typescriptComment              Comment
    3              0.000034   HiLink typescriptLineComment          Comment
    3              0.000033   HiLink typescriptDocComment           Comment
    3              0.000034   HiLink typescriptCommentTodo          Todo
    3              0.000033   HiLink typescriptRef                  Include
    3              0.000034   HiLink typescriptDocNotation          SpecialComment
    3              0.000035   HiLink typescriptDocTags              SpecialComment
    3              0.000033   HiLink typescriptDocNGParam           typescriptDocParam
    3              0.000033   HiLink typescriptDocParam             Function
    3              0.000033   HiLink typescriptDocNumParam          Function
    3              0.000032   HiLink typescriptDocEventRef          Function
    3              0.000036   HiLink typescriptDocNamedParamType    Type
    3              0.000036   HiLink typescriptDocParamName         Type
    3              0.000035   HiLink typescriptDocParamType         Type
    3              0.000038   HiLink typescriptString               String
    3              0.000035   HiLink typescriptSpecial              Special
    3              0.000035   HiLink typescriptStringLiteralType    String
    3              0.000033   HiLink typescriptStringMember         String
    3              0.000037   HiLink typescriptTemplate             String
    3              0.000037   HiLink typescriptEventString          String
    3              0.000035   HiLink typescriptASCII                Special
    3              0.000034   HiLink typescriptTemplateSB           Label
    3              0.000036   HiLink typescriptRegexpString         String
    3              0.000034   HiLink typescriptGlobal               Constant
    3              0.000030   HiLink typescriptTestGlobal           Function
    3              0.000036   HiLink typescriptPrototype            Type
    3              0.000034   HiLink typescriptConditional          Conditional
    3              0.000034   HiLink typescriptConditionalElse      Conditional
    3              0.000033   HiLink typescriptCase                 Conditional
    3              0.000025   HiLink typescriptDefault              typescriptCase
    3              0.000032   HiLink typescriptBranch               Conditional
    3              0.000033   HiLink typescriptIdentifier           Structure
    3              0.000037   HiLink typescriptVariable             Identifier
    3              0.000037   HiLink typescriptEnumKeyword          Identifier
    3              0.000033   HiLink typescriptRepeat               Repeat
    3              0.000033   HiLink typescriptForOperator          Repeat
    3              0.000034   HiLink typescriptStatementKeyword     Statement
    3              0.000047   HiLink typescriptMessage              Keyword
    3              0.000039   HiLink typescriptOperator             Identifier
    3              0.000037   HiLink typescriptKeywordOp            Identifier
    3              0.000035   HiLink typescriptCastKeyword          Special
    3              0.000045   HiLink typescriptType                 Type
    3              0.000034   HiLink typescriptNull                 Boolean
    3              0.000038   HiLink typescriptNumber               Number
    3              0.000037   HiLink typescriptExponent             Number
    3              0.000034   HiLink typescriptBoolean              Boolean
    3              0.000028   HiLink typescriptObjectLabel          typescriptLabel
    3              0.000034   HiLink typescriptLabel                Label
    3              0.000052   HiLink typescriptStringProperty       String
    3              0.000035   HiLink typescriptImport               Special
    3              0.000034   HiLink typescriptAmbientDeclaration   Special
    3              0.000034   HiLink typescriptExport               Special
    3              0.000033   HiLink typescriptModule               Special
    3              0.000033   HiLink typescriptTry                  Special
    3              0.000033   HiLink typescriptExceptions           Special
                            
    3              0.000029   HiLink typescriptMember              Function
    3              0.000034   HiLink typescriptMethodAccessor       Operator
                            
    3              0.000029   HiLink typescriptAsyncFuncKeyword     Keyword
    3              0.000034   HiLink typescriptObjectAsyncKeyword   Keyword
    3              0.000033   HiLink typescriptAsyncFor             Keyword
    3              0.000033   HiLink typescriptFuncKeyword          Keyword
    3              0.000028   HiLink typescriptAsyncFunc            Keyword
    3              0.000031   HiLink typescriptArrowFunc            Type
    3              0.000028   HiLink typescriptFuncName             Function
    3              0.000043   HiLink typescriptFuncArg              PreProc
    3              0.000033   HiLink typescriptArrowFuncArg         PreProc
    3              0.000045   HiLink typescriptFuncComma            Operator
                            
    3              0.000036   HiLink typescriptClassKeyword         Keyword
    3              0.000029   HiLink typescriptClassExtends         Keyword
                              " HiLink typescriptClassName            Function
    3              0.000033   HiLink typescriptAbstract             Special
                              " HiLink typescriptClassHeritage        Function
                              " HiLink typescriptInterfaceHeritage    Function
    3              0.000029   HiLink typescriptClassStatic          StorageClass
    3              0.000031   HiLink typescriptReadonlyModifier     Keyword
    3              0.000033   HiLink typescriptInterfaceKeyword     Keyword
    3              0.000027   HiLink typescriptInterfaceExtends     Keyword
    3              0.000029   HiLink typescriptInterfaceName        Function
                            
    3              0.000033   HiLink shellbang                      Comment
                            
    3              0.000036   HiLink typescriptTypeParameter         Identifier
    3              0.000032   HiLink typescriptConstraint            Keyword
    3              0.000035   HiLink typescriptPredefinedType        Type
    3              0.000033   HiLink typescriptReadonlyArrayKeyword  Keyword
    3              0.000037   HiLink typescriptUnion                 Operator
    3              0.000032   HiLink typescriptFuncTypeArrow         Function
    3              0.000032   HiLink typescriptConstructorType       Function
    3              0.000032   HiLink typescriptTypeQuery             Keyword
    3              0.000032   HiLink typescriptAccessibilityModifier Keyword
    3              0.000032   HiLink typescriptOptionalMark          PreProc
    3              0.000032   HiLink typescriptFuncType              Special
    3              0.000038   HiLink typescriptMappedIn              Special
    3              0.000038   HiLink typescriptCall                  PreProc
    3              0.000033   HiLink typescriptParamImpl             PreProc
    3              0.000036   HiLink typescriptConstructSignature    Identifier
    3              0.000036   HiLink typescriptAliasDeclaration      Identifier
    3              0.000032   HiLink typescriptAliasKeyword          Keyword
    3              0.000032   HiLink typescriptUserDefinedType       Keyword
    3              0.000035   HiLink typescriptTypeReference         Identifier
    3              0.000029   HiLink typescriptConstructor           Keyword
    3              0.000032   HiLink typescriptDecorator             Special
    3              0.000032   HiLink typescriptAssertType            Keyword
                            
    3              0.000028   highlight link typeScript             NONE
                            
    3              0.000016   delcommand HiLink
    3              0.000011   unlet did_typescript_hilink
    3              0.000013 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/identifiers.vim
Sourced 3 times
Total time:   0.001036
 Self time:   0.001036

count  total (s)   self (s)
    3              0.000145 syntax cluster afterIdentifier contains=
                              \ typescriptDotNotation,
                              \ typescriptFuncCallArg,
                              \ typescriptTemplate,
                              \ typescriptIndexExpr,
                              \ @typescriptSymbols,
                              \ typescriptTypeArguments
                            
    3              0.000061 syntax match   typescriptIdentifierName        /\<\K\k*/
                              \ nextgroup=@afterIdentifier
                              \ transparent
                              \ contains=@_semantic
                              \ skipnl skipwhite
                            
    3              0.000051 syntax match   typescriptProp contained /\K\k*!\?/
                              \ transparent
                              \ contains=@props
                              \ nextgroup=@afterIdentifier
                              \ skipwhite skipempty
                            
    3              0.000097 syntax region  typescriptIndexExpr      contained matchgroup=typescriptProperty start=/\[/rs=s+1 end=/]/he=e-1 contains=@typescriptValue nextgroup=@typescriptSymbols,typescriptDotNotation,typescriptFuncCallArg skipwhite skipempty
                            
    3              0.000045 syntax match   typescriptDotNotation           /\.\|?\.\|!\./ nextgroup=typescriptProp skipnl
    3              0.000063 syntax match   typescriptDotStyleNotation      /\.style\./ nextgroup=typescriptDOMStyle transparent
                            " syntax match   typescriptFuncCall              contained /[a-zA-Z]\k*\ze(/ nextgroup=typescriptFuncCallArg
    3              0.000094 syntax region  typescriptParenExp              matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptComments,@typescriptValue,typescriptCastKeyword nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000064 syntax region  typescriptFuncCallArg           contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptValue,@typescriptComments nextgroup=@typescriptSymbols,typescriptDotNotation skipwhite skipempty skipnl
    3              0.000047 syntax region  typescriptEventFuncCallArg      contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptEventExpression
    3              0.000184 syntax region  typescriptEventString           contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/ contains=typescriptASCII,@events

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/literal.vim
Sourced 3 times
Total time:   0.000897
 Self time:   0.000897

count  total (s)   self (s)
                            "Syntax in the JavaScript code
                            
                            " String
    3              0.000037 syntax match   typescriptASCII                 contained /\\\d\d\d/
                            
    3              0.000077 syntax region  typescriptTemplateSubstitution matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptValue
                              \ contained
                            
                            
    3              0.000099 syntax region  typescriptString 
                              \ start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+
                              \ contains=typescriptSpecial,@Spell
                              \ extend
                            
    3              0.000045 syntax match   typescriptSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{1,6}})|c\u|.)"
                            
                            " From vim runtime
                            " <https://github.com/vim/vim/blob/master/runtime/syntax/javascript.vim#L48>
    3              0.000110 syntax region  typescriptRegexpString          start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gimuy]\{0,5\}\s*$+ end=+/[gimuy]\{0,5\}\s*[;.,)\]}]+me=e-1 nextgroup=typescriptDotNotation oneline
                            
    3              0.000087 syntax region  typescriptTemplate
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitution,typescriptSpecial,@Spell
                              \ nextgroup=@typescriptSymbols
                              \ skipwhite skipempty
                            
                            "Array
    3              0.000079 syntax region  typescriptArray matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=@typescriptSymbols,typescriptDotNotation
                              \ skipwhite skipempty fold
                            
                            " Number
    3              0.000043 syntax match typescriptNumber /\<0[bB][01][01_]*\>/        nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000032 syntax match typescriptNumber /\<0[oO][0-7][0-7_]*\>/       nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000030 syntax match typescriptNumber /\<0[xX][0-9a-fA-F][0-9a-fA-F_]*\>/ nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000071 syntax match typescriptNumber /\d[0-9_]*\.\d[0-9_]*\|\d[0-9_]*\|\.\d[0-9]*/
                              \ nextgroup=typescriptExponent,@typescriptSymbols skipwhite skipempty
    3              0.000043 syntax match typescriptExponent /[eE][+-]\=\d[0-9]*\>/
                              \ nextgroup=@typescriptSymbols skipwhite skipempty contained

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/object.vim
Sourced 3 times
Total time:   0.000688
 Self time:   0.000688

count  total (s)   self (s)
    3              0.000173 syntax region  typescriptObjectLiteral         matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptComments,typescriptObjectLabel,typescriptStringProperty,typescriptComputedPropertyName,typescriptObjectAsyncKeyword
                              \ fold contained
                            
    3              0.000018 syntax keyword typescriptObjectAsyncKeyword async contained
                            
    3              0.000060 syntax match   typescriptObjectLabel  contained /\k\+\_s*/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
    3              0.000071 syntax region  typescriptStringProperty   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptPropertyName    contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1(/me=e-1 nextgroup=@typescriptCallSignature skipwhite skipempty oneline
    3              0.000062 syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptBraces
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*:/he=e-1 contains=@typescriptValue nextgroup=@typescriptValue skipwhite skipempty
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*(/me=e-1 contains=@typescriptValue nextgroup=@typescriptCallSignature skipwhite skipempty
                            " Value for object, statement for label statement
    3              0.000030 syntax match typescriptRestOrSpread /\.\.\./ contained
    3              0.000059 syntax match typescriptObjectSpread /\.\.\./ contained containedin=typescriptObjectLiteral,typescriptArray nextgroup=@typescriptValue
                            
    3              0.000034 syntax match typescriptObjectColon contained /:/ nextgroup=@typescriptValue skipwhite skipempty

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/symbols.vim
Sourced 3 times
Total time:   0.000890
 Self time:   0.000890

count  total (s)   self (s)
                            " + - ^ ~
    3              0.000070 syntax match typescriptUnaryOp /[+\-~!]/
                             \ nextgroup=@typescriptValue
                             \ skipwhite
                            
    3              0.000090 syntax region typescriptTernary matchgroup=typescriptTernaryOp start=/?[.?]\@!/ end=/:/ contained contains=@typescriptValue,@typescriptComments nextgroup=@typescriptValue skipwhite skipempty
                            
    3              0.000036 syntax match   typescriptAssign  /=/ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
                            " 2: ==, ===
    3              0.000036 syntax match   typescriptBinaryOp contained /===\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 6: >>>=, >>>, >>=, >>, >=, >
    3              0.000033 syntax match   typescriptBinaryOp contained />\(>>=\|>>\|>=\|>\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: <<=, <<, <=, <
    3              0.000024 syntax match   typescriptBinaryOp contained /<\(<=\|<\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: ||, |=, |
    3              0.000023 syntax match   typescriptBinaryOp contained /|\(|\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: &&, &=, &
    3              0.000021 syntax match   typescriptBinaryOp contained /&\(&\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: *=, *
    3              0.000021 syntax match   typescriptBinaryOp contained /\*=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: %=, %
    3              0.000045 syntax match   typescriptBinaryOp contained /%=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: /=, /
    3              0.000032 syntax match   typescriptBinaryOp contained +/\(=\|[^\*/]\@=\)+ nextgroup=@typescriptValue skipwhite skipempty
    3              0.000023 syntax match   typescriptBinaryOp contained /!==\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: !=, !==
    3              0.000023 syntax match   typescriptBinaryOp contained /+\(+\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: +, ++, +=
    3              0.000021 syntax match   typescriptBinaryOp contained /-\(-\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: -, --, -=
                            
                            " exponentiation operator
                            " 2: **, **=
    3              0.000023 syntax match typescriptBinaryOp contained /\*\*=\?/ nextgroup=@typescriptValue
                            
    3              0.000090 syntax cluster typescriptSymbols               contains=typescriptBinaryOp,typescriptKeywordOp,typescriptTernary,typescriptAssign,typescriptCastKeyword

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/keyword.vim
Sourced 3 times
Total time:   0.001926
 Self time:   0.001926

count  total (s)   self (s)
                            "Import
    3              0.000048 syntax keyword typescriptImport                from as import
    3              0.000024 syntax keyword typescriptExport                export
    3              0.000023 syntax keyword typescriptModule                namespace module
                            
                            "this
                            
                            "JavaScript Prototype
    3              0.000034 syntax keyword typescriptPrototype             prototype
                              \ nextgroup=@afterIdentifier
                            
    3              0.000024 syntax keyword typescriptCastKeyword           as
                              \ nextgroup=@typescriptType
                              \ skipwhite
                            
                            "Program Keywords
    3              0.000033 syntax keyword typescriptIdentifier            arguments this super
                              \ nextgroup=@afterIdentifier
                            
    3              0.000063 syntax keyword typescriptVariable              let var
                              \ nextgroup=typescriptVariableDeclaration
                              \ skipwhite skipempty skipnl
                            
    3              0.000054 syntax keyword typescriptVariable const
                              \ nextgroup=typescriptEnum,typescriptVariableDeclaration
                              \ skipwhite
                            
    3              0.000078 syntax match typescriptVariableDeclaration /[A-Za-z_$]\k*/
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ contained skipwhite skipempty skipnl
                            
    3              0.000080 syntax region typescriptEnum matchgroup=typescriptEnumKeyword start=/enum / end=/\ze{/
                              \ nextgroup=typescriptBlock
                              \ skipwhite
                            
    3              0.000026 syntax keyword typescriptKeywordOp
                              \ contained in instanceof nextgroup=@typescriptValue
    3              0.000038 syntax keyword typescriptOperator              delete new typeof void
                              \ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
    3              0.000025 syntax keyword typescriptForOperator           contained in of
    3              0.000031 syntax keyword typescriptBoolean               true false nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000028 syntax keyword typescriptNull                  null undefined nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000059 syntax keyword typescriptMessage               alert confirm prompt status
                              \ nextgroup=typescriptDotNotation,typescriptFuncCallArg
    3              0.000031 syntax keyword typescriptGlobal                self top parent
                              \ nextgroup=@afterIdentifier
                            
                            "Statement Keywords
    3              0.000051 syntax keyword typescriptConditional           if else switch
                              \ nextgroup=typescriptConditionalParen
                              \ skipwhite skipempty skipnl
    3              0.000021 syntax keyword typescriptConditionalElse       else
    3              0.000049 syntax keyword typescriptRepeat                do while for nextgroup=typescriptLoopParen skipwhite skipempty
    3              0.000053 syntax keyword typescriptRepeat                for nextgroup=typescriptLoopParen,typescriptAsyncFor skipwhite skipempty
    3              0.000045 syntax keyword typescriptBranch                break continue containedin=typescriptBlock
    3              0.000047 syntax keyword typescriptCase                  case nextgroup=@typescriptPrimitive skipwhite containedin=typescriptBlock
    3              0.000085 syntax keyword typescriptDefault               default containedin=typescriptBlock nextgroup=@typescriptValue,typescriptClassKeyword,typescriptInterfaceKeyword skipwhite oneline
    3              0.000026 syntax keyword typescriptStatementKeyword      with
    3              0.000053 syntax keyword typescriptStatementKeyword      yield skipwhite nextgroup=@typescriptValue containedin=typescriptBlock
    3              0.000040 syntax keyword typescriptStatementKeyword      return skipwhite contained nextgroup=@typescriptValue containedin=typescriptBlock
                            
    3              0.000027 syntax keyword typescriptTry                   try
    3              0.000039 syntax keyword typescriptExceptions            catch throw finally
    3              0.000025 syntax keyword typescriptDebugger              debugger
                            
    3              0.000028 syntax keyword typescriptAsyncFor              await nextgroup=typescriptLoopParen skipwhite skipempty contained
                            
    3              0.000117 syntax region  typescriptLoopParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptVariable,typescriptForOperator,typescriptEndColons,@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    3              0.000063 syntax region  typescriptConditionalParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    3              0.000020 syntax match   typescriptEndColons             /[;,]/ contained
                            
    3              0.000032 syntax keyword typescriptAmbientDeclaration declare nextgroup=@typescriptAmbients
                              \ skipwhite skipempty
                            
    3              0.000122 syntax cluster typescriptAmbients contains=
                              \ typescriptVariable,
                              \ typescriptFuncKeyword,
                              \ typescriptClassKeyword,
                              \ typescriptAbstract,
                              \ typescriptEnumKeyword,typescriptEnum,
                              \ typescriptModule

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/doc.vim
Sourced 3 times
Total time:   0.002301
 Self time:   0.002301

count  total (s)   self (s)
                            "Syntax coloring for Node.js shebang line
    3              0.000063 syntax match   shellbang "^#!.*node\>"
    3              0.000024 syntax match   shellbang "^#!.*iojs\>"
                            
                            
                            "JavaScript comments
    3              0.000033 syntax keyword typescriptCommentTodo TODO FIXME XXX TBD
    3              0.000078 syntax match   typescriptLineComment "//.*"
                              \ contains=@Spell,typescriptCommentTodo,typescriptRef
    3              0.000066 syntax region  typescriptComment
                              \ start="/\*"  end="\*/"
                              \ contains=@Spell,typescriptCommentTodo extend
    3              0.000051 syntax cluster typescriptComments
                              \ contains=typescriptDocComment,typescriptComment,typescriptLineComment
                            
    3              0.000048 syntax match   typescriptRef  +///\s*<reference\s\+.*\/>$+
                              \ contains=typescriptString
    3              0.000040 syntax match   typescriptRef  +///\s*<amd-dependency\s\+.*\/>$+
                              \ contains=typescriptString
    3              0.000036 syntax match   typescriptRef  +///\s*<amd-module\s\+.*\/>$+
                              \ contains=typescriptString
                            
                            "JSDoc
    3              0.000006 syntax case ignore
                            
    3              0.000079 syntax region  typescriptDocComment            matchgroup=typescriptComment
                              \ start="/\*\*"  end="\*/"
                              \ contains=typescriptDocNotation,typescriptCommentTodo,@Spell
                              \ fold keepend
    3              0.000040 syntax match   typescriptDocNotation           contained /@/ nextgroup=typescriptDocTags
                            
    3              0.000039 syntax keyword typescriptDocTags               contained constant constructor constructs function ignore inner private public readonly static
    3              0.000035 syntax keyword typescriptDocTags               contained const dict expose inheritDoc interface nosideeffects override protected struct internal
    3              0.000014 syntax keyword typescriptDocTags               contained example global
    3              0.000023 syntax keyword typescriptDocTags               contained alpha beta defaultValue eventProperty experimental label
    3              0.000021 syntax keyword typescriptDocTags               contained packageDocumentation privateRemarks remarks sealed typeParam
                            
                            " syntax keyword typescriptDocTags               contained ngdoc nextgroup=typescriptDocNGDirective
    3              0.000017 syntax keyword typescriptDocTags               contained ngdoc scope priority animations
    3              0.000058 syntax keyword typescriptDocTags               contained ngdoc restrict methodOf propertyOf eventOf eventType nextgroup=typescriptDocParam skipwhite
    3              0.000094 syntax keyword typescriptDocNGDirective        contained overview service object function method property event directive filter inputType error
                            
    3              0.000018 syntax keyword typescriptDocTags               contained abstract virtual access augments
                            
    3              0.000044 syntax keyword typescriptDocTags               contained arguments callback lends memberOf name type kind link mixes mixin tutorial nextgroup=typescriptDocParam skipwhite
    3              0.000038 syntax keyword typescriptDocTags               contained variation nextgroup=typescriptDocNumParam skipwhite
                            
    3              0.000049 syntax keyword typescriptDocTags               contained author class classdesc copyright default defaultvalue nextgroup=typescriptDocDesc skipwhite
    3              0.000030 syntax keyword typescriptDocTags               contained deprecated description external host nextgroup=typescriptDocDesc skipwhite
    3              0.000037 syntax keyword typescriptDocTags               contained file fileOverview overview namespace requires since version nextgroup=typescriptDocDesc skipwhite
    3              0.000027 syntax keyword typescriptDocTags               contained summary todo license preserve nextgroup=typescriptDocDesc skipwhite
                            
    3              0.000037 syntax keyword typescriptDocTags               contained borrows exports nextgroup=typescriptDocA skipwhite
    3              0.000065 syntax keyword typescriptDocTags               contained param arg argument property prop module nextgroup=typescriptDocNamedParamType,typescriptDocParamName skipwhite
    3              0.000045 syntax keyword typescriptDocTags               contained define enum extends implements this typedef nextgroup=typescriptDocParamType skipwhite
    3              0.000036 syntax keyword typescriptDocTags               contained return returns throws exception nextgroup=typescriptDocParamType,typescriptDocParamName skipwhite
    3              0.000032 syntax keyword typescriptDocTags               contained see nextgroup=typescriptDocRef skipwhite
                            
    3              0.000037 syntax keyword typescriptDocTags               contained function func method nextgroup=typescriptDocName skipwhite
    3              0.000030 syntax match   typescriptDocName               contained /\h\w*/
                            
    3              0.000057 syntax keyword typescriptDocTags               contained fires event nextgroup=typescriptDocEventRef skipwhite
    3              0.000027 syntax match   typescriptDocEventRef           contained /\h\w*#\(\h\w*\:\)\?\h\w*/
                            
    3              0.000048 syntax match   typescriptDocNamedParamType     contained /{.\+}/ nextgroup=typescriptDocParamName skipwhite
    3              0.000042 syntax match   typescriptDocParamName          contained /\[\?0-9a-zA-Z_\.]\+\]\?/ nextgroup=typescriptDocDesc skipwhite
    3              0.000026 syntax match   typescriptDocParamType          contained /{.\+}/ nextgroup=typescriptDocDesc skipwhite
    3              0.000053 syntax match   typescriptDocA                  contained /\%(#\|\w\|\.\|:\|\/\)\+/ nextgroup=typescriptDocAs skipwhite
    3              0.000070 syntax match   typescriptDocAs                 contained /\s*as\s*/ nextgroup=typescriptDocB skipwhite
    3              0.000026 syntax match   typescriptDocB                  contained /\%(#\|\w\|\.\|:\|\/\)\+/
    3              0.000026 syntax match   typescriptDocParam              contained /\%(#\|\w\|\.\|:\|\/\|-\)\+/
    3              0.000018 syntax match   typescriptDocNumParam           contained /\d\+/
    3              0.000023 syntax match   typescriptDocRef                contained /\%(#\|\w\|\.\|:\|\/\)\+/
    3              0.000064 syntax region  typescriptDocLinkTag            contained matchgroup=typescriptDocLinkTag start=/{/ end=/}/ contains=typescriptDocTags
                            
    3              0.000040 syntax cluster typescriptDocs                  contains=typescriptDocParamType,typescriptDocNamedParamType,typescriptDocParam
                            
    3              0.000025 if main_syntax == "typescript"
    3              0.000014   syntax sync clear
    3              0.000015   syntax sync ccomment typescriptComment minlines=200
    3              0.000005 endif
                            
    3              0.000015 syntax case match

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/type.vim
Sourced 3 times
Total time:   0.002454
 Self time:   0.002454

count  total (s)   self (s)
                            " Types
    3              0.000050 syntax match typescriptOptionalMark /?/ contained
                            
    3              0.000059 syntax cluster typescriptTypeParameterCluster contains=
                              \ typescriptTypeParameter,
                              \ typescriptGenericDefault
                            
    3              0.000063 syntax region typescriptTypeParameters matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ contained
                            
    3              0.000047 syntax match typescriptTypeParameter /\K\k*/
                              \ nextgroup=typescriptConstraint
                              \ contained skipwhite skipnl
                            
    3              0.000026 syntax keyword typescriptConstraint extends
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
    3              0.000025 syntax match typescriptGenericDefault /=/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite
                            
                            "><
                            " class A extend B<T> {} // ClassBlock
                            " func<T>() // FuncCallArg
    3              0.000076 syntax region typescriptTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/\></ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptFuncCallArg,@typescriptTypeOperator
                              \ contained skipwhite
                            
                            
    3              0.000066 syntax cluster typescriptType contains=
                              \ @typescriptPrimaryType,
                              \ typescriptUnion,
                              \ @typescriptFunctionType,
                              \ typescriptConstructorType
                            
                            " array type: A[]
                            " type indexing A['key']
    3              0.000079 syntax region typescriptTypeBracket contained
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptString,typescriptNumber
                              \ nextgroup=@typescriptTypeOperator
                              \ skipwhite skipempty
                            
    3              0.000176 syntax cluster typescriptPrimaryType contains=
                              \ typescriptParenthesizedType,
                              \ typescriptPredefinedType,
                              \ typescriptTypeReference,
                              \ typescriptObjectType,
                              \ typescriptTupleType,
                              \ typescriptTypeQuery,
                              \ typescriptStringLiteralType,
                              \ typescriptReadonlyArrayKeyword,
                              \ typescriptAssertType
                            
    3              0.000067 syntax region  typescriptStringLiteralType contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ nextgroup=typescriptUnion
                              \ skipwhite skipempty
                            
    3              0.000052 syntax region typescriptParenthesizedType matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty fold
                            
    3              0.000078 syntax match typescriptTypeReference /\K\k*\(\.\K\k*\)*/
                              \ nextgroup=typescriptTypeArguments,@typescriptTypeOperator,typescriptUserDefinedType
                              \ skipwhite contained skipempty
                            
    3              0.000041 syntax keyword typescriptPredefinedType any number boolean string void never undefined null object unknown
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
    3              0.000036 syntax match typescriptPredefinedType /unique symbol/
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
    3              0.000111 syntax region typescriptObjectType matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptTypeMember,typescriptEndColons,@typescriptComments,typescriptAccessibilityModifier,typescriptReadonlyModifier
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite fold
                            
    3              0.000060 syntax cluster typescriptTypeMember contains=
                              \ @typescriptCallSignature,
                              \ typescriptConstructSignature,
                              \ typescriptIndexSignature,
                              \ @typescriptMembers
                            
    3              0.000049 syntax region typescriptTupleType matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=@typescriptType,@typescriptComments
                              \ contained skipwhite
                            
    3              0.000026 syntax cluster typescriptTypeOperator
                              \ contains=typescriptUnion,typescriptTypeBracket
                            
    3              0.000023 syntax match typescriptUnion /|\|&/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty
                            
    3              0.000045 syntax cluster typescriptFunctionType contains=typescriptGenericFunc,typescriptFuncType
    3              0.000077 syntax region typescriptGenericFunc matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptFuncType
                              \ containedin=typescriptFunctionType
                              \ contained skipwhite skipnl
                            
    3              0.000070 syntax region typescriptFuncType matchgroup=typescriptParens
                              \ start=/(/ end=/)\s*=>/me=e-2
                              \ contains=@typescriptParameterList
                              \ nextgroup=typescriptFuncTypeArrow
                              \ contained skipwhite skipnl oneline
                            
    3              0.000037 syntax match typescriptFuncTypeArrow /=>/
                              \ nextgroup=@typescriptType
                              \ containedin=typescriptFuncType
                              \ contained skipwhite skipnl
                            
                            
    3              0.000022 syntax keyword typescriptConstructorType new
                              \ nextgroup=@typescriptFunctionType
                              \ contained skipwhite skipnl
                            
    3              0.000036 syntax keyword typescriptUserDefinedType is
                              \ contained nextgroup=@typescriptType skipwhite skipempty
                            
    3              0.000029 syntax keyword typescriptTypeQuery typeof keyof
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
    3              0.000021 syntax keyword typescriptAssertType asserts
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
    3              0.000046 syntax cluster typescriptCallSignature contains=typescriptGenericCall,typescriptCall
    3              0.000056 syntax region typescriptGenericCall matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptCall
                              \ contained skipwhite skipnl
    3              0.000094 syntax region typescriptCall matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptBlock
                              \ contained skipwhite skipnl
                            
    3              0.000024 syntax match typescriptTypeAnnotation /:/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
    3              0.000092 syntax cluster typescriptParameterList contains=
                              \ typescriptTypeAnnotation,
                              \ typescriptAccessibilityModifier,
                              \ typescriptOptionalMark,
                              \ typescriptRestOrSpread,
                              \ typescriptFuncComma,
                              \ typescriptDefaultParam
                            
    3              0.000014 syntax match typescriptFuncComma /,/ contained
                            
    3              0.000023 syntax match typescriptDefaultParam /=/
                              \ nextgroup=@typescriptValue
                              \ contained skipwhite
                            
    3              0.000018 syntax keyword typescriptConstructSignature new
                              \ nextgroup=@typescriptCallSignature
                              \ contained skipwhite
                            
    3              0.000094 syntax region typescriptIndexSignature matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptPredefinedType,typescriptMappedIn,typescriptString
                              \ nextgroup=typescriptTypeAnnotation
                              \ contained skipwhite oneline
                            
    3              0.000020 syntax keyword typescriptMappedIn in
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl skipempty
                            
    3              0.000053 syntax keyword typescriptAliasKeyword type
                              \ nextgroup=typescriptAliasDeclaration
                              \ skipwhite skipnl skipempty
                            
    3              0.000059 syntax region typescriptAliasDeclaration matchgroup=typescriptUnion
                              \ start=/ / end=/=/
                              \ nextgroup=@typescriptType
                              \ contains=typescriptConstraint,typescriptTypeParameters
                              \ contained skipwhite skipempty
                            
    3              0.000028 syntax keyword typescriptReadonlyArrayKeyword readonly
                              \ nextgroup=@typescriptPrimaryType
                              \ skipwhite

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats.vim
Sourced 3 times
Total time:   0.065613
 Self time:   0.015813

count  total (s)   self (s)
    3   0.001765   0.000434 runtime syntax/yats/typescript.vim
    3   0.001122   0.000390 runtime syntax/yats/es6-number.vim
    3   0.001142   0.000391 runtime syntax/yats/es6-string.vim
    3   0.001277   0.000373 runtime syntax/yats/es6-array.vim
    3   0.001640   0.000401 runtime syntax/yats/es6-object.vim
    3   0.001021   0.000386 runtime syntax/yats/es6-symbol.vim
    3   0.000759   0.000374 runtime syntax/yats/es6-function.vim
    3   0.001080   0.000358 runtime syntax/yats/es6-math.vim
    3   0.001226   0.000383 runtime syntax/yats/es6-date.vim
    3   0.000746   0.000367 runtime syntax/yats/es6-json.vim
    3   0.001000   0.000374 runtime syntax/yats/es6-regexp.vim
    3   0.000870   0.000383 runtime syntax/yats/es6-map.vim
    3   0.000840   0.000355 runtime syntax/yats/es6-set.vim
    3   0.000736   0.000363 runtime syntax/yats/es6-proxy.vim
    3   0.000913   0.000368 runtime syntax/yats/es6-promise.vim
    3   0.000832   0.000376 runtime syntax/yats/es6-reflect.vim
    3   0.000771   0.000369 runtime syntax/yats/ecma-402.vim
    3   0.000816   0.000356 runtime syntax/yats/node.vim
    3   0.000731   0.000347 runtime syntax/yats/test.vim
    3   0.008453   0.000349 runtime syntax/yats/web.vim
    3   0.011669   0.000395 runtime syntax/yats/web-window.vim
    3   0.001171   0.000402 runtime syntax/yats/web-navigator.vim
    3   0.000855   0.000379 runtime syntax/yats/web-location.vim
    3   0.000775   0.000369 runtime syntax/yats/web-history.vim
    3   0.000793   0.000359 runtime syntax/yats/web-console.vim
    3   0.000955   0.000359 runtime syntax/yats/web-xhr.vim
    3   0.001563   0.000343 runtime syntax/yats/web-blob.vim
    3   0.001013   0.000360 runtime syntax/yats/web-crypto.vim
    3   0.001260   0.000344 runtime syntax/yats/web-fetch.vim
    3   0.000960   0.000369 runtime syntax/yats/web-service-worker.vim
    3   0.000890   0.000349 runtime syntax/yats/web-encoding.vim
    3   0.000830   0.000406 runtime syntax/yats/web-geo.vim
    3   0.000731   0.000370 runtime syntax/yats/web-network.vim
    3   0.001334   0.000361 runtime syntax/yats/web-payment.vim
    3   0.001125   0.000376 runtime syntax/yats/dom-node.vim
    3   0.000967   0.000358 runtime syntax/yats/dom-elem.vim
    3   0.001307   0.000361 runtime syntax/yats/dom-document.vim
    3   0.002075   0.000369 runtime syntax/yats/dom-event.vim
    3   0.000951   0.000390 runtime syntax/yats/dom-storage.vim
    3   0.000843   0.000373 runtime syntax/yats/dom-form.vim
    3   0.001707   0.000351 runtime syntax/yats/css.vim
                            
                            
    3              0.000022 let typescript_props = 1
                            
    3   0.003904   0.000379 runtime syntax/yats/event.vim

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/typescript.vim
Sourced 3 times
Total time:   0.001275
 Self time:   0.001275

count  total (s)   self (s)
    3              0.000056 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function Boolean
    3              0.000040 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Error EvalError
    3              0.000026 syntax keyword typescriptGlobal containedin=typescriptIdentifierName InternalError
    3              0.000027 syntax keyword typescriptGlobal containedin=typescriptIdentifierName RangeError ReferenceError
    3              0.000024 syntax keyword typescriptGlobal containedin=typescriptIdentifierName StopIteration
    3              0.000027 syntax keyword typescriptGlobal containedin=typescriptIdentifierName SyntaxError TypeError
    3              0.000025 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URIError Date
    3              0.000023 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float32Array
    3              0.000024 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float64Array
    3              0.000025 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int16Array Int32Array
    3              0.000025 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int8Array Uint16Array
    3              0.000024 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint32Array Uint8Array
    3              0.000023 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint8ClampedArray
    3              0.000023 syntax keyword typescriptGlobal containedin=typescriptIdentifierName ParallelArray
    3              0.000043 syntax keyword typescriptGlobal containedin=typescriptIdentifierName ArrayBuffer DataView
    3              0.000023 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Iterator Generator
    3              0.000023 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect Proxy
    3              0.000022 syntax keyword typescriptGlobal containedin=typescriptIdentifierName arguments
    3              0.000090 if exists("did_typescript_hilink") | HiLink typescriptGlobal Structure
    3              0.000005 endif
    3              0.000061 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName eval uneval nextgroup=typescriptFuncCallArg
    3              0.000036 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isFinite nextgroup=typescriptFuncCallArg
    3              0.000035 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isNaN parseFloat nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName parseInt nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURI nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURIComponent nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURI nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURIComponent nextgroup=typescriptFuncCallArg
    3              0.000017 syntax cluster props add=typescriptGlobalMethod
    3              0.000067 if exists("did_typescript_hilink") | HiLink typescriptGlobalMethod Structure
    3              0.000015 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-number.vim
Sourced 3 times
Total time:   0.000681
 Self time:   0.000681

count  total (s)   self (s)
    3              0.000081 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Number nextgroup=typescriptGlobalNumberDot,typescriptFuncCallArg
    3              0.000082 syntax match   typescriptGlobalNumberDot /\./ contained nextgroup=typescriptNumberStaticProp,typescriptNumberStaticMethod,typescriptProp
    3              0.000015 syntax keyword typescriptNumberStaticProp contained EPSILON MAX_SAFE_INTEGER MAX_VALUE
    3              0.000013 syntax keyword typescriptNumberStaticProp contained MIN_SAFE_INTEGER MIN_VALUE NEGATIVE_INFINITY
    3              0.000011 syntax keyword typescriptNumberStaticProp contained NaN POSITIVE_INFINITY
    3              0.000068 if exists("did_typescript_hilink") | HiLink typescriptNumberStaticProp Keyword
    3              0.000004 endif
    3              0.000033 syntax keyword typescriptNumberStaticMethod contained isFinite isInteger isNaN isSafeInteger nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptNumberStaticMethod contained parseFloat parseInt nextgroup=typescriptFuncCallArg
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptNumberStaticMethod Keyword
    3              0.000003 endif
    3              0.000045 syntax keyword typescriptNumberMethod contained toExponential toFixed toLocaleString nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptNumberMethod contained toPrecision toSource toString valueOf nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptNumberMethod
    3              0.000046 if exists("did_typescript_hilink") | HiLink typescriptNumberMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-string.vim
Sourced 3 times
Total time:   0.000699
 Self time:   0.000699

count  total (s)   self (s)
    3              0.000081 syntax keyword typescriptGlobal containedin=typescriptIdentifierName String nextgroup=typescriptGlobalStringDot,typescriptFuncCallArg
    3              0.000060 syntax match   typescriptGlobalStringDot /\./ contained nextgroup=typescriptStringStaticMethod,typescriptProp
    3              0.000029 syntax keyword typescriptStringStaticMethod contained fromCharCode fromCodePoint raw nextgroup=typescriptFuncCallArg
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptStringStaticMethod Keyword
    3              0.000004 endif
    3              0.000047 syntax keyword typescriptStringMethod contained anchor charAt charCodeAt codePointAt nextgroup=typescriptFuncCallArg
    3              0.000031 syntax keyword typescriptStringMethod contained concat endsWith includes indexOf lastIndexOf nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptStringMethod contained link localeCompare match normalize nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptStringMethod contained padStart padEnd repeat replace search nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptStringMethod contained slice split startsWith substr substring nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptStringMethod contained toLocaleLowerCase toLocaleUpperCase nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptStringMethod contained toLowerCase toString toUpperCase trim nextgroup=typescriptFuncCallArg
    3              0.000022 syntax keyword typescriptStringMethod contained valueOf nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptStringMethod
    3              0.000049 if exists("did_typescript_hilink") | HiLink typescriptStringMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-array.vim
Sourced 3 times
Total time:   0.000848
 Self time:   0.000848

count  total (s)   self (s)
    3              0.000080 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Array nextgroup=typescriptGlobalArrayDot,typescriptFuncCallArg
    3              0.000059 syntax match   typescriptGlobalArrayDot /\./ contained nextgroup=typescriptArrayStaticMethod,typescriptProp
    3              0.000029 syntax keyword typescriptArrayStaticMethod contained from isArray of nextgroup=typescriptFuncCallArg
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptArrayStaticMethod Keyword
    3              0.000004 endif
    3              0.000049 syntax keyword typescriptArrayMethod contained concat copyWithin entries every fill nextgroup=typescriptFuncCallArg
    3              0.000029 syntax keyword typescriptArrayMethod contained filter find findIndex forEach indexOf nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptArrayMethod contained includes join keys lastIndexOf map nextgroup=typescriptFuncCallArg
    3              0.000144 syntax keyword typescriptArrayMethod contained pop push reduce reduceRight reverse nextgroup=typescriptFuncCallArg
    3              0.000090 syntax keyword typescriptArrayMethod contained shift slice some sort splice toLocaleString nextgroup=typescriptFuncCallArg
    3              0.000041 syntax keyword typescriptArrayMethod contained toSource toString unshift nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptArrayMethod
    3              0.000052 if exists("did_typescript_hilink") | HiLink typescriptArrayMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-object.vim
Sourced 3 times
Total time:   0.001120
 Self time:   0.001120

count  total (s)   self (s)
    3              0.000110 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Object nextgroup=typescriptGlobalObjectDot,typescriptFuncCallArg
    3              0.000187 syntax match   typescriptGlobalObjectDot /\./ contained nextgroup=typescriptObjectStaticMethod,typescriptProp
    3              0.000085 syntax keyword typescriptObjectStaticMethod contained create defineProperties defineProperty nextgroup=typescriptFuncCallArg
    3              0.000058 syntax keyword typescriptObjectStaticMethod contained entries freeze getOwnPropertyDescriptors nextgroup=typescriptFuncCallArg
    3              0.000054 syntax keyword typescriptObjectStaticMethod contained getOwnPropertyDescriptor getOwnPropertyNames nextgroup=typescriptFuncCallArg
    3              0.000054 syntax keyword typescriptObjectStaticMethod contained getOwnPropertySymbols getPrototypeOf nextgroup=typescriptFuncCallArg
    3              0.000070 syntax keyword typescriptObjectStaticMethod contained is isExtensible isFrozen isSealed nextgroup=typescriptFuncCallArg
    3              0.000054 syntax keyword typescriptObjectStaticMethod contained keys preventExtensions values nextgroup=typescriptFuncCallArg
    3              0.000071 if exists("did_typescript_hilink") | HiLink typescriptObjectStaticMethod Keyword
    3              0.000004 endif
    3              0.000060 syntax keyword typescriptObjectMethod contained getOwnPropertyDescriptors hasOwnProperty nextgroup=typescriptFuncCallArg
    3              0.000052 syntax keyword typescriptObjectMethod contained isPrototypeOf propertyIsEnumerable nextgroup=typescriptFuncCallArg
    3              0.000042 syntax keyword typescriptObjectMethod contained toLocaleString toString valueOf seal nextgroup=typescriptFuncCallArg
    3              0.000037 syntax keyword typescriptObjectMethod contained setPrototypeOf nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptObjectMethod
    3              0.000053 if exists("did_typescript_hilink") | HiLink typescriptObjectMethod Keyword
    3              0.000015 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-symbol.vim
Sourced 3 times
Total time:   0.000581
 Self time:   0.000581

count  total (s)   self (s)
    3              0.000098 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Symbol nextgroup=typescriptGlobalSymbolDot,typescriptFuncCallArg
    3              0.000080 syntax match   typescriptGlobalSymbolDot /\./ contained nextgroup=typescriptSymbolStaticProp,typescriptSymbolStaticMethod,typescriptProp
    3              0.000044 syntax keyword typescriptSymbolStaticProp contained length iterator match replace
    3              0.000028 syntax keyword typescriptSymbolStaticProp contained search split hasInstance isConcatSpreadable
    3              0.000012 syntax keyword typescriptSymbolStaticProp contained unscopables species toPrimitive
    3              0.000008 syntax keyword typescriptSymbolStaticProp contained toStringTag
    3              0.000065 if exists("did_typescript_hilink") | HiLink typescriptSymbolStaticProp Keyword
    3              0.000004 endif
    3              0.000029 syntax keyword typescriptSymbolStaticMethod contained for keyFor nextgroup=typescriptFuncCallArg
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptSymbolStaticMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-function.vim
Sourced 3 times
Total time:   0.000331
 Self time:   0.000331

count  total (s)   self (s)
    3              0.000042 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function
    3              0.000047 syntax keyword typescriptFunctionMethod contained apply bind call nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptFunctionMethod
    3              0.000062 if exists("did_typescript_hilink") | HiLink typescriptFunctionMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-math.vim
Sourced 3 times
Total time:   0.000672
 Self time:   0.000672

count  total (s)   self (s)
    3              0.000079 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Math nextgroup=typescriptGlobalMathDot,typescriptFuncCallArg
    3              0.000079 syntax match   typescriptGlobalMathDot /\./ contained nextgroup=typescriptMathStaticProp,typescriptMathStaticMethod,typescriptProp
    3              0.000019 syntax keyword typescriptMathStaticProp contained E LN10 LN2 LOG10E LOG2E PI SQRT1_2
    3              0.000008 syntax keyword typescriptMathStaticProp contained SQRT2
    3              0.000061 if exists("did_typescript_hilink") | HiLink typescriptMathStaticProp Keyword
    3              0.000004 endif
    3              0.000033 syntax keyword typescriptMathStaticMethod contained abs acos acosh asin asinh atan nextgroup=typescriptFuncCallArg
    3              0.000031 syntax keyword typescriptMathStaticMethod contained atan2 atanh cbrt ceil clz32 cos nextgroup=typescriptFuncCallArg
    3              0.000029 syntax keyword typescriptMathStaticMethod contained cosh exp expm1 floor fround hypot nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptMathStaticMethod contained imul log log10 log1p log2 max nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptMathStaticMethod contained min pow random round sign sin nextgroup=typescriptFuncCallArg
    3              0.000038 syntax keyword typescriptMathStaticMethod contained sinh sqrt tan tanh trunc nextgroup=typescriptFuncCallArg
    3              0.000064 if exists("did_typescript_hilink") | HiLink typescriptMathStaticMethod Keyword
    3              0.000016 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-date.vim
Sourced 3 times
Total time:   0.000785
 Self time:   0.000785

count  total (s)   self (s)
    3              0.000084 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Date nextgroup=typescriptGlobalDateDot,typescriptFuncCallArg
    3              0.000059 syntax match   typescriptGlobalDateDot /\./ contained nextgroup=typescriptDateStaticMethod,typescriptProp
    3              0.000027 syntax keyword typescriptDateStaticMethod contained UTC now parse nextgroup=typescriptFuncCallArg
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptDateStaticMethod Keyword
    3              0.000004 endif
    3              0.000046 syntax keyword typescriptDateMethod contained getDate getDay getFullYear getHours nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDateMethod contained getMilliseconds getMinutes getMonth nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained getSeconds getTime getTimezoneOffset nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained getUTCDate getUTCDay getUTCFullYear nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained getUTCHours getUTCMilliseconds getUTCMinutes nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDateMethod contained getUTCMonth getUTCSeconds setDate setFullYear nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained setHours setMilliseconds setMinutes nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained setMonth setSeconds setTime setUTCDate nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained setUTCFullYear setUTCHours setUTCMilliseconds nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDateMethod contained setUTCMinutes setUTCMonth setUTCSeconds nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDateMethod contained toDateString toISOString toJSON toLocaleDateString nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDateMethod contained toLocaleFormat toLocaleString toLocaleTimeString nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDateMethod contained toSource toString toTimeString toUTCString nextgroup=typescriptFuncCallArg
    3              0.000022 syntax keyword typescriptDateMethod contained valueOf nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptDateMethod
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptDateMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-json.vim
Sourced 3 times
Total time:   0.000325
 Self time:   0.000325

count  total (s)   self (s)
    3              0.000080 syntax keyword typescriptGlobal containedin=typescriptIdentifierName JSON nextgroup=typescriptGlobalJSONDot,typescriptFuncCallArg
    3              0.000058 syntax match   typescriptGlobalJSONDot /\./ contained nextgroup=typescriptJSONStaticMethod,typescriptProp
    3              0.000026 syntax keyword typescriptJSONStaticMethod contained parse stringify nextgroup=typescriptFuncCallArg
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptJSONStaticMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-regexp.vim
Sourced 3 times
Total time:   0.000560
 Self time:   0.000560

count  total (s)   self (s)
    3              0.000078 syntax keyword typescriptGlobal containedin=typescriptIdentifierName RegExp nextgroup=typescriptGlobalRegExpDot,typescriptFuncCallArg
    3              0.000057 syntax match   typescriptGlobalRegExpDot /\./ contained nextgroup=typescriptRegExpStaticProp,typescriptProp
    3              0.000010 syntax keyword typescriptRegExpStaticProp contained lastIndex
    3              0.000059 if exists("did_typescript_hilink") | HiLink typescriptRegExpStaticProp Keyword
    3              0.000004 endif
    3              0.000030 syntax keyword typescriptRegExpProp contained global ignoreCase multiline source sticky
    3              0.000021 syntax cluster props add=typescriptRegExpProp
    3              0.000045 if exists("did_typescript_hilink") | HiLink typescriptRegExpProp Keyword
    3              0.000003 endif
    3              0.000041 syntax keyword typescriptRegExpMethod contained exec test nextgroup=typescriptFuncCallArg
    3              0.000017 syntax cluster props add=typescriptRegExpMethod
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptRegExpMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-map.vim
Sourced 3 times
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
    3              0.000043 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Map WeakMap
    3              0.000025 syntax keyword typescriptES6MapProp contained size
    3              0.000019 syntax cluster props add=typescriptES6MapProp
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptES6MapProp Keyword
    3              0.000004 endif
    3              0.000049 syntax keyword typescriptES6MapMethod contained clear delete entries forEach get has nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptES6MapMethod contained keys set values nextgroup=typescriptFuncCallArg
    3              0.000016 syntax cluster props add=typescriptES6MapMethod
    3              0.000045 if exists("did_typescript_hilink") | HiLink typescriptES6MapMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-set.vim
Sourced 3 times
Total time:   0.000433
 Self time:   0.000433

count  total (s)   self (s)
    3              0.000043 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Set WeakSet
    3              0.000025 syntax keyword typescriptES6SetProp contained size
    3              0.000019 syntax cluster props add=typescriptES6SetProp
    3              0.000056 if exists("did_typescript_hilink") | HiLink typescriptES6SetProp Keyword
    3              0.000004 endif
    3              0.000047 syntax keyword typescriptES6SetMethod contained add clear delete entries forEach has nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptES6SetMethod contained values nextgroup=typescriptFuncCallArg
    3              0.000016 syntax cluster props add=typescriptES6SetMethod
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptES6SetMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-proxy.vim
Sourced 3 times
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
    3              0.000040 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Proxy
    3              0.000028 syntax keyword typescriptProxyAPI contained getOwnPropertyDescriptor getOwnPropertyNames
    3              0.000015 syntax keyword typescriptProxyAPI contained defineProperty deleteProperty freeze seal
    3              0.000016 syntax keyword typescriptProxyAPI contained preventExtensions has hasOwn get set enumerate
    3              0.000012 syntax keyword typescriptProxyAPI contained iterate ownKeys apply construct
    3              0.000057 if exists("did_typescript_hilink") | HiLink typescriptProxyAPI Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-promise.vim
Sourced 3 times
Total time:   0.000493
 Self time:   0.000493

count  total (s)   self (s)
    3              0.000081 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Promise nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg
    3              0.000061 syntax match   typescriptGlobalPromiseDot /\./ contained nextgroup=typescriptPromiseStaticMethod,typescriptProp
    3              0.000030 syntax keyword typescriptPromiseStaticMethod contained resolve reject all race nextgroup=typescriptFuncCallArg
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptPromiseStaticMethod Keyword
    3              0.000004 endif
    3              0.000044 syntax keyword typescriptPromiseMethod contained then catch finally nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptPromiseMethod
    3              0.000045 if exists("did_typescript_hilink") | HiLink typescriptPromiseMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/es6-reflect.vim
Sourced 3 times
Total time:   0.000402
 Self time:   0.000402

count  total (s)   self (s)
    3              0.000041 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect
    3              0.000050 syntax keyword typescriptReflectMethod contained apply construct defineProperty deleteProperty nextgroup=typescriptFuncCallArg
    3              0.000029 syntax keyword typescriptReflectMethod contained enumerate get getOwnPropertyDescriptor nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptReflectMethod contained getPrototypeOf has isExtensible ownKeys nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptReflectMethod contained preventExtensions set setPrototypeOf nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptReflectMethod
    3              0.000057 if exists("did_typescript_hilink") | HiLink typescriptReflectMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/ecma-402.vim
Sourced 3 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
    3              0.000040 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Intl
    3              0.000047 syntax keyword typescriptIntlMethod contained Collator DateTimeFormat NumberFormat nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptIntlMethod contained PluralRules nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptIntlMethod
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptIntlMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/node.vim
Sourced 3 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
    3              0.000056 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName global process
    3              0.000026 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName console Buffer
    3              0.000024 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName module exports
    3              0.000021 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setTimeout
    3              0.000022 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearTimeout
    3              0.000021 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setInterval
    3              0.000021 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearInterval
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptNodeGlobal Structure
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/test.vim
Sourced 3 times
Total time:   0.000333
 Self time:   0.000333

count  total (s)   self (s)
    3              0.000054 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName describe
    3              0.000027 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName it test before
    3              0.000023 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName after beforeEach
    3              0.000021 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterEach
    3              0.000020 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName beforeAll
    3              0.000020 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterAll
    3              0.000030 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName expect assert

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web.vim
Sourced 3 times
Total time:   0.008050
 Self time:   0.008050

count  total (s)   self (s)
    3              0.000056 syntax keyword typescriptBOM containedin=typescriptIdentifierName AbortController
    3              0.000026 syntax keyword typescriptBOM containedin=typescriptIdentifierName AbstractWorker AnalyserNode
    3              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName App Apps ArrayBuffer
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName ArrayBufferView
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName Attr AudioBuffer
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioBufferSourceNode
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioContext AudioDestinationNode
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioListener AudioNode
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioParam BatteryManager
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName BiquadFilterNode
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName BlobEvent BluetoothAdapter
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothDevice
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothManager
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraCapabilities
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraControl CameraManager
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasGradient CanvasImageSource
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasPattern CanvasRenderingContext2D
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName CaretPosition CDATASection
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelMergerNode
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelSplitterNode
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName CharacterData ChildNode
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChromeWorker Comment
    3              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Connection Console
    3              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName ContactManager Contacts
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName ConvolverNode Coordinates
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSS CSSConditionRule
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSGroupingRule
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframeRule
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframesRule
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSMediaRule CSSNamespaceRule
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSPageRule CSSRule
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSRuleList CSSStyleDeclaration
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSStyleRule CSSStyleSheet
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSSupportsRule
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName DataTransfer DataView
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName DedicatedWorkerGlobalScope
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DelayNode DeviceAcceleration
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceRotationRate
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceStorage DirectoryEntry
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryEntrySync
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReader
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReaderSync
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName Document DocumentFragment
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DocumentTouch DocumentType
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMCursor DOMError
    3              0.000056 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMException DOMHighResTimeStamp
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementation
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementationRegistry
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMParser DOMRequest
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMString DOMStringList
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMStringMap DOMTimeStamp
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMTokenList DynamicsCompressorNode
    3              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName Element Entry EntrySync
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Extensions FileException
    3              0.000033 syntax keyword typescriptBOM containedin=typescriptIdentifierName Float32Array Float64Array
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName FMRadio FormData
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName GainNode Gamepad
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName GamepadButton Geolocation
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName History HTMLAnchorElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAreaElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAudioElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBaseElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBodyElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBRElement HTMLButtonElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCanvasElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCollection HTMLDataElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDataListElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDivElement HTMLDListElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDocument HTMLElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLEmbedElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFieldSetElement
    3              0.000080 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormControlsCollection
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadingElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHRElement HTMLHtmlElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLIFrameElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLImageElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLInputElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLKeygenElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLabelElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLegendElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLIElement HTMLLinkElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMapElement HTMLMediaElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMetaElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMeterElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLModElement HTMLObjectElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOListElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptGroupElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionsCollection
    3              0.000033 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOutputElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParagraphElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParamElement
    3              0.000044 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLPreElement HTMLProgressElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLQuoteElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLScriptElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSelectElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSourceElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSpanElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLStyleElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCaptionElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCellElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableColElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableDataCellElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableHeaderCellElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableRowElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableSectionElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTextAreaElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTimeElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTitleElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTrackElement
    3              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUListElement
    3              0.000028 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUnknownElement
    3              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLVideoElement
    3              0.000030 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursor IDBCursorSync
    3              0.000028 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursorWithValue
    3              0.000030 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBDatabase IDBDatabaseSync
    3              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBEnvironment IDBEnvironmentSync
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBFactory IDBFactorySync
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBIndex IDBIndexSync
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBKeyRange IDBObjectStore
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBObjectStoreSync
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBOpenDBRequest
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBRequest IDBTransaction
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBTransactionSync
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBVersionChangeEvent
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName ImageData IndexedDB
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Int16Array Int32Array
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Int8Array L10n LinkStyle
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystem
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystemSync
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName Location LockedFile
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaQueryList MediaQueryListListener
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaRecorder MediaSource
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaStream MediaStreamTrack
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName MutationObserver
    3              0.000037 syntax keyword typescriptBOM containedin=typescriptIdentifierName Navigator NavigatorGeolocation
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorID NavigatorLanguage
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorOnLine
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorPlugins
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName Node NodeFilter
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName NodeIterator NodeList
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Notification OfflineAudioContext
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName OscillatorNode PannerNode
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName ParentNode Performance
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceNavigation
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceTiming
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName Permissions PermissionSettings
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName Plugin PluginArray
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName Position PositionError
    3              0.000031 syntax keyword typescriptBOM containedin=typescriptIdentifierName PositionOptions
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName PowerManager ProcessingInstruction
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName PromiseResolver
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName PushManager Range
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCConfiguration
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnection
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnectionErrorCallback
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescription
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescriptionCallback
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName ScriptProcessorNode
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName Selection SettingsLock
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SettingsManager
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SharedWorker StyleSheet
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName StyleSheetList SVGAElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAngle SVGAnimateColorElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedAngle
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedBoolean
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedEnumeration
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedInteger
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLength
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLengthList
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumber
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumberList
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPoints
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPreserveAspectRatio
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedRect
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedString
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedTransformList
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateMotionElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateTransformElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimationElement
    3              0.000031 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCircleElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGClipPathElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCursorElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGDefsElement SVGDescElement
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGElement SVGEllipseElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFilterElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontElement SVGFontFaceElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceFormatElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceNameElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceSrcElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceUriElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGForeignObjectElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGElement SVGGlyphElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGradientElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGHKernElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGImageElement
    3              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLength SVGLengthList
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLinearGradientElement
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLineElement SVGMaskElement
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMatrix SVGMissingGlyphElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMPathElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGNumber SVGNumberList
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPathElement SVGPatternElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPoint SVGPolygonElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPolylineElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPreserveAspectRatio
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRadialGradientElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRect SVGRectElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGScriptElement
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSetElement SVGStopElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStringList SVGStylable
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStyleElement
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSVGElement SVGSwitchElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSymbolElement
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTests SVGTextElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTextPositioningElement
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTitleElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransform SVGTransformable
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransformList
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTRefElement SVGTSpanElement
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGUseElement SVGViewElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGVKernElement
    3              0.000020 syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPServerSocket
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPSocket Telephony
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName TelephonyCall Text
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName TextDecoder TextEncoder
    3              0.000448 syntax keyword typescriptBOM containedin=typescriptIdentifierName TextMetrics TimeRanges
    3              0.000206 syntax keyword typescriptBOM containedin=typescriptIdentifierName Touch TouchList
    3              0.000179 syntax keyword typescriptBOM containedin=typescriptIdentifierName Transferable TreeWalker
    3              0.000027 syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint16Array Uint32Array
    3              0.000022 syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint8Array Uint8ClampedArray
    3              0.000093 syntax keyword typescriptBOM containedin=typescriptIdentifierName URLSearchParams
    3              0.000094 syntax keyword typescriptBOM containedin=typescriptIdentifierName URLUtilsReadOnly
    3              0.000093 syntax keyword typescriptBOM containedin=typescriptIdentifierName UserProximityEvent
    3              0.000160 syntax keyword typescriptBOM containedin=typescriptIdentifierName ValidityState VideoPlaybackQuality
    3              0.000157 syntax keyword typescriptBOM containedin=typescriptIdentifierName WaveShaperNode WebBluetooth
    3              0.000089 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebGLRenderingContext
    3              0.000156 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebSMS WebSocket
    3              0.000157 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebVTT WifiManager
    3              0.000227 syntax keyword typescriptBOM containedin=typescriptIdentifierName Window Worker WorkerConsole
    3              0.000160 syntax keyword typescriptBOM containedin=typescriptIdentifierName WorkerLocation WorkerNavigator
    3              0.000159 syntax keyword typescriptBOM containedin=typescriptIdentifierName XDomainRequest XMLDocument
    3              0.000090 syntax keyword typescriptBOM containedin=typescriptIdentifierName XMLHttpRequestEventTarget
    3              0.000082 if exists("did_typescript_hilink") | HiLink typescriptBOM Structure
    3              0.000013 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-window.vim
Sourced 3 times
Total time:   0.011215
 Self time:   0.011215

count  total (s)   self (s)
    3              0.000136 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName applicationCache
    3              0.000097 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName closed
    3              0.000096 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName Components
    3              0.000093 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName controllers
    3              0.000094 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName dialogArguments
    3              0.000092 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName document
    3              0.000092 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frameElement
    3              0.000090 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frames
    3              0.000090 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName fullScreen
    3              0.000089 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName history
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerHeight
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerWidth
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName length
    3              0.000088 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName location
    3              0.000089 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName locationbar
    3              0.000089 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName menubar
    3              0.000088 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName messageManager
    3              0.000156 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName name navigator
    3              0.000090 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName opener
    3              0.000089 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerHeight
    3              0.000090 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerWidth
    3              0.000088 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageXOffset
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageYOffset
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName parent
    3              0.000088 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName performance
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName personalbar
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName returnValue
    3              0.000092 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screen
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenX
    3              0.000090 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenY
    3              0.000089 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollbars
    3              0.000091 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxX
    3              0.000089 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxY
    3              0.000101 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollX
    3              0.000093 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollY
    3              0.000092 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName self sidebar
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName status
    3              0.000087 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName statusbar
    3              0.000092 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName toolbar
    3              0.000101 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName top visualViewport
    3              0.000090 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName window
    3              0.000025 syntax cluster props add=typescriptBOMWindowProp
    3              0.000078 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowProp Structure
    3              0.000005 endif
    3              0.000061 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName alert nextgroup=typescriptFuncCallArg
    3              0.000109 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName atob nextgroup=typescriptFuncCallArg
    3              0.000129 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName blur nextgroup=typescriptFuncCallArg
    3              0.000107 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName btoa nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearImmediate nextgroup=typescriptFuncCallArg
    3              0.000040 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearInterval nextgroup=typescriptFuncCallArg
    3              0.000037 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearTimeout nextgroup=typescriptFuncCallArg
    3              0.000102 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName close nextgroup=typescriptFuncCallArg
    3              0.000039 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName confirm nextgroup=typescriptFuncCallArg
    3              0.000105 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName dispatchEvent nextgroup=typescriptFuncCallArg
    3              0.000039 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName find nextgroup=typescriptFuncCallArg
    3              0.000105 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName focus nextgroup=typescriptFuncCallArg
    3              0.000208 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttention nextgroup=typescriptFuncCallArg
    3              0.000107 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttentionWithCycleCount nextgroup=typescriptFuncCallArg
    3              0.000107 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getComputedStyle nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getDefaulComputedStyle nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getSelection nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName matchMedia nextgroup=typescriptFuncCallArg
    3              0.000107 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName maximize nextgroup=typescriptFuncCallArg
    3              0.000104 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveBy nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveTo nextgroup=typescriptFuncCallArg
    3              0.000105 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName open nextgroup=typescriptFuncCallArg
    3              0.000107 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName openDialog nextgroup=typescriptFuncCallArg
    3              0.000105 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName postMessage nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName print nextgroup=typescriptFuncCallArg
    3              0.000039 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName prompt nextgroup=typescriptFuncCallArg
    3              0.000102 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName removeEventListener nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeBy nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeTo nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName restore nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scroll nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollBy nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByLines nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByPages nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollTo nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setCursor nextgroup=typescriptFuncCallArg
    3              0.000120 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setImmediate nextgroup=typescriptFuncCallArg
    3              0.000039 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setInterval nextgroup=typescriptFuncCallArg
    3              0.000106 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setResizable nextgroup=typescriptFuncCallArg
    3              0.000039 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setTimeout nextgroup=typescriptFuncCallArg
    3              0.000103 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName showModalDialog nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName sizeToContent nextgroup=typescriptFuncCallArg
    3              0.000107 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName stop nextgroup=typescriptFuncCallArg
    3              0.000108 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName updateCommands nextgroup=typescriptFuncCallArg
    3              0.000022 syntax cluster props add=typescriptBOMWindowMethod
    3              0.000066 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowMethod Structure
    3              0.000004 endif
    3              0.000312 syntax keyword typescriptBOMWindowEvent contained onabort onbeforeunload onblur onchange
    3              0.000290 syntax keyword typescriptBOMWindowEvent contained onclick onclose oncontextmenu ondevicelight
    3              0.000157 syntax keyword typescriptBOMWindowEvent contained ondevicemotion ondeviceorientation
    3              0.000235 syntax keyword typescriptBOMWindowEvent contained ondeviceproximity ondragdrop onerror
    3              0.000295 syntax keyword typescriptBOMWindowEvent contained onfocus onhashchange onkeydown onkeypress
    3              0.000278 syntax keyword typescriptBOMWindowEvent contained onkeyup onload onmousedown onmousemove
    3              0.000210 syntax keyword typescriptBOMWindowEvent contained onmouseout onmouseover onmouseup
    3              0.000211 syntax keyword typescriptBOMWindowEvent contained onmozbeforepaint onpaint onpopstate
    3              0.000278 syntax keyword typescriptBOMWindowEvent contained onreset onresize onscroll onselect
    3              0.000214 syntax keyword typescriptBOMWindowEvent contained onsubmit onunload onuserproximity
    3              0.000146 syntax keyword typescriptBOMWindowEvent contained onpageshow onpagehide
    3              0.000069 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowEvent Keyword
    3              0.000004 endif
    3              0.000047 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName DOMParser
    3              0.000023 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName QueryInterface
    3              0.000022 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName XMLSerializer
    3              0.000052 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowCons Structure
    3              0.000015 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-navigator.vim
Sourced 3 times
Total time:   0.000661
 Self time:   0.000661

count  total (s)   self (s)
    3              0.000052 syntax keyword typescriptBOMNavigatorProp contained battery buildID connection cookieEnabled
    3              0.000013 syntax keyword typescriptBOMNavigatorProp contained doNotTrack maxTouchPoints oscpu
    3              0.000011 syntax keyword typescriptBOMNavigatorProp contained productSub push serviceWorker
    3              0.000009 syntax keyword typescriptBOMNavigatorProp contained vendor vendorSub
    3              0.000023 syntax cluster props add=typescriptBOMNavigatorProp
    3              0.000070 if exists("did_typescript_hilink") | HiLink typescriptBOMNavigatorProp Keyword
    3              0.000004 endif
    3              0.000048 syntax keyword typescriptBOMNavigatorMethod contained addIdleObserver geolocation nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptBOMNavigatorMethod contained getDeviceStorage getDeviceStorages nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptBOMNavigatorMethod contained getGamepads getUserMedia registerContentHandler nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptBOMNavigatorMethod contained removeIdleObserver requestWakeLock nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptBOMNavigatorMethod contained share vibrate watch registerProtocolHandler nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptBOMNavigatorMethod contained sendBeacon nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptBOMNavigatorMethod
    3              0.000053 if exists("did_typescript_hilink") | HiLink typescriptBOMNavigatorMethod Keyword
    3              0.000003 endif
    3              0.000040 syntax keyword typescriptServiceWorkerMethod contained register nextgroup=typescriptFuncCallArg
    3              0.000018 syntax cluster props add=typescriptServiceWorkerMethod
    3              0.000046 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-location.vim
Sourced 3 times
Total time:   0.000424
 Self time:   0.000424

count  total (s)   self (s)
    3              0.000045 syntax keyword typescriptBOMLocationProp contained href protocol host hostname port
    3              0.000014 syntax keyword typescriptBOMLocationProp contained pathname search hash username password
    3              0.000008 syntax keyword typescriptBOMLocationProp contained origin
    3              0.000020 syntax cluster props add=typescriptBOMLocationProp
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptBOMLocationProp Keyword
    3              0.000004 endif
    3              0.000046 syntax keyword typescriptBOMLocationMethod contained assign reload replace toString nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptBOMLocationMethod
    3              0.000046 if exists("did_typescript_hilink") | HiLink typescriptBOMLocationMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-history.vim
Sourced 3 times
Total time:   0.000348
 Self time:   0.000348

count  total (s)   self (s)
    3              0.000044 syntax keyword typescriptBOMHistoryProp contained length current next previous state
    3              0.000009 syntax keyword typescriptBOMHistoryProp contained scrollRestoration
    3              0.000021 syntax cluster props add=typescriptBOMHistoryProp
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptBOMHistoryProp Keyword
    3              0.000004 endif
    3              0.000046 syntax keyword typescriptBOMHistoryMethod contained back forward go pushState replaceState nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptBOMHistoryMethod
    3              0.000044 if exists("did_typescript_hilink") | HiLink typescriptBOMHistoryMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-console.vim
Sourced 3 times
Total time:   0.000382
 Self time:   0.000382

count  total (s)   self (s)
    3              0.000044 syntax keyword typescriptGlobal containedin=typescriptIdentifierName console
    3              0.000053 syntax keyword typescriptConsoleMethod contained count dir error group groupCollapsed nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptConsoleMethod contained groupEnd info log time timeEnd trace nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptConsoleMethod contained warn nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptConsoleMethod
    3              0.000057 if exists("did_typescript_hilink") | HiLink typescriptConsoleMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-xhr.vim
Sourced 3 times
Total time:   0.000546
 Self time:   0.000546

count  total (s)   self (s)
    3              0.000074 syntax keyword typescriptXHRGlobal containedin=typescriptIdentifierName XMLHttpRequest
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptXHRGlobal Structure
    3              0.000004 endif
    3              0.000026 syntax keyword typescriptXHRProp contained onreadystatechange readyState response
    3              0.000013 syntax keyword typescriptXHRProp contained responseText responseType responseXML status
    3              0.000013 syntax keyword typescriptXHRProp contained statusText timeout ontimeout upload withCredentials
    3              0.000021 syntax cluster props add=typescriptXHRProp
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptXHRProp Keyword
    3              0.000004 endif
    3              0.000040 syntax keyword typescriptXHRMethod contained abort getAllResponseHeaders getResponseHeader nextgroup=typescriptFuncCallArg
    3              0.000030 syntax keyword typescriptXHRMethod contained open overrideMimeType send setRequestHeader nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptXHRMethod
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptXHRMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-blob.vim
Sourced 3 times
Total time:   0.001164
 Self time:   0.001164

count  total (s)   self (s)
    3              0.000043 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Blob BlobBuilder
    3              0.000027 syntax keyword typescriptGlobal containedin=typescriptIdentifierName File FileReader
    3              0.000025 syntax keyword typescriptGlobal containedin=typescriptIdentifierName FileReaderSync
    3              0.000064 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URL nextgroup=typescriptGlobalURLDot,typescriptFuncCallArg
    3              0.000067 syntax match   typescriptGlobalURLDot /\./ contained nextgroup=typescriptURLStaticMethod,typescriptProp
    3              0.000027 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URLUtils
    3              0.000041 syntax keyword typescriptFileMethod contained readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptFileMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    3              0.000021 syntax cluster props add=typescriptFileMethod
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptFileMethod Keyword
    3              0.000004 endif
    3              0.000026 syntax keyword typescriptFileReaderProp contained error readyState result
    3              0.000019 syntax cluster props add=typescriptFileReaderProp
    3              0.000045 if exists("did_typescript_hilink") | HiLink typescriptFileReaderProp Keyword
    3              0.000003 endif
    3              0.000042 syntax keyword typescriptFileReaderMethod contained abort readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptFileReaderMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptFileReaderMethod
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptFileReaderMethod Keyword
    3              0.000003 endif
    3              0.000037 syntax keyword typescriptFileListMethod contained item nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptFileListMethod
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptFileListMethod Keyword
    3              0.000003 endif
    3              0.000040 syntax keyword typescriptBlobMethod contained append getBlob getFile nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptBlobMethod
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptBlobMethod Keyword
    3              0.000003 endif
    3              0.000029 syntax keyword typescriptURLUtilsProp contained hash host hostname href origin password
    3              0.000013 syntax keyword typescriptURLUtilsProp contained pathname port protocol search searchParams
    3              0.000007 syntax keyword typescriptURLUtilsProp contained username
    3              0.000018 syntax cluster props add=typescriptURLUtilsProp
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptURLUtilsProp Keyword
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptURLStaticMethod contained createObjectURL revokeObjectURL nextgroup=typescriptFuncCallArg
    3              0.000040 if exists("did_typescript_hilink") | HiLink typescriptURLStaticMethod Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-crypto.vim
Sourced 3 times
Total time:   0.000583
 Self time:   0.000583

count  total (s)   self (s)
    3              0.000055 syntax keyword typescriptCryptoGlobal containedin=typescriptIdentifierName crypto
    3              0.000055 if exists("did_typescript_hilink") | HiLink typescriptCryptoGlobal Structure
    3              0.000004 endif
    3              0.000044 syntax keyword typescriptSubtleCryptoMethod contained encrypt decrypt sign verify nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptSubtleCryptoMethod contained digest nextgroup=typescriptFuncCallArg
    3              0.000021 syntax cluster props add=typescriptSubtleCryptoMethod
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptSubtleCryptoMethod Keyword
    3              0.000003 endif
    3              0.000021 syntax keyword typescriptCryptoProp contained subtle
    3              0.000019 syntax cluster props add=typescriptCryptoProp
    3              0.000040 if exists("did_typescript_hilink") | HiLink typescriptCryptoProp Keyword
    3              0.000003 endif
    3              0.000037 syntax keyword typescriptCryptoMethod contained getRandomValues nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptCryptoMethod
    3              0.000040 if exists("did_typescript_hilink") | HiLink typescriptCryptoMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-fetch.vim
Sourced 3 times
Total time:   0.000866
 Self time:   0.000866

count  total (s)   self (s)
    3              0.000044 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Headers Request
    3              0.000026 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Response
    3              0.000039 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName fetch nextgroup=typescriptFuncCallArg
    3              0.000027 syntax cluster props add=typescriptGlobalMethod
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptGlobalMethod Structure
    3              0.000003 endif
    3              0.000049 syntax keyword typescriptHeadersMethod contained append delete get getAll has set nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptHeadersMethod
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptHeadersMethod Keyword
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptRequestProp contained method url headers context referrer
    3              0.000013 syntax keyword typescriptRequestProp contained mode credentials cache
    3              0.000019 syntax cluster props add=typescriptRequestProp
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptRequestProp Keyword
    3              0.000003 endif
    3              0.000038 syntax keyword typescriptRequestMethod contained clone nextgroup=typescriptFuncCallArg
    3              0.000019 syntax cluster props add=typescriptRequestMethod
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptRequestMethod Keyword
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptResponseProp contained type url status statusText headers
    3              0.000008 syntax keyword typescriptResponseProp contained redirected
    3              0.000018 syntax cluster props add=typescriptResponseProp
    3              0.000040 if exists("did_typescript_hilink") | HiLink typescriptResponseProp Keyword
    3              0.000003 endif
    3              0.000037 syntax keyword typescriptResponseMethod contained clone nextgroup=typescriptFuncCallArg
    3              0.000021 syntax cluster props add=typescriptResponseMethod
    3              0.000040 if exists("did_typescript_hilink") | HiLink typescriptResponseMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-service-worker.vim
Sourced 3 times
Total time:   0.000532
 Self time:   0.000532

count  total (s)   self (s)
    3              0.000040 syntax keyword typescriptServiceWorkerProp contained controller ready
    3              0.000024 syntax cluster props add=typescriptServiceWorkerProp
    3              0.000055 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerProp Keyword
    3              0.000004 endif
    3              0.000029 syntax keyword typescriptServiceWorkerMethod contained register getRegistration nextgroup=typescriptFuncCallArg
    3              0.000023 syntax cluster props add=typescriptServiceWorkerMethod
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerMethod Keyword
    3              0.000003 endif
    3              0.000029 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Cache
    3              0.000045 syntax keyword typescriptCacheMethod contained match matchAll add addAll put delete nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptCacheMethod contained keys nextgroup=typescriptFuncCallArg
    3              0.000020 syntax cluster props add=typescriptCacheMethod
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptCacheMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-encoding.vim
Sourced 3 times
Total time:   0.000480
 Self time:   0.000480

count  total (s)   self (s)
    3              0.000055 syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextEncoder
    3              0.000023 syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextDecoder
    3              0.000053 if exists("did_typescript_hilink") | HiLink typescriptEncodingGlobal Structure
    3              0.000004 endif
    3              0.000026 syntax keyword typescriptEncodingProp contained encoding fatal ignoreBOM
    3              0.000022 syntax cluster props add=typescriptEncodingProp
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptEncodingProp Keyword
    3              0.000003 endif
    3              0.000040 syntax keyword typescriptEncodingMethod contained encode decode nextgroup=typescriptFuncCallArg
    3              0.000021 syntax cluster props add=typescriptEncodingMethod
    3              0.000040 if exists("did_typescript_hilink") | HiLink typescriptEncodingMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-geo.vim
Sourced 3 times
Total time:   0.000351
 Self time:   0.000351

count  total (s)   self (s)
    3              0.000045 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Geolocation
    3              0.000046 syntax keyword typescriptGeolocationMethod contained getCurrentPosition watchPosition nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptGeolocationMethod contained clearWatch nextgroup=typescriptFuncCallArg
    3              0.000024 syntax cluster props add=typescriptGeolocationMethod
    3              0.000055 if exists("did_typescript_hilink") | HiLink typescriptGeolocationMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-network.vim
Sourced 3 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
    3              0.000042 syntax keyword typescriptGlobal containedin=typescriptIdentifierName NetworkInformation
    3              0.000029 syntax keyword typescriptBOMNetworkProp contained downlink downlinkMax effectiveType
    3              0.000010 syntax keyword typescriptBOMNetworkProp contained rtt type
    3              0.000024 syntax cluster props add=typescriptBOMNetworkProp
    3              0.000056 if exists("did_typescript_hilink") | HiLink typescriptBOMNetworkProp Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/web-payment.vim
Sourced 3 times
Total time:   0.000921
 Self time:   0.000921

count  total (s)   self (s)
    3              0.000041 syntax keyword typescriptGlobal containedin=typescriptIdentifierName PaymentRequest
    3              0.000047 syntax keyword typescriptPaymentMethod contained show abort canMakePayment nextgroup=typescriptFuncCallArg
    3              0.000026 syntax cluster props add=typescriptPaymentMethod
    3              0.000056 if exists("did_typescript_hilink") | HiLink typescriptPaymentMethod Keyword
    3              0.000004 endif
    3              0.000026 syntax keyword typescriptPaymentProp contained shippingAddress shippingOption result
    3              0.000022 syntax cluster props add=typescriptPaymentProp
    3              0.000044 if exists("did_typescript_hilink") | HiLink typescriptPaymentProp Keyword
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptPaymentEvent contained onshippingaddresschange onshippingoptionchange
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptPaymentEvent Keyword
    3              0.000003 endif
    3              0.000039 syntax keyword typescriptPaymentResponseMethod contained complete nextgroup=typescriptFuncCallArg
    3              0.000023 syntax cluster props add=typescriptPaymentResponseMethod
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptPaymentResponseMethod Keyword
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptPaymentResponseProp contained details methodName payerEmail
    3              0.000010 syntax keyword typescriptPaymentResponseProp contained payerPhone shippingAddress
    3              0.000008 syntax keyword typescriptPaymentResponseProp contained shippingOption
    3              0.000021 syntax cluster props add=typescriptPaymentResponseProp
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptPaymentResponseProp Keyword
    3              0.000003 endif
    3              0.000025 syntax keyword typescriptPaymentAddressProp contained addressLine careOf city country
    3              0.000010 syntax keyword typescriptPaymentAddressProp contained country dependentLocality languageCode
    3              0.000010 syntax keyword typescriptPaymentAddressProp contained organization phone postalCode
    3              0.000009 syntax keyword typescriptPaymentAddressProp contained recipient region sortingCode
    3              0.000022 syntax cluster props add=typescriptPaymentAddressProp
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptPaymentAddressProp Keyword
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptPaymentShippingOptionProp contained id label amount selected
    3              0.000024 syntax cluster props add=typescriptPaymentShippingOptionProp
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptPaymentShippingOptionProp Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/dom-node.vim
Sourced 3 times
Total time:   0.000699
 Self time:   0.000699

count  total (s)   self (s)
    3              0.000041 syntax keyword typescriptDOMNodeProp contained attributes baseURI baseURIObject childNodes
    3              0.000013 syntax keyword typescriptDOMNodeProp contained firstChild lastChild localName namespaceURI
    3              0.000011 syntax keyword typescriptDOMNodeProp contained nextSibling nodeName nodePrincipal
    3              0.000011 syntax keyword typescriptDOMNodeProp contained nodeType nodeValue ownerDocument parentElement
    3              0.000012 syntax keyword typescriptDOMNodeProp contained parentNode prefix previousSibling textContent
    3              0.000025 syntax cluster props add=typescriptDOMNodeProp
    3              0.000055 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeProp Keyword
    3              0.000004 endif
    3              0.000046 syntax keyword typescriptDOMNodeMethod contained appendChild cloneNode compareDocumentPosition nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptDOMNodeMethod contained getUserData hasAttributes hasChildNodes nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDOMNodeMethod contained insertBefore isDefaultNamespace isEqualNode nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDOMNodeMethod contained isSameNode isSupported lookupNamespaceURI nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDOMNodeMethod contained lookupPrefix normalize removeChild nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptDOMNodeMethod contained replaceChild setUserData nextgroup=typescriptFuncCallArg
    3              0.000025 syntax match typescriptDOMNodeMethod contained /contains/
    3              0.000024 syntax cluster props add=typescriptDOMNodeMethod
    3              0.000044 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeMethod Keyword
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptDOMNodeType contained ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE
    3              0.000010 syntax keyword typescriptDOMNodeType contained CDATA_SECTION_NODEN_NODE ENTITY_REFERENCE_NODE
    3              0.000009 syntax keyword typescriptDOMNodeType contained ENTITY_NODE PROCESSING_INSTRUCTION_NODEN_NODE
    3              0.000010 syntax keyword typescriptDOMNodeType contained COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE
    3              0.000009 syntax keyword typescriptDOMNodeType contained DOCUMENT_FRAGMENT_NODE NOTATION_NODE
    3              0.000041 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeType Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/dom-elem.vim
Sourced 3 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
    3              0.000041 syntax keyword typescriptDOMElemAttrs contained accessKey clientHeight clientLeft
    3              0.000013 syntax keyword typescriptDOMElemAttrs contained clientTop clientWidth id innerHTML
    3              0.000012 syntax keyword typescriptDOMElemAttrs contained length onafterscriptexecute onbeforescriptexecute
    3              0.000012 syntax keyword typescriptDOMElemAttrs contained oncopy oncut onpaste onwheel scrollHeight
    3              0.000011 syntax keyword typescriptDOMElemAttrs contained scrollLeft scrollTop scrollWidth tagName
    3              0.000012 syntax keyword typescriptDOMElemAttrs contained classList className name outerHTML
    3              0.000007 syntax keyword typescriptDOMElemAttrs contained style
    3              0.000056 if exists("did_typescript_hilink") | HiLink typescriptDOMElemAttrs Keyword
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptDOMElemFuncs contained getAttributeNS getAttributeNode getAttributeNodeNS
    3              0.000009 syntax keyword typescriptDOMElemFuncs contained getBoundingClientRect getClientRects
    3              0.000008 syntax keyword typescriptDOMElemFuncs contained getElementsByClassName getElementsByTagName
    3              0.000008 syntax keyword typescriptDOMElemFuncs contained getElementsByTagNameNS hasAttribute
    3              0.000007 syntax keyword typescriptDOMElemFuncs contained hasAttributeNS insertAdjacentHTML
    3              0.000008 syntax keyword typescriptDOMElemFuncs contained matches querySelector querySelectorAll
    3              0.000008 syntax keyword typescriptDOMElemFuncs contained removeAttribute removeAttributeNS
    3              0.000007 syntax keyword typescriptDOMElemFuncs contained removeAttributeNode requestFullscreen
    3              0.000007 syntax keyword typescriptDOMElemFuncs contained requestPointerLock scrollIntoView
    3              0.000009 syntax keyword typescriptDOMElemFuncs contained setAttribute setAttributeNS setAttributeNode
    3              0.000057 syntax keyword typescriptDOMElemFuncs contained setAttributeNodeNS setCapture supports
    3              0.000011 syntax keyword typescriptDOMElemFuncs contained getAttribute
    3              0.000052 if exists("did_typescript_hilink") | HiLink typescriptDOMElemFuncs Keyword
    3              0.000012 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/dom-document.vim
Sourced 3 times
Total time:   0.000867
 Self time:   0.000867

count  total (s)   self (s)
    3              0.000042 syntax keyword typescriptDOMDocProp contained activeElement body cookie defaultView
    3              0.000015 syntax keyword typescriptDOMDocProp contained designMode dir domain embeds forms head
    3              0.000012 syntax keyword typescriptDOMDocProp contained images lastModified links location plugins
    3              0.000012 syntax keyword typescriptDOMDocProp contained postMessage readyState referrer registerElement
    3              0.000012 syntax keyword typescriptDOMDocProp contained scripts styleSheets title vlinkColor
    3              0.000010 syntax keyword typescriptDOMDocProp contained xmlEncoding characterSet compatMode
    3              0.000011 syntax keyword typescriptDOMDocProp contained contentType currentScript doctype documentElement
    3              0.000010 syntax keyword typescriptDOMDocProp contained documentURI documentURIObject firstChild
    3              0.000010 syntax keyword typescriptDOMDocProp contained implementation lastStyleSheetSet namespaceURI
    3              0.000009 syntax keyword typescriptDOMDocProp contained nodePrincipal ononline pointerLockElement
    3              0.000009 syntax keyword typescriptDOMDocProp contained popupNode preferredStyleSheetSet selectedStyleSheetSet
    3              0.000011 syntax keyword typescriptDOMDocProp contained styleSheetSets textContent tooltipNode
    3              0.000028 syntax cluster props add=typescriptDOMDocProp
    3              0.000058 if exists("did_typescript_hilink") | HiLink typescriptDOMDocProp Keyword
    3              0.000004 endif
    3              0.000048 syntax keyword typescriptDOMDocMethod contained caretPositionFromPoint close createNodeIterator nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptDOMDocMethod contained createRange createTreeWalker elementFromPoint nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptDOMDocMethod contained getElementsByName adoptNode createAttribute nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptDOMDocMethod contained createCDATASection createComment createDocumentFragment nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDOMDocMethod contained createElement createElementNS createEvent nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptDOMDocMethod contained createExpression createNSResolver nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptDOMDocMethod contained createProcessingInstruction createTextNode nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDOMDocMethod contained enableStyleSheetsForSet evaluate execCommand nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDOMDocMethod contained exitPointerLock getBoxObjectFor getElementById nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptDOMDocMethod contained getElementsByClassName getElementsByTagName nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptDOMDocMethod contained getElementsByTagNameNS getSelection nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptDOMDocMethod contained hasFocus importNode loadOverlay open nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptDOMDocMethod contained queryCommandSupported querySelector nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDOMDocMethod contained querySelectorAll write writeln nextgroup=typescriptFuncCallArg
    3              0.000024 syntax cluster props add=typescriptDOMDocMethod
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptDOMDocMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/dom-event.vim
Sourced 3 times
Total time:   0.001656
 Self time:   0.001656

count  total (s)   self (s)
    3              0.000064 syntax keyword typescriptDOMEventTargetMethod contained addEventListener removeEventListener nextgroup=typescriptEventFuncCallArg
    3              0.000027 syntax keyword typescriptDOMEventTargetMethod contained dispatchEvent waitUntil nextgroup=typescriptEventFuncCallArg
    3              0.000026 syntax cluster props add=typescriptDOMEventTargetMethod
    3              0.000059 if exists("did_typescript_hilink") | HiLink typescriptDOMEventTargetMethod Keyword
    3              0.000004 endif
    3              0.000042 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AnimationEvent
    3              0.000024 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AudioProcessingEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeInputEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeUnloadEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BlobEvent
    3              0.000023 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ClipboardEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CloseEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CompositionEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CSSFontFaceLoadEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CustomEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceLightEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceMotionEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceOrientationEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceProximityEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DOMTransactionEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DragEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName EditingBeforeInputEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ErrorEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName FocusEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName GamepadEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName HashChangeEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName IDBVersionChangeEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName KeyboardEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MediaStreamEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MessageEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MouseEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MutationEvent
    3              0.000022 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName OfflineAudioCompletionEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PageTransitionEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PointerEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PopStateEvent
    3              0.000020 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ProgressEvent
    3              0.000020 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RelatedEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RTCPeerConnectionIceEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SensorEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName StorageEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGZoomEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TimeEvent
    3              0.000036 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TouchEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TrackEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TransitionEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UIEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UserProximityEvent
    3              0.000021 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName WheelEvent
    3              0.000049 if exists("did_typescript_hilink") | HiLink typescriptDOMEventCons Structure
    3              0.000003 endif
    3              0.000028 syntax keyword typescriptDOMEventProp contained bubbles cancelable currentTarget defaultPrevented
    3              0.000013 syntax keyword typescriptDOMEventProp contained eventPhase target timeStamp type isTrusted
    3              0.000007 syntax keyword typescriptDOMEventProp contained isReload
    3              0.000025 syntax cluster props add=typescriptDOMEventProp
    3              0.000044 if exists("did_typescript_hilink") | HiLink typescriptDOMEventProp Keyword
    3              0.000003 endif
    3              0.000043 syntax keyword typescriptDOMEventMethod contained initEvent preventDefault stopImmediatePropagation nextgroup=typescriptEventFuncCallArg
    3              0.000028 syntax keyword typescriptDOMEventMethod contained stopPropagation respondWith default nextgroup=typescriptEventFuncCallArg
    3              0.000025 syntax cluster props add=typescriptDOMEventMethod
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptDOMEventMethod Keyword
    3              0.000010 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/dom-storage.vim
Sourced 3 times
Total time:   0.000495
 Self time:   0.000495

count  total (s)   self (s)
    3              0.000042 syntax keyword typescriptDOMStorage contained sessionStorage localStorage
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptDOMStorage Keyword
    3              0.000004 endif
    3              0.000024 syntax keyword typescriptDOMStorageProp contained length
    3              0.000028 syntax cluster props add=typescriptDOMStorageProp
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptDOMStorageProp Keyword
    3              0.000003 endif
    3              0.000047 syntax keyword typescriptDOMStorageMethod contained getItem key setItem removeItem nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptDOMStorageMethod contained clear nextgroup=typescriptFuncCallArg
    3              0.000025 syntax cluster props add=typescriptDOMStorageMethod
    3              0.000042 if exists("did_typescript_hilink") | HiLink typescriptDOMStorageMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/dom-form.vim
Sourced 3 times
Total time:   0.000410
 Self time:   0.000410

count  total (s)   self (s)
    3              0.000044 syntax keyword typescriptDOMFormProp contained acceptCharset action elements encoding
    3              0.000015 syntax keyword typescriptDOMFormProp contained enctype length method name target
    3              0.000027 syntax cluster props add=typescriptDOMFormProp
    3              0.000057 if exists("did_typescript_hilink") | HiLink typescriptDOMFormProp Keyword
    3              0.000004 endif
    3              0.000044 syntax keyword typescriptDOMFormMethod contained reportValidity reset submit nextgroup=typescriptFuncCallArg
    3              0.000025 syntax cluster props add=typescriptDOMFormMethod
    3              0.000043 if exists("did_typescript_hilink") | HiLink typescriptDOMFormMethod Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/css.vim
Sourced 3 times
Total time:   0.001298
 Self time:   0.001298

count  total (s)   self (s)
    3              0.000033 syntax keyword typescriptDOMStyle contained alignContent alignItems alignSelf animation
    3              0.000017 syntax keyword typescriptDOMStyle contained animationDelay animationDirection animationDuration
    3              0.000014 syntax keyword typescriptDOMStyle contained animationFillMode animationIterationCount
    3              0.000015 syntax keyword typescriptDOMStyle contained animationName animationPlayState animationTimingFunction
    3              0.000014 syntax keyword typescriptDOMStyle contained appearance backfaceVisibility background
    3              0.000013 syntax keyword typescriptDOMStyle contained backgroundAttachment backgroundBlendMode
    3              0.000015 syntax keyword typescriptDOMStyle contained backgroundClip backgroundColor backgroundImage
    3              0.000014 syntax keyword typescriptDOMStyle contained backgroundOrigin backgroundPosition backgroundRepeat
    3              0.000015 syntax keyword typescriptDOMStyle contained backgroundSize border borderBottom borderBottomColor
    3              0.000013 syntax keyword typescriptDOMStyle contained borderBottomLeftRadius borderBottomRightRadius
    3              0.000014 syntax keyword typescriptDOMStyle contained borderBottomStyle borderBottomWidth borderCollapse
    3              0.000013 syntax keyword typescriptDOMStyle contained borderColor borderImage borderImageOutset
    3              0.000014 syntax keyword typescriptDOMStyle contained borderImageRepeat borderImageSlice borderImageSource
    3              0.000013 syntax keyword typescriptDOMStyle contained borderImageWidth borderLeft borderLeftColor
    3              0.000014 syntax keyword typescriptDOMStyle contained borderLeftStyle borderLeftWidth borderRadius
    3              0.000014 syntax keyword typescriptDOMStyle contained borderRight borderRightColor borderRightStyle
    3              0.000014 syntax keyword typescriptDOMStyle contained borderRightWidth borderSpacing borderStyle
    3              0.000013 syntax keyword typescriptDOMStyle contained borderTop borderTopColor borderTopLeftRadius
    3              0.000014 syntax keyword typescriptDOMStyle contained borderTopRightRadius borderTopStyle borderTopWidth
    3              0.000013 syntax keyword typescriptDOMStyle contained borderWidth bottom boxDecorationBreak
    3              0.000014 syntax keyword typescriptDOMStyle contained boxShadow boxSizing breakAfter breakBefore
    3              0.000016 syntax keyword typescriptDOMStyle contained breakInside captionSide caretColor caretShape
    3              0.000019 syntax keyword typescriptDOMStyle contained caret clear clip clipPath color columns
    3              0.000016 syntax keyword typescriptDOMStyle contained columnCount columnFill columnGap columnRule
    3              0.000015 syntax keyword typescriptDOMStyle contained columnRuleColor columnRuleStyle columnRuleWidth
    3              0.000017 syntax keyword typescriptDOMStyle contained columnSpan columnWidth content counterIncrement
    3              0.000016 syntax keyword typescriptDOMStyle contained counterReset cursor direction display
    3              0.000016 syntax keyword typescriptDOMStyle contained emptyCells flex flexBasis flexDirection
    3              0.000016 syntax keyword typescriptDOMStyle contained flexFlow flexGrow flexShrink flexWrap
    3              0.000017 syntax keyword typescriptDOMStyle contained float font fontFamily fontFeatureSettings
    3              0.000015 syntax keyword typescriptDOMStyle contained fontKerning fontLanguageOverride fontSize
    3              0.000016 syntax keyword typescriptDOMStyle contained fontSizeAdjust fontStretch fontStyle fontSynthesis
    3              0.000014 syntax keyword typescriptDOMStyle contained fontVariant fontVariantAlternates fontVariantCaps
    3              0.000013 syntax keyword typescriptDOMStyle contained fontVariantEastAsian fontVariantLigatures
    3              0.000013 syntax keyword typescriptDOMStyle contained fontVariantNumeric fontVariantPosition
    3              0.000017 syntax keyword typescriptDOMStyle contained fontWeight grad grid gridArea gridAutoColumns
    3              0.000015 syntax keyword typescriptDOMStyle contained gridAutoFlow gridAutoPosition gridAutoRows
    3              0.000014 syntax keyword typescriptDOMStyle contained gridColumn gridColumnStart gridColumnEnd
    3              0.000015 syntax keyword typescriptDOMStyle contained gridRow gridRowStart gridRowEnd gridTemplate
    3              0.000015 syntax keyword typescriptDOMStyle contained gridTemplateAreas gridTemplateRows gridTemplateColumns
    3              0.000015 syntax keyword typescriptDOMStyle contained height hyphens imageRendering imageResolution
    3              0.000015 syntax keyword typescriptDOMStyle contained imageOrientation imeMode inherit justifyContent
    3              0.000015 syntax keyword typescriptDOMStyle contained left letterSpacing lineBreak lineHeight
    3              0.000014 syntax keyword typescriptDOMStyle contained listStyle listStyleImage listStylePosition
    3              0.000028 syntax keyword typescriptDOMStyle contained listStyleType margin marginBottom marginLeft
    3              0.000015 syntax keyword typescriptDOMStyle contained marginRight marginTop marks mask maskType
    3              0.000015 syntax keyword typescriptDOMStyle contained maxHeight maxWidth minHeight minWidth
    3              0.000014 syntax keyword typescriptDOMStyle contained mixBlendMode objectFit objectPosition
    3              0.000017 syntax keyword typescriptDOMStyle contained opacity order orphans outline outlineColor
    3              0.000014 syntax keyword typescriptDOMStyle contained outlineOffset outlineStyle outlineWidth
    3              0.000015 syntax keyword typescriptDOMStyle contained overflow overflowWrap overflowX overflowY
    3              0.000014 syntax keyword typescriptDOMStyle contained overflowClipBox padding paddingBottom
    3              0.000015 syntax keyword typescriptDOMStyle contained paddingLeft paddingRight paddingTop pageBreakAfter
    3              0.000013 syntax keyword typescriptDOMStyle contained pageBreakBefore pageBreakInside perspective
    3              0.000014 syntax keyword typescriptDOMStyle contained perspectiveOrigin pointerEvents position
    3              0.000015 syntax keyword typescriptDOMStyle contained quotes resize right shapeImageThreshold
    3              0.000016 syntax keyword typescriptDOMStyle contained shapeMargin shapeOutside tableLayout tabSize
    3              0.000014 syntax keyword typescriptDOMStyle contained textAlign textAlignLast textCombineHorizontal
    3              0.000015 syntax keyword typescriptDOMStyle contained textDecoration textDecorationColor textDecorationLine
    3              0.000014 syntax keyword typescriptDOMStyle contained textDecorationStyle textIndent textOrientation
    3              0.000014 syntax keyword typescriptDOMStyle contained textOverflow textRendering textShadow
    3              0.000015 syntax keyword typescriptDOMStyle contained textTransform textUnderlinePosition top
    3              0.000014 syntax keyword typescriptDOMStyle contained touchAction transform transformOrigin
    3              0.000014 syntax keyword typescriptDOMStyle contained transformStyle transition transitionDelay
    3              0.000013 syntax keyword typescriptDOMStyle contained transitionDuration transitionProperty
    3              0.000014 syntax keyword typescriptDOMStyle contained transitionTimingFunction unicodeBidi unicodeRange
    3              0.000015 syntax keyword typescriptDOMStyle contained userSelect userZoom verticalAlign visibility
    3              0.000014 syntax keyword typescriptDOMStyle contained whiteSpace width willChange wordBreak
    3              0.000015 syntax keyword typescriptDOMStyle contained wordSpacing wordWrap writingMode zIndex
    3              0.000070 if exists("did_typescript_hilink") | HiLink typescriptDOMStyle Keyword
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/yats/event.vim
Sourced 3 times
Total time:   0.003452
 Self time:   0.003452

count  total (s)   self (s)
    3              0.000045 syntax keyword typescriptAnimationEvent contained animationend animationiteration
    3              0.000012 syntax keyword typescriptAnimationEvent contained animationstart beginEvent endEvent
    3              0.000007 syntax keyword typescriptAnimationEvent contained repeatEvent
    3              0.000015 syntax cluster events add=typescriptAnimationEvent
    3              0.000077 if exists("did_typescript_hilink") | HiLink typescriptAnimationEvent Title
    3              0.000004 endif
    3              0.000028 syntax keyword typescriptCSSEvent contained CssRuleViewRefreshed CssRuleViewChanged
    3              0.000009 syntax keyword typescriptCSSEvent contained CssRuleViewCSSLinkClicked transitionend
    3              0.000014 syntax cluster events add=typescriptCSSEvent
    3              0.000056 if exists("did_typescript_hilink") | HiLink typescriptCSSEvent Title
    3              0.000003 endif
    3              0.000030 syntax keyword typescriptDatabaseEvent contained blocked complete error success upgradeneeded
    3              0.000008 syntax keyword typescriptDatabaseEvent contained versionchange
    3              0.000013 syntax cluster events add=typescriptDatabaseEvent
    3              0.000052 if exists("did_typescript_hilink") | HiLink typescriptDatabaseEvent Title
    3              0.000004 endif
    3              0.000025 syntax keyword typescriptDocumentEvent contained DOMLinkAdded DOMLinkRemoved DOMMetaAdded
    3              0.000009 syntax keyword typescriptDocumentEvent contained DOMMetaRemoved DOMWillOpenModalDialog
    3              0.000008 syntax keyword typescriptDocumentEvent contained DOMModalDialogClosed unload
    3              0.000011 syntax cluster events add=typescriptDocumentEvent
    3              0.000050 if exists("did_typescript_hilink") | HiLink typescriptDocumentEvent Title
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptDOMMutationEvent contained DOMAttributeNameChanged DOMAttrModified
    3              0.000009 syntax keyword typescriptDOMMutationEvent contained DOMCharacterDataModified DOMContentLoaded
    3              0.000008 syntax keyword typescriptDOMMutationEvent contained DOMElementNameChanged DOMNodeInserted
    3              0.000008 syntax keyword typescriptDOMMutationEvent contained DOMNodeInsertedIntoDocument DOMNodeRemoved
    3              0.000008 syntax keyword typescriptDOMMutationEvent contained DOMNodeRemovedFromDocument DOMSubtreeModified
    3              0.000013 syntax cluster events add=typescriptDOMMutationEvent
    3              0.000049 if exists("did_typescript_hilink") | HiLink typescriptDOMMutationEvent Title
    3              0.000003 endif
    3              0.000028 syntax keyword typescriptDragEvent contained drag dragdrop dragend dragenter dragexit
    3              0.000011 syntax keyword typescriptDragEvent contained draggesture dragleave dragover dragstart
    3              0.000006 syntax keyword typescriptDragEvent contained drop
    3              0.000012 syntax cluster events add=typescriptDragEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptDragEvent Title
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptElementEvent contained invalid overflow underflow DOMAutoComplete
    3              0.000010 syntax keyword typescriptElementEvent contained command commandupdate
    3              0.000013 syntax cluster events add=typescriptElementEvent
    3              0.000050 if exists("did_typescript_hilink") | HiLink typescriptElementEvent Title
    3              0.000003 endif
    3              0.000029 syntax keyword typescriptFocusEvent contained blur change DOMFocusIn DOMFocusOut focus
    3              0.000009 syntax keyword typescriptFocusEvent contained focusin focusout
    3              0.000013 syntax cluster events add=typescriptFocusEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptFocusEvent Title
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptFormEvent contained reset submit
    3              0.000013 syntax cluster events add=typescriptFormEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptFormEvent Title
    3              0.000003 endif
    3              0.000022 syntax keyword typescriptFrameEvent contained DOMFrameContentLoaded
    3              0.000013 syntax cluster events add=typescriptFrameEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptFrameEvent Title
    3              0.000003 endif
    3              0.000025 syntax keyword typescriptInputDeviceEvent contained click contextmenu DOMMouseScroll
    3              0.000011 syntax keyword typescriptInputDeviceEvent contained dblclick gamepadconnected gamepaddisconnected
    3              0.000011 syntax keyword typescriptInputDeviceEvent contained keydown keypress keyup MozGamepadButtonDown
    3              0.000010 syntax keyword typescriptInputDeviceEvent contained MozGamepadButtonUp mousedown mouseenter
    3              0.000008 syntax keyword typescriptInputDeviceEvent contained mouseleave mousemove mouseout
    3              0.000010 syntax keyword typescriptInputDeviceEvent contained mouseover mouseup mousewheel MozMousePixelScroll
    3              0.000008 syntax keyword typescriptInputDeviceEvent contained pointerlockchange pointerlockerror
    3              0.000006 syntax keyword typescriptInputDeviceEvent contained wheel
    3              0.000013 syntax cluster events add=typescriptInputDeviceEvent
    3              0.000049 if exists("did_typescript_hilink") | HiLink typescriptInputDeviceEvent Title
    3              0.000018 endif
    3              0.000026 syntax keyword typescriptMediaEvent contained audioprocess canplay canplaythrough
    3              0.000013 syntax keyword typescriptMediaEvent contained durationchange emptied ended ended loadeddata
    3              0.000009 syntax keyword typescriptMediaEvent contained loadedmetadata MozAudioAvailable pause
    3              0.000010 syntax keyword typescriptMediaEvent contained play playing ratechange seeked seeking
    3              0.000009 syntax keyword typescriptMediaEvent contained stalled suspend timeupdate volumechange
    3              0.000008 syntax keyword typescriptMediaEvent contained waiting complete
    3              0.000013 syntax cluster events add=typescriptMediaEvent
    3              0.000049 if exists("did_typescript_hilink") | HiLink typescriptMediaEvent Title
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptMenuEvent contained DOMMenuItemActive DOMMenuItemInactive
    3              0.000014 syntax cluster events add=typescriptMenuEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptMenuEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptNetworkEvent contained datachange dataerror disabled enabled
    3              0.000012 syntax keyword typescriptNetworkEvent contained offline online statuschange connectionInfoUpdate
    3              0.000014 syntax cluster events add=typescriptNetworkEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptNetworkEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptProgressEvent contained abort error load loadend loadstart
    3              0.000011 syntax keyword typescriptProgressEvent contained progress timeout uploadprogress
    3              0.000014 syntax cluster events add=typescriptProgressEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptProgressEvent Title
    3              0.000003 endif
    3              0.000025 syntax keyword typescriptResourceEvent contained cached error load
    3              0.000014 syntax cluster events add=typescriptResourceEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptResourceEvent Title
    3              0.000003 endif
    3              0.000023 syntax keyword typescriptScriptEvent contained afterscriptexecute beforescriptexecute
    3              0.000014 syntax cluster events add=typescriptScriptEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptScriptEvent Title
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptSensorEvent contained compassneedscalibration devicelight
    3              0.000010 syntax keyword typescriptSensorEvent contained devicemotion deviceorientation deviceproximity
    3              0.000008 syntax keyword typescriptSensorEvent contained orientationchange userproximity
    3              0.000014 syntax cluster events add=typescriptSensorEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptSensorEvent Title
    3              0.000003 endif
    3              0.000025 syntax keyword typescriptSessionHistoryEvent contained pagehide pageshow popstate
    3              0.000015 syntax cluster events add=typescriptSessionHistoryEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptSessionHistoryEvent Title
    3              0.000003 endif
    3              0.000023 syntax keyword typescriptStorageEvent contained change storage
    3              0.000014 syntax cluster events add=typescriptStorageEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptStorageEvent Title
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptSVGEvent contained SVGAbort SVGError SVGLoad SVGResize SVGScroll
    3              0.000008 syntax keyword typescriptSVGEvent contained SVGUnload SVGZoom
    3              0.000014 syntax cluster events add=typescriptSVGEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptSVGEvent Title
    3              0.000003 endif
    3              0.000022 syntax keyword typescriptTabEvent contained visibilitychange
    3              0.000015 syntax cluster events add=typescriptTabEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptTabEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptTextEvent contained compositionend compositionstart compositionupdate
    3              0.000012 syntax keyword typescriptTextEvent contained copy cut paste select text
    3              0.000015 syntax cluster events add=typescriptTextEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptTextEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptTouchEvent contained touchcancel touchend touchenter touchleave
    3              0.000008 syntax keyword typescriptTouchEvent contained touchmove touchstart
    3              0.000015 syntax cluster events add=typescriptTouchEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptTouchEvent Title
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptUpdateEvent contained checking downloading error noupdate
    3              0.000008 syntax keyword typescriptUpdateEvent contained obsolete updateready
    3              0.000015 syntax cluster events add=typescriptUpdateEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptUpdateEvent Title
    3              0.000003 endif
    3              0.000025 syntax keyword typescriptValueChangeEvent contained hashchange input readystatechange
    3              0.000016 syntax cluster events add=typescriptValueChangeEvent
    3              0.000060 if exists("did_typescript_hilink") | HiLink typescriptValueChangeEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptViewEvent contained fullscreen fullscreenchange fullscreenerror
    3              0.000008 syntax keyword typescriptViewEvent contained resize scroll
    3              0.000015 syntax cluster events add=typescriptViewEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptViewEvent Title
    3              0.000003 endif
    3              0.000027 syntax keyword typescriptWebsocketEvent contained close error message open
    3              0.000016 syntax cluster events add=typescriptWebsocketEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptWebsocketEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptWindowEvent contained DOMWindowCreated DOMWindowClose DOMTitleChanged
    3              0.000016 syntax cluster events add=typescriptWindowEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptWindowEvent Title
    3              0.000003 endif
    3              0.000026 syntax keyword typescriptUncategorizedEvent contained beforeunload message open show
    3              0.000017 syntax cluster events add=typescriptUncategorizedEvent
    3              0.000048 if exists("did_typescript_hilink") | HiLink typescriptUncategorizedEvent Title
    3              0.000003 endif
    3              0.000024 syntax keyword typescriptServiceWorkerEvent contained install activate fetch
    3              0.000017 syntax cluster events add=typescriptServiceWorkerEvent
    3              0.000047 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerEvent Title
    3              0.000011 endif

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/patch.vim
Sourced 3 times
Total time:   0.000321
 Self time:   0.000321

count  total (s)   self (s)
                            " patch for generated code
    3              0.000097 syntax keyword typescriptGlobal Promise
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
    3              0.000074 syntax keyword typescriptGlobal Map WeakMap
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/members.vim
Sourced 3 times
Total time:   0.000955
 Self time:   0.000955

count  total (s)   self (s)
    3              0.000058 syntax keyword typescriptConstructor           contained constructor
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            
    3              0.000056 syntax cluster memberNextGroup contains=typescriptMemberOptionality,typescriptTypeAnnotation,@typescriptCallSignature
                            
    3              0.000221 syntax match typescriptMember /\K\k*/
                              \ nextgroup=@memberNextGroup
                              \ contained skipwhite
                            
    3              0.000054 syntax match typescriptMethodAccessor contained /\v(get|set)\s\K/me=e-1
                              \ nextgroup=@typescriptMembers
                            
    3              0.000068 syntax cluster typescriptPropertyMemberDeclaration contains=
                              \ typescriptClassStatic,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptMethodAccessor,
                              \ @typescriptMembers
                              " \ typescriptMemberVariableDeclaration
                            
    3              0.000047 syntax match typescriptMemberOptionality /?\|!/ contained
                              \ nextgroup=typescriptTypeAnnotation,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    3              0.000047 syntax cluster typescriptMembers contains=typescriptMember,typescriptStringMember,typescriptComputedMember
                            
    3              0.000058 syntax keyword typescriptClassStatic static
                              \ nextgroup=@typescriptMembers,typescriptAsyncFuncKeyword,typescriptReadonlyModifier
                              \ skipwhite contained
                            
    3              0.000016 syntax keyword typescriptAccessibilityModifier public private protected contained
                            
    3              0.000011 syntax keyword typescriptReadonlyModifier readonly contained
                            
    3              0.000063 syntax region  typescriptStringMember   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty
                            
    3              0.000088 syntax region  typescriptComputedMember   contained matchgroup=typescriptProperty
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue,typescriptMember,typescriptMappedIn
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/class.vim
Sourced 3 times
Total time:   0.001088
 Self time:   0.001088

count  total (s)   self (s)
                            "don't add typescriptMembers to nextgroup, let outer scope match it
                            " so we won't match abstract method outside abstract class
    3              0.000047 syntax keyword typescriptAbstract              abstract
                              \ nextgroup=typescriptClassKeyword
                              \ skipwhite skipnl
    3              0.000086 syntax keyword typescriptClassKeyword          class
                              \ nextgroup=typescriptClassName,typescriptClassExtends,typescriptClassBlock
                              \ skipwhite
                            
    3              0.000053 syntax match   typescriptClassName             contained /\K\k*/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptClassTypeParameter
                              \ skipwhite skipnl
                            
    3              0.000050 syntax region typescriptClassTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends
                              \ contained skipwhite skipnl
                            
    3              0.000036 syntax keyword typescriptClassExtends          contained extends implements nextgroup=typescriptClassHeritage skipwhite skipnl
                            
    3              0.000086 syntax match   typescriptClassHeritage         contained /\v(\k|\.|\(|\))+/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptMixinComma,typescriptClassTypeArguments
                              \ contains=@typescriptValue
                              \ skipwhite skipnl
                              \ contained
                            
    3              0.000061 syntax region typescriptClassTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptClassExtends,typescriptClassBlock,typescriptMixinComma
                              \ contained skipwhite skipnl
                            
    3              0.000017 syntax match typescriptMixinComma /,/ contained nextgroup=typescriptClassHeritage skipwhite skipnl
                            
                            " we need add arrowFunc to class block for high order arrow func
                            " see test case
    3              0.000139 syntax region  typescriptClassBlock matchgroup=typescriptBraces start=/{/ end=/}/
                              \ contains=@typescriptPropertyMemberDeclaration,typescriptAbstract,@typescriptComments,typescriptBlock,typescriptAssign,typescriptDecorator,typescriptAsyncFuncKeyword,typescriptArrowFunc
                              \ contained fold
                            
    3              0.000039 syntax keyword typescriptInterfaceKeyword          interface nextgroup=typescriptInterfaceName skipwhite
    3              0.000075 syntax match   typescriptInterfaceName             contained /\k\+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends,typescriptInterfaceTypeParameter
                              \ skipwhite skipnl
    3              0.000055 syntax region typescriptInterfaceTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends
                              \ contained
                              \ skipwhite skipnl
                            
    3              0.000034 syntax keyword typescriptInterfaceExtends          contained extends nextgroup=typescriptInterfaceHeritage skipwhite skipnl
                            
    3              0.000075 syntax match typescriptInterfaceHeritage contained /\v(\k|\.)+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma,typescriptInterfaceTypeArguments
                              \ skipwhite
                            
    3              0.000074 syntax region typescriptInterfaceTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma
                              \ contained skipwhite
                            
    3              0.000026 syntax match typescriptInterfaceComma /,/ contained nextgroup=typescriptInterfaceHeritage skipwhite skipnl

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/cluster.vim
Sourced 3 times
Total time:   0.001055
 Self time:   0.001055

count  total (s)   self (s)
                            "Block VariableStatement EmptyStatement ExpressionStatement IfStatement IterationStatement ContinueStatement BreakStatement ReturnStatement WithStatement LabelledStatement SwitchStatement ThrowStatement TryStatement DebuggerStatement
    3              0.000302 syntax cluster typescriptStatement
                              \ contains=typescriptBlock,typescriptVariable,
                              \ @typescriptTopExpression,typescriptAssign,
                              \ typescriptConditional,typescriptRepeat,typescriptBranch,
                              \ typescriptLabel,typescriptStatementKeyword,
                              \ typescriptFuncKeyword,
                              \ typescriptTry,typescriptExceptions,typescriptDebugger,
                              \ typescriptExport,typescriptInterfaceKeyword,typescriptEnum,
                              \ typescriptModule,typescriptAliasKeyword,typescriptImport
                            
    3              0.000119 syntax cluster typescriptPrimitive  contains=typescriptString,typescriptTemplate,typescriptRegexpString,typescriptNumber,typescriptBoolean,typescriptNull,typescriptArray
                            
    3              0.000089 syntax cluster typescriptEventTypes            contains=typescriptEventString,typescriptTemplate,typescriptNumber,typescriptBoolean,typescriptNull
                            
                            " top level expression: no arrow func
                            " also no func keyword. funcKeyword is contained in statement
                            " funcKeyword allows overloading (func without body)
                            " funcImpl requires body
    3              0.000162 syntax cluster typescriptTopExpression
                              \ contains=@typescriptPrimitive,
                              \ typescriptIdentifier,typescriptIdentifierName,
                              \ typescriptOperator,typescriptUnaryOp,
                              \ typescriptParenExp,typescriptRegexpString,
                              \ typescriptGlobal,typescriptAsyncFuncKeyword,
                              \ typescriptClassKeyword,typescriptTypeCast
                            
                            " no object literal, used in type cast and arrow func
                            " TODO: change func keyword to funcImpl
    3              0.000052 syntax cluster typescriptExpression
                              \ contains=@typescriptTopExpression,
                              \ typescriptArrowFuncDef,
                              \ typescriptFuncImpl
                            
    3              0.000031 syntax cluster typescriptValue
                              \ contains=@typescriptExpression,typescriptObjectLiteral
                            
    3              0.000113 syntax cluster typescriptEventExpression       contains=typescriptArrowFuncDef,typescriptParenExp,@typescriptValue,typescriptRegexpString,@typescriptEventTypes,typescriptOperator,typescriptGlobal,jsxRegion

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/function.vim
Sourced 3 times
Total time:   0.001087
 Self time:   0.001087

count  total (s)   self (s)
    3              0.000054 syntax keyword typescriptAsyncFuncKeyword      async
                              \ nextgroup=typescriptFuncKeyword,typescriptArrowFuncDef
                              \ skipwhite
                            
    3              0.000020 syntax keyword typescriptAsyncFuncKeyword      await
                              \ nextgroup=@typescriptValue
                              \ skipwhite
                            
    3              0.000072 syntax keyword typescriptFuncKeyword           function
                              \ nextgroup=typescriptAsyncFunc,typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    3              0.000031 syntax match   typescriptAsyncFunc             contained /*/
                              \ nextgroup=typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    3              0.000023 syntax match   typescriptFuncName              contained /\K\k*/
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite
                            
                            " destructuring ({ a: ee }) =>
    3              0.000092 syntax match   typescriptArrowFuncDef          contained /({\_[^}]*}\(:\_[^)]\)\?)\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            " matches `(a) =>` or `([a]) =>` or
                            " `(
                            "  a) =>`
    3              0.000073 syntax match   typescriptArrowFuncDef          contained /(\(\_s*[a-zA-Z\$_\[.]\_[^)]*\)*)\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
    3              0.000055 syntax match   typescriptArrowFuncDef          contained /\K\k*\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            " TODO: optimize this pattern
    3              0.000093 syntax region   typescriptArrowFuncDef          contained start=/(\_[^(^)]*):/ end=/=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc,typescriptTypeAnnotation
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty keepend
                            
    3              0.000012 syntax match   typescriptArrowFunc             /=>/
    3              0.000013 syntax match   typescriptArrowFuncArg          contained /\K\k*/
    3              0.000035 syntax region  typescriptArrowFuncArg          contained start=/<\|(/ end=/\ze=>/ contains=@typescriptCallSignature
                            
    3              0.000066 syntax region typescriptReturnAnnotation contained start=/:/ end=/{/me=e-1 contains=@typescriptType nextgroup=typescriptBlock
                            
                            
    3              0.000064 syntax region typescriptFuncImpl contained start=/function/ end=/{/me=e-1
                              \ contains=typescriptFuncKeyword
                              \ nextgroup=typescriptBlock
                            
    3              0.000046 syntax cluster typescriptCallImpl contains=typescriptGenericImpl,typescriptParamImpl
    3              0.000069 syntax region typescriptGenericImpl matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptParamImpl
                              \ contained skipwhite
    3              0.000092 syntax region typescriptParamImpl matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptReturnAnnotation,typescriptBlock
                              \ contained skipwhite skipnl

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/basic/decorator.vim
Sourced 3 times
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
    3              0.000135 syntax match typescriptDecorator /@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>/
                              \ nextgroup=typescriptFuncCallArg,typescriptTypeArguments
                              \ contains=@_semantic,typescriptDotNotation

SCRIPT  /usr/share/nvim/runtime/syntax/typescript.vim
Sourced 3 times
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript
                            " Maintainer:   Bram Moolenaar
                            " Last Change:	2019 Jun 07
                            " Based On:     Herrington Darkholme's yats.vim
                            " Changes:      See https:github.com/HerringtonDarkholme/yats.vim
                            " Credits:      See yats.vim
                            
                            " This is the same syntax that is in yats.vim, but:
                            " - flattened into one file
                            " - HiLink commands changed to "hi def link"
                            " - Setting 'cpo' to the Vim value
                            
    3              0.000023 if !exists("main_syntax")
    3              0.000013   if exists("b:current_syntax")
    3              0.000007     finish
                              endif
                              let main_syntax = 'typescript'
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " nextgroup doesn't contain objectLiteral, let outer region contains it
                            syntax region typescriptTypeCast matchgroup=typescriptTypeBrackets
                              \ start=/< \@!/ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptExpression
                              \ contained skipwhite oneline
                            
                            " runtime syntax/common.vim
                            
                            " NOTE: this results in accurate highlighting, but can be slow.
                            syntax sync fromstart
                            
                            "Dollar sign is permitted anywhere in an identifier
                            setlocal iskeyword-=$
                            if main_syntax == 'typescript' || main_syntax == 'typescript.tsx'
                              setlocal iskeyword+=$
                              " syntax cluster htmlJavaScript                 contains=TOP
                            endif
                            
                            " lowest priority on least used feature
                            syntax match   typescriptLabel                /[a-zA-Z_$]\k*:/he=e-1 contains=typescriptReserved nextgroup=@typescriptStatement skipwhite skipempty
                            
                            " other keywords like return,case,yield uses containedin
                            syntax region  typescriptBlock                 matchgroup=typescriptBraces start=/{/ end=/}/ contains=@typescriptStatement,@typescriptComments fold
                            
                            
                            "runtime syntax/basic/identifiers.vim
                            syntax cluster afterIdentifier contains=
                              \ typescriptDotNotation,
                              \ typescriptFuncCallArg,
                              \ typescriptTemplate,
                              \ typescriptIndexExpr,
                              \ @typescriptSymbols,
                              \ typescriptTypeArguments
                            
                            syntax match   typescriptIdentifierName        /\<\K\k*/
                              \ nextgroup=@afterIdentifier
                              \ transparent
                              \ contains=@_semantic
                              \ skipnl skipwhite
                            
                            syntax match   typescriptProp contained /\K\k*!\?/
                              \ transparent
                              \ contains=@props
                              \ nextgroup=@afterIdentifier
                              \ skipwhite skipempty
                            
                            syntax region  typescriptIndexExpr      contained matchgroup=typescriptProperty start=/\[/rs=s+1 end=/]/he=e-1 contains=@typescriptValue nextgroup=@typescriptSymbols,typescriptDotNotation,typescriptFuncCallArg skipwhite skipempty
                            
                            syntax match   typescriptDotNotation           /\./ nextgroup=typescriptProp skipnl
                            syntax match   typescriptDotStyleNotation      /\.style\./ nextgroup=typescriptDOMStyle transparent
                            " syntax match   typescriptFuncCall              contained /[a-zA-Z]\k*\ze(/ nextgroup=typescriptFuncCallArg
                            syntax region  typescriptParenExp              matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptComments,@typescriptValue,typescriptCastKeyword nextgroup=@typescriptSymbols skipwhite skipempty
                            syntax region  typescriptFuncCallArg           contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptValue,@typescriptComments nextgroup=@typescriptSymbols,typescriptDotNotation skipwhite skipempty skipnl
                            syntax region  typescriptEventFuncCallArg      contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptEventExpression
                            syntax region  typescriptEventString           contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/ contains=typescriptASCII,@events
                            
                            "runtime syntax/basic/literal.vim
                            "Syntax in the JavaScript code
                            
                            " String
                            syntax match   typescriptASCII                 contained /\\\d\d\d/
                            
                            syntax region  typescriptTemplateSubstitution matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptValue
                              \ contained
                            
                            
                            syntax region  typescriptString 
                              \ start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+
                              \ contains=typescriptSpecial,@Spell
                              \ extend
                            
                            syntax match   typescriptSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{4,5}})|c\u|.)"
                            
                            " From vim runtime
                            " <https://github.com/vim/vim/blob/master/runtime/syntax/javascript.vim#L48>
                            syntax region  typescriptRegexpString          start=+/[^/*]+me=e-1 skip=+\\\\\|\\/+ end=+/[gimuy]\{0,5\}\s*$+ end=+/[gimuy]\{0,5\}\s*[;.,)\]}]+me=e-1 nextgroup=typescriptDotNotation oneline
                            
                            syntax region  typescriptTemplate
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitution
                              \ nextgroup=@typescriptSymbols
                              \ skipwhite skipempty
                            
                            "Array
                            syntax region  typescriptArray matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=@typescriptSymbols,typescriptDotNotation
                              \ skipwhite skipempty fold
                            
                            " Number
                            syntax match typescriptNumber /\<0[bB][01][01_]*\>/        nextgroup=@typescriptSymbols skipwhite skipempty
                            syntax match typescriptNumber /\<0[oO][0-7][0-7_]*\>/       nextgroup=@typescriptSymbols skipwhite skipempty
                            syntax match typescriptNumber /\<0[xX][0-9a-fA-F][0-9a-fA-F_]*\>/ nextgroup=@typescriptSymbols skipwhite skipempty
                            syntax match typescriptNumber /\d[0-9_]*\.\d[0-9_]*\|\d[0-9_]*\|\.\d[0-9]*/
                              \ nextgroup=typescriptExponent,@typescriptSymbols skipwhite skipempty
                            syntax match typescriptExponent /[eE][+-]\=\d[0-9]*\>/
                              \ nextgroup=@typescriptSymbols skipwhite skipempty contained
                            
                            
                            " runtime syntax/basic/object.vim
                            syntax region  typescriptObjectLiteral         matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptComments,typescriptObjectLabel,typescriptStringProperty,typescriptComputedPropertyName
                              \ fold contained
                            
                            syntax match   typescriptObjectLabel  contained /\k\+\_s*/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            syntax region  typescriptStringProperty   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptPropertyName    contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1(/me=e-1 nextgroup=@typescriptCallSignature skipwhite skipempty oneline
                            syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptBraces
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*:/he=e-1 contains=@typescriptValue nextgroup=@typescriptValue skipwhite skipempty
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*(/me=e-1 contains=@typescriptValue nextgroup=@typescriptCallSignature skipwhite skipempty
                            " Value for object, statement for label statement
                            syntax match typescriptRestOrSpread /\.\.\./ contained
                            syntax match typescriptObjectSpread /\.\.\./ contained containedin=typescriptObjectLiteral,typescriptArray nextgroup=@typescriptValue
                            
                            syntax match typescriptObjectColon contained /:/ nextgroup=@typescriptValue skipwhite skipempty
                            
                            "runtime syntax/basic/symbols.vim
                            " + - ^ ~
                            syntax match typescriptUnaryOp /[+\-~!]/
                             \ nextgroup=@typescriptValue
                             \ skipwhite
                            
                            syntax region typescriptTernary matchgroup=typescriptTernaryOp start=/?/ end=/:/ contained contains=@typescriptValue,@typescriptComments nextgroup=@typescriptValue skipwhite skipempty
                            
                            syntax match   typescriptAssign  /=/ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
                            " 2: ==, ===
                            syntax match   typescriptBinaryOp contained /===\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 6: >>>=, >>>, >>=, >>, >=, >
                            syntax match   typescriptBinaryOp contained />\(>>=\|>>\|>=\|>\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: <<=, <<, <=, <
                            syntax match   typescriptBinaryOp contained /<\(<=\|<\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: ||, |=, |
                            syntax match   typescriptBinaryOp contained /|\(|\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: &&, &=, &
                            syntax match   typescriptBinaryOp contained /&\(&\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: *=, *
                            syntax match   typescriptBinaryOp contained /\*=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: %=, %
                            syntax match   typescriptBinaryOp contained /%=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: /=, /
                            syntax match   typescriptBinaryOp contained +/\(=\|[^\*/]\@=\)+ nextgroup=@typescriptValue skipwhite skipempty
                            syntax match   typescriptBinaryOp contained /!==\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: !=, !==
                            syntax match   typescriptBinaryOp contained /+\(+\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: +, ++, +=
                            syntax match   typescriptBinaryOp contained /-\(-\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: -, --, -=
                            
                            " exponentiation operator
                            " 2: **, **=
                            syntax match typescriptBinaryOp contained /\*\*=\?/ nextgroup=@typescriptValue
                            
                            syntax cluster typescriptSymbols               contains=typescriptBinaryOp,typescriptKeywordOp,typescriptTernary,typescriptAssign,typescriptCastKeyword
                            
                            "" runtime syntax/basic/reserved.vim
                            
                            "runtime syntax/basic/keyword.vim
                            "Import
                            syntax keyword typescriptImport                from as import
                            syntax keyword typescriptExport                export
                            syntax keyword typescriptModule                namespace module
                            
                            "this
                            
                            "JavaScript Prototype
                            syntax keyword typescriptPrototype             prototype
                              \ nextgroup=@afterIdentifier
                            
                            syntax keyword typescriptCastKeyword           as
                              \ nextgroup=@typescriptType
                              \ skipwhite
                            
                            "Program Keywords
                            syntax keyword typescriptIdentifier            arguments this super
                              \ nextgroup=@afterIdentifier
                            
                            syntax keyword typescriptVariable              let var
                              \ nextgroup=typescriptVariableDeclaration
                              \ skipwhite skipempty skipnl
                            
                            syntax keyword typescriptVariable const
                              \ nextgroup=typescriptEnum,typescriptVariableDeclaration
                              \ skipwhite
                            
                            syntax match typescriptVariableDeclaration /[A-Za-z_$]\k*/
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ contained skipwhite skipempty skipnl
                            
                            syntax region typescriptEnum matchgroup=typescriptEnumKeyword start=/enum / end=/\ze{/
                              \ nextgroup=typescriptBlock
                              \ skipwhite
                            
                            syntax keyword typescriptKeywordOp
                              \ contained in instanceof nextgroup=@typescriptValue
                            syntax keyword typescriptOperator              delete new typeof void
                              \ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
                            syntax keyword typescriptForOperator           contained in of
                            syntax keyword typescriptBoolean               true false nextgroup=@typescriptSymbols skipwhite skipempty
                            syntax keyword typescriptNull                  null undefined nextgroup=@typescriptSymbols skipwhite skipempty
                            syntax keyword typescriptMessage               alert confirm prompt status
                              \ nextgroup=typescriptDotNotation,typescriptFuncCallArg
                            syntax keyword typescriptGlobal                self top parent
                              \ nextgroup=@afterIdentifier
                            
                            "Statement Keywords
                            syntax keyword typescriptConditional           if else switch
                              \ nextgroup=typescriptConditionalParen
                              \ skipwhite skipempty skipnl
                            syntax keyword typescriptConditionalElse       else
                            syntax keyword typescriptRepeat                do while for nextgroup=typescriptLoopParen skipwhite skipempty
                            syntax keyword typescriptRepeat                for nextgroup=typescriptLoopParen,typescriptAsyncFor skipwhite skipempty
                            syntax keyword typescriptBranch                break continue containedin=typescriptBlock
                            syntax keyword typescriptCase                  case nextgroup=@typescriptPrimitive skipwhite containedin=typescriptBlock
                            syntax keyword typescriptDefault               default containedin=typescriptBlock nextgroup=@typescriptValue,typescriptClassKeyword,typescriptInterfaceKeyword skipwhite oneline
                            syntax keyword typescriptStatementKeyword      with
                            syntax keyword typescriptStatementKeyword      yield skipwhite nextgroup=@typescriptValue containedin=typescriptBlock
                            syntax keyword typescriptStatementKeyword      return skipwhite contained nextgroup=@typescriptValue containedin=typescriptBlock
                            
                            syntax keyword typescriptTry                   try
                            syntax keyword typescriptExceptions            catch throw finally
                            syntax keyword typescriptDebugger              debugger
                            
                            syntax keyword typescriptAsyncFor              await nextgroup=typescriptLoopParen skipwhite skipempty contained
                            
                            syntax region  typescriptLoopParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptVariable,typescriptForOperator,typescriptEndColons,@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
                            syntax region  typescriptConditionalParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
                            syntax match   typescriptEndColons             /[;,]/ contained
                            
                            syntax keyword typescriptAmbientDeclaration declare nextgroup=@typescriptAmbients
                              \ skipwhite skipempty
                            
                            syntax cluster typescriptAmbients contains=
                              \ typescriptVariable,
                              \ typescriptFuncKeyword,
                              \ typescriptClassKeyword,
                              \ typescriptAbstract,
                              \ typescriptEnumKeyword,typescriptEnum,
                              \ typescriptModule
                            
                            "runtime syntax/basic/doc.vim
                            "Syntax coloring for Node.js shebang line
                            syntax match   shellbang "^#!.*node\>"
                            syntax match   shellbang "^#!.*iojs\>"
                            
                            
                            "JavaScript comments
                            syntax keyword typescriptCommentTodo TODO FIXME XXX TBD
                            syntax match   typescriptLineComment "//.*"
                              \ contains=@Spell,typescriptCommentTodo,typescriptRef
                            syntax region  typescriptComment
                              \ start="/\*"  end="\*/"
                              \ contains=@Spell,typescriptCommentTodo extend
                            syntax cluster typescriptComments
                              \ contains=typescriptDocComment,typescriptComment,typescriptLineComment
                            
                            syntax match   typescriptRef  +///\s*<reference\s\+.*\/>$+
                              \ contains=typescriptString
                            syntax match   typescriptRef  +///\s*<amd-dependency\s\+.*\/>$+
                              \ contains=typescriptString
                            syntax match   typescriptRef  +///\s*<amd-module\s\+.*\/>$+
                              \ contains=typescriptString
                            
                            "JSDoc
                            syntax case ignore
                            
                            syntax region  typescriptDocComment            matchgroup=typescriptComment
                              \ start="/\*\*"  end="\*/"
                              \ contains=typescriptDocNotation,typescriptCommentTodo,@Spell
                              \ fold keepend
                            syntax match   typescriptDocNotation           contained /@/ nextgroup=typescriptDocTags
                            
                            syntax keyword typescriptDocTags               contained constant constructor constructs function ignore inner private public readonly static
                            syntax keyword typescriptDocTags               contained const dict expose inheritDoc interface nosideeffects override protected struct internal
                            syntax keyword typescriptDocTags               contained example global
                            
                            " syntax keyword typescriptDocTags               contained ngdoc nextgroup=typescriptDocNGDirective
                            syntax keyword typescriptDocTags               contained ngdoc scope priority animations
                            syntax keyword typescriptDocTags               contained ngdoc restrict methodOf propertyOf eventOf eventType nextgroup=typescriptDocParam skipwhite
                            syntax keyword typescriptDocNGDirective        contained overview service object function method property event directive filter inputType error
                            
                            syntax keyword typescriptDocTags               contained abstract virtual access augments
                            
                            syntax keyword typescriptDocTags               contained arguments callback lends memberOf name type kind link mixes mixin tutorial nextgroup=typescriptDocParam skipwhite
                            syntax keyword typescriptDocTags               contained variation nextgroup=typescriptDocNumParam skipwhite
                            
                            syntax keyword typescriptDocTags               contained author class classdesc copyright default defaultvalue nextgroup=typescriptDocDesc skipwhite
                            syntax keyword typescriptDocTags               contained deprecated description external host nextgroup=typescriptDocDesc skipwhite
                            syntax keyword typescriptDocTags               contained file fileOverview overview namespace requires since version nextgroup=typescriptDocDesc skipwhite
                            syntax keyword typescriptDocTags               contained summary todo license preserve nextgroup=typescriptDocDesc skipwhite
                            
                            syntax keyword typescriptDocTags               contained borrows exports nextgroup=typescriptDocA skipwhite
                            syntax keyword typescriptDocTags               contained param arg argument property prop module nextgroup=typescriptDocNamedParamType,typescriptDocParamName skipwhite
                            syntax keyword typescriptDocTags               contained define enum extends implements this typedef nextgroup=typescriptDocParamType skipwhite
                            syntax keyword typescriptDocTags               contained return returns throws exception nextgroup=typescriptDocParamType,typescriptDocParamName skipwhite
                            syntax keyword typescriptDocTags               contained see nextgroup=typescriptDocRef skipwhite
                            
                            syntax keyword typescriptDocTags               contained function func method nextgroup=typescriptDocName skipwhite
                            syntax match   typescriptDocName               contained /\h\w*/
                            
                            syntax keyword typescriptDocTags               contained fires event nextgroup=typescriptDocEventRef skipwhite
                            syntax match   typescriptDocEventRef           contained /\h\w*#\(\h\w*\:\)\?\h\w*/
                            
                            syntax match   typescriptDocNamedParamType     contained /{.\+}/ nextgroup=typescriptDocParamName skipwhite
                            syntax match   typescriptDocParamName          contained /\[\?0-9a-zA-Z_\.]\+\]\?/ nextgroup=typescriptDocDesc skipwhite
                            syntax match   typescriptDocParamType          contained /{.\+}/ nextgroup=typescriptDocDesc skipwhite
                            syntax match   typescriptDocA                  contained /\%(#\|\w\|\.\|:\|\/\)\+/ nextgroup=typescriptDocAs skipwhite
                            syntax match   typescriptDocAs                 contained /\s*as\s*/ nextgroup=typescriptDocB skipwhite
                            syntax match   typescriptDocB                  contained /\%(#\|\w\|\.\|:\|\/\)\+/
                            syntax match   typescriptDocParam              contained /\%(#\|\w\|\.\|:\|\/\|-\)\+/
                            syntax match   typescriptDocNumParam           contained /\d\+/
                            syntax match   typescriptDocRef                contained /\%(#\|\w\|\.\|:\|\/\)\+/
                            syntax region  typescriptDocLinkTag            contained matchgroup=typescriptDocLinkTag start=/{/ end=/}/ contains=typescriptDocTags
                            
                            syntax cluster typescriptDocs                  contains=typescriptDocParamType,typescriptDocNamedParamType,typescriptDocParam
                            
                            if main_syntax == "typescript"
                              syntax sync clear
                              syntax sync ccomment typescriptComment minlines=200
                            endif
                            
                            syntax case match
                            
                            "runtime syntax/basic/type.vim
                            " Types
                            syntax match typescriptOptionalMark /?/ contained
                            
                            syntax region typescriptTypeParameters matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ contained
                            
                            syntax match typescriptTypeParameter /\K\k*/
                              \ nextgroup=typescriptConstraint,typescriptGenericDefault
                              \ contained skipwhite skipnl
                            
                            syntax keyword typescriptConstraint extends
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
                            syntax match typescriptGenericDefault /=/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite
                            
                            "><
                            " class A extend B<T> {} // ClassBlock
                            " func<T>() // FuncCallArg
                            syntax region typescriptTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/\></ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptFuncCallArg,@typescriptTypeOperator
                              \ contained skipwhite
                            
                            
                            syntax cluster typescriptType contains=
                              \ @typescriptPrimaryType,
                              \ typescriptUnion,
                              \ @typescriptFunctionType,
                              \ typescriptConstructorType
                            
                            " array type: A[]
                            " type indexing A['key']
                            syntax region typescriptTypeBracket contained
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptString,typescriptNumber
                              \ nextgroup=@typescriptTypeOperator
                              \ skipwhite skipempty
                            
                            syntax cluster typescriptPrimaryType contains=
                              \ typescriptParenthesizedType,
                              \ typescriptPredefinedType,
                              \ typescriptTypeReference,
                              \ typescriptObjectType,
                              \ typescriptTupleType,
                              \ typescriptTypeQuery,
                              \ typescriptStringLiteralType,
                              \ typescriptReadonlyArrayKeyword
                            
                            syntax region  typescriptStringLiteralType contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ nextgroup=typescriptUnion
                              \ skipwhite skipempty
                            
                            syntax region typescriptParenthesizedType matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty fold
                            
                            syntax match typescriptTypeReference /\K\k*\(\.\K\k*\)*/
                              \ nextgroup=typescriptTypeArguments,@typescriptTypeOperator,typescriptUserDefinedType
                              \ skipwhite contained skipempty
                            
                            syntax keyword typescriptPredefinedType any number boolean string void never undefined null object unknown
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
                            syntax match typescriptPredefinedType /unique symbol/
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
                            syntax region typescriptObjectType matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptTypeMember,typescriptEndColons,@typescriptComments,typescriptAccessibilityModifier,typescriptReadonlyModifier
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite fold
                            
                            syntax cluster typescriptTypeMember contains=
                              \ @typescriptCallSignature,
                              \ typescriptConstructSignature,
                              \ typescriptIndexSignature,
                              \ @typescriptMembers
                            
                            syntax region typescriptTupleType matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=@typescriptType
                              \ contained skipwhite oneline
                            
                            syntax cluster typescriptTypeOperator
                              \ contains=typescriptUnion,typescriptTypeBracket
                            
                            syntax match typescriptUnion /|\|&/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty
                            
                            syntax cluster typescriptFunctionType contains=typescriptGenericFunc,typescriptFuncType
                            syntax region typescriptGenericFunc matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptFuncType
                              \ containedin=typescriptFunctionType
                              \ contained skipwhite skipnl
                            
                            syntax region typescriptFuncType matchgroup=typescriptParens
                              \ start=/(/ end=/)\s*=>/me=e-2
                              \ contains=@typescriptParameterList
                              \ nextgroup=typescriptFuncTypeArrow
                              \ contained skipwhite skipnl oneline
                            
                            syntax match typescriptFuncTypeArrow /=>/
                              \ nextgroup=@typescriptType
                              \ containedin=typescriptFuncType
                              \ contained skipwhite skipnl
                            
                            
                            syntax keyword typescriptConstructorType new
                              \ nextgroup=@typescriptFunctionType
                              \ contained skipwhite skipnl
                            
                            syntax keyword typescriptUserDefinedType is
                              \ contained nextgroup=@typescriptType skipwhite skipempty
                            
                            syntax keyword typescriptTypeQuery typeof keyof
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
                            syntax cluster typescriptCallSignature contains=typescriptGenericCall,typescriptCall
                            syntax region typescriptGenericCall matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptCall
                              \ contained skipwhite skipnl
                            syntax region typescriptCall matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptBlock
                              \ contained skipwhite skipnl
                            
                            syntax match typescriptTypeAnnotation /:/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
                            syntax cluster typescriptParameterList contains=
                              \ typescriptTypeAnnotation,
                              \ typescriptAccessibilityModifier,
                              \ typescriptOptionalMark,
                              \ typescriptRestOrSpread,
                              \ typescriptFuncComma,
                              \ typescriptDefaultParam
                            
                            syntax match typescriptFuncComma /,/ contained
                            
                            syntax match typescriptDefaultParam /=/
                              \ nextgroup=@typescriptValue
                              \ contained skipwhite
                            
                            syntax keyword typescriptConstructSignature new
                              \ nextgroup=@typescriptCallSignature
                              \ contained skipwhite
                            
                            syntax region typescriptIndexSignature matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptPredefinedType,typescriptMappedIn,typescriptString
                              \ nextgroup=typescriptTypeAnnotation
                              \ contained skipwhite oneline
                            
                            syntax keyword typescriptMappedIn in
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl skipempty
                            
                            syntax keyword typescriptAliasKeyword type
                              \ nextgroup=typescriptAliasDeclaration
                              \ skipwhite skipnl skipempty
                            
                            syntax region typescriptAliasDeclaration matchgroup=typescriptUnion
                              \ start=/ / end=/=/
                              \ nextgroup=@typescriptType
                              \ contains=typescriptConstraint,typescriptTypeParameters
                              \ contained skipwhite skipempty
                            
                            syntax keyword typescriptReadonlyArrayKeyword readonly
                              \ nextgroup=@typescriptPrimaryType
                              \ skipwhite
                            
                            " extension
                            if get(g:, 'yats_host_keyword', 1)
                              "runtime syntax/yats.vim
                              "runtime syntax/yats/typescript.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function Boolean
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Error EvalError
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName InternalError
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName RangeError ReferenceError
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName StopIteration
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName SyntaxError TypeError
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName URIError Date
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float32Array
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float64Array
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int16Array Int32Array
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int8Array Uint16Array
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint32Array Uint8Array
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint8ClampedArray
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName ParallelArray
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName ArrayBuffer DataView
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Iterator Generator
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect Proxy
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName arguments
                              hi def link typescriptGlobal Structure
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName eval uneval nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isFinite nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isNaN parseFloat nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName parseInt nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURI nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURIComponent nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURI nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURIComponent nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptGlobalMethod
                              hi def link typescriptGlobalMethod Structure
                            
                              "runtime syntax/yats/es6-number.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Number nextgroup=typescriptGlobalNumberDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalNumberDot /\./ contained nextgroup=typescriptNumberStaticProp,typescriptNumberStaticMethod,typescriptProp
                              syntax keyword typescriptNumberStaticProp contained EPSILON MAX_SAFE_INTEGER MAX_VALUE
                              syntax keyword typescriptNumberStaticProp contained MIN_SAFE_INTEGER MIN_VALUE NEGATIVE_INFINITY
                              syntax keyword typescriptNumberStaticProp contained NaN POSITIVE_INFINITY
                              hi def link typescriptNumberStaticProp Keyword
                              syntax keyword typescriptNumberStaticMethod contained isFinite isInteger isNaN isSafeInteger nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptNumberStaticMethod contained parseFloat parseInt nextgroup=typescriptFuncCallArg
                              hi def link typescriptNumberStaticMethod Keyword
                              syntax keyword typescriptNumberMethod contained toExponential toFixed toLocaleString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptNumberMethod contained toPrecision toSource toString valueOf nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptNumberMethod
                              hi def link typescriptNumberMethod Keyword
                            
                              "runtime syntax/yats/es6-string.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName String nextgroup=typescriptGlobalStringDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalStringDot /\./ contained nextgroup=typescriptStringStaticMethod,typescriptProp
                              syntax keyword typescriptStringStaticMethod contained fromCharCode fromCodePoint raw nextgroup=typescriptFuncCallArg
                              hi def link typescriptStringStaticMethod Keyword
                              syntax keyword typescriptStringMethod contained anchor charAt charCodeAt codePointAt nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained concat endsWith includes indexOf lastIndexOf nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained link localeCompare match normalize nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained padStart padEnd repeat replace search nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained slice split startsWith substr substring nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained toLocaleLowerCase toLocaleUpperCase nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained toLowerCase toString toUpperCase trim nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptStringMethod contained valueOf nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptStringMethod
                              hi def link typescriptStringMethod Keyword
                            
                              "runtime syntax/yats/es6-array.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Array nextgroup=typescriptGlobalArrayDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalArrayDot /\./ contained nextgroup=typescriptArrayStaticMethod,typescriptProp
                              syntax keyword typescriptArrayStaticMethod contained from isArray of nextgroup=typescriptFuncCallArg
                              hi def link typescriptArrayStaticMethod Keyword
                              syntax keyword typescriptArrayMethod contained concat copyWithin entries every fill nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptArrayMethod contained filter find findIndex forEach indexOf nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptArrayMethod contained includes join keys lastIndexOf map nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptArrayMethod contained pop push reduce reduceRight reverse nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptArrayMethod contained shift slice some sort splice toLocaleString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptArrayMethod contained toSource toString unshift nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptArrayMethod
                              hi def link typescriptArrayMethod Keyword
                            
                              "runtime syntax/yats/es6-object.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Object nextgroup=typescriptGlobalObjectDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalObjectDot /\./ contained nextgroup=typescriptObjectStaticMethod,typescriptProp
                              syntax keyword typescriptObjectStaticMethod contained create defineProperties defineProperty nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectStaticMethod contained entries freeze getOwnPropertyDescriptors nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectStaticMethod contained getOwnPropertyDescriptor getOwnPropertyNames nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectStaticMethod contained getOwnPropertySymbols getPrototypeOf nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectStaticMethod contained is isExtensible isFrozen isSealed nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectStaticMethod contained keys preventExtensions values nextgroup=typescriptFuncCallArg
                              hi def link typescriptObjectStaticMethod Keyword
                              syntax keyword typescriptObjectMethod contained getOwnPropertyDescriptors hasOwnProperty nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectMethod contained isPrototypeOf propertyIsEnumerable nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectMethod contained toLocaleString toString valueOf seal nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptObjectMethod contained setPrototypeOf nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptObjectMethod
                              hi def link typescriptObjectMethod Keyword
                            
                              "runtime syntax/yats/es6-symbol.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Symbol nextgroup=typescriptGlobalSymbolDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalSymbolDot /\./ contained nextgroup=typescriptSymbolStaticProp,typescriptSymbolStaticMethod,typescriptProp
                              syntax keyword typescriptSymbolStaticProp contained length iterator match replace
                              syntax keyword typescriptSymbolStaticProp contained search split hasInstance isConcatSpreadable
                              syntax keyword typescriptSymbolStaticProp contained unscopables species toPrimitive
                              syntax keyword typescriptSymbolStaticProp contained toStringTag
                              hi def link typescriptSymbolStaticProp Keyword
                              syntax keyword typescriptSymbolStaticMethod contained for keyFor nextgroup=typescriptFuncCallArg
                              hi def link typescriptSymbolStaticMethod Keyword
                            
                              "runtime syntax/yats/es6-function.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function
                              syntax keyword typescriptFunctionMethod contained apply bind call nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptFunctionMethod
                              hi def link typescriptFunctionMethod Keyword
                            
                              "runtime syntax/yats/es6-math.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Math nextgroup=typescriptGlobalMathDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalMathDot /\./ contained nextgroup=typescriptMathStaticProp,typescriptMathStaticMethod,typescriptProp
                              syntax keyword typescriptMathStaticProp contained E LN10 LN2 LOG10E LOG2E PI SQRT1_2
                              syntax keyword typescriptMathStaticProp contained SQRT2
                              hi def link typescriptMathStaticProp Keyword
                              syntax keyword typescriptMathStaticMethod contained abs acos acosh asin asinh atan nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptMathStaticMethod contained atan2 atanh cbrt ceil clz32 cos nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptMathStaticMethod contained cosh exp expm1 floor fround hypot nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptMathStaticMethod contained imul log log10 log1p log2 max nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptMathStaticMethod contained min pow random round sign sin nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptMathStaticMethod contained sinh sqrt tan tanh trunc nextgroup=typescriptFuncCallArg
                              hi def link typescriptMathStaticMethod Keyword
                            
                              "runtime syntax/yats/es6-date.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Date nextgroup=typescriptGlobalDateDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalDateDot /\./ contained nextgroup=typescriptDateStaticMethod,typescriptProp
                              syntax keyword typescriptDateStaticMethod contained UTC now parse nextgroup=typescriptFuncCallArg
                              hi def link typescriptDateStaticMethod Keyword
                              syntax keyword typescriptDateMethod contained getDate getDay getFullYear getHours nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained getMilliseconds getMinutes getMonth nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained getSeconds getTime getTimezoneOffset nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained getUTCDate getUTCDay getUTCFullYear nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained getUTCHours getUTCMilliseconds getUTCMinutes nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained getUTCMonth getUTCSeconds setDate setFullYear nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained setHours setMilliseconds setMinutes nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained setMonth setSeconds setTime setUTCDate nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained setUTCFullYear setUTCHours setUTCMilliseconds nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained setUTCMinutes setUTCMonth setUTCSeconds nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained toDateString toISOString toJSON toLocaleDateString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained toLocaleFormat toLocaleString toLocaleTimeString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained toSource toString toTimeString toUTCString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDateMethod contained valueOf nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptDateMethod
                              hi def link typescriptDateMethod Keyword
                            
                              "runtime syntax/yats/es6-json.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName JSON nextgroup=typescriptGlobalJSONDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalJSONDot /\./ contained nextgroup=typescriptJSONStaticMethod,typescriptProp
                              syntax keyword typescriptJSONStaticMethod contained parse stringify nextgroup=typescriptFuncCallArg
                              hi def link typescriptJSONStaticMethod Keyword
                            
                              "runtime syntax/yats/es6-regexp.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName RegExp nextgroup=typescriptGlobalRegExpDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalRegExpDot /\./ contained nextgroup=typescriptRegExpStaticProp,typescriptProp
                              syntax keyword typescriptRegExpStaticProp contained lastIndex
                              hi def link typescriptRegExpStaticProp Keyword
                              syntax keyword typescriptRegExpProp contained global ignoreCase multiline source sticky
                              syntax cluster props add=typescriptRegExpProp
                              hi def link typescriptRegExpProp Keyword
                              syntax keyword typescriptRegExpMethod contained exec test nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptRegExpMethod
                              hi def link typescriptRegExpMethod Keyword
                            
                              "runtime syntax/yats/es6-map.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Map WeakMap
                              syntax keyword typescriptES6MapProp contained size
                              syntax cluster props add=typescriptES6MapProp
                              hi def link typescriptES6MapProp Keyword
                              syntax keyword typescriptES6MapMethod contained clear delete entries forEach get has nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptES6MapMethod contained keys set values nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptES6MapMethod
                              hi def link typescriptES6MapMethod Keyword
                            
                              "runtime syntax/yats/es6-set.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Set WeakSet
                              syntax keyword typescriptES6SetProp contained size
                              syntax cluster props add=typescriptES6SetProp
                              hi def link typescriptES6SetProp Keyword
                              syntax keyword typescriptES6SetMethod contained add clear delete entries forEach has nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptES6SetMethod contained values nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptES6SetMethod
                              hi def link typescriptES6SetMethod Keyword
                            
                              "runtime syntax/yats/es6-proxy.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Proxy
                              syntax keyword typescriptProxyAPI contained getOwnPropertyDescriptor getOwnPropertyNames
                              syntax keyword typescriptProxyAPI contained defineProperty deleteProperty freeze seal
                              syntax keyword typescriptProxyAPI contained preventExtensions has hasOwn get set enumerate
                              syntax keyword typescriptProxyAPI contained iterate ownKeys apply construct
                              hi def link typescriptProxyAPI Keyword
                            
                              "runtime syntax/yats/es6-promise.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Promise nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalPromiseDot /\./ contained nextgroup=typescriptPromiseStaticMethod,typescriptProp
                              syntax keyword typescriptPromiseStaticMethod contained resolve reject all race nextgroup=typescriptFuncCallArg
                              hi def link typescriptPromiseStaticMethod Keyword
                              syntax keyword typescriptPromiseMethod contained then catch finally nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptPromiseMethod
                              hi def link typescriptPromiseMethod Keyword
                            
                              "runtime syntax/yats/es6-reflect.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect
                              syntax keyword typescriptReflectMethod contained apply construct defineProperty deleteProperty nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptReflectMethod contained enumerate get getOwnPropertyDescriptor nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptReflectMethod contained getPrototypeOf has isExtensible ownKeys nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptReflectMethod contained preventExtensions set setPrototypeOf nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptReflectMethod
                              hi def link typescriptReflectMethod Keyword
                            
                              "runtime syntax/yats/ecma-402.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Intl
                              syntax keyword typescriptIntlMethod contained Collator DateTimeFormat NumberFormat nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptIntlMethod contained PluralRules nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptIntlMethod
                              hi def link typescriptIntlMethod Keyword
                            
                              "runtime syntax/yats/node.vim
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName global process
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName console Buffer
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName module exports
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setTimeout
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearTimeout
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setInterval
                              syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearInterval
                              hi def link typescriptNodeGlobal Structure
                            
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName describe it test
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName before after
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName beforeEach afterEach
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName beforeAll afterAll
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName expect assert
                            
                              "runtime syntax/yats/web.vim
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName AbortController
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName AbstractWorker AnalyserNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName App Apps ArrayBuffer
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ArrayBufferView
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Attr AudioBuffer
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioBufferSourceNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioContext AudioDestinationNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioListener AudioNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioParam BatteryManager
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName BiquadFilterNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName BlobEvent BluetoothAdapter
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothDevice
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothManager
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraCapabilities
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraControl CameraManager
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasGradient CanvasImageSource
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasPattern CanvasRenderingContext2D
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CaretPosition CDATASection
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelMergerNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelSplitterNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CharacterData ChildNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ChromeWorker Comment
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Connection Console
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ContactManager Contacts
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ConvolverNode Coordinates
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSS CSSConditionRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSGroupingRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframeRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframesRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSMediaRule CSSNamespaceRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSPageRule CSSRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSRuleList CSSStyleDeclaration
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSStyleRule CSSStyleSheet
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSSupportsRule
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DataTransfer DataView
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DedicatedWorkerGlobalScope
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DelayNode DeviceAcceleration
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceRotationRate
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceStorage DirectoryEntry
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryEntrySync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReader
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReaderSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Document DocumentFragment
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DocumentTouch DocumentType
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMCursor DOMError
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMException DOMHighResTimeStamp
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementation
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementationRegistry
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMParser DOMRequest
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMString DOMStringList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMStringMap DOMTimeStamp
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMTokenList DynamicsCompressorNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Element Entry EntrySync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Extensions FileException
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Float32Array Float64Array
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName FMRadio FormData
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName GainNode Gamepad
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName GamepadButton Geolocation
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName History HTMLAnchorElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAreaElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAudioElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBaseElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBodyElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBRElement HTMLButtonElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCanvasElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCollection HTMLDataElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDataListElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDivElement HTMLDListElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDocument HTMLElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLEmbedElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFieldSetElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormControlsCollection
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadingElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHRElement HTMLHtmlElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLIFrameElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLImageElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLInputElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLKeygenElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLabelElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLegendElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLIElement HTMLLinkElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMapElement HTMLMediaElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMetaElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMeterElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLModElement HTMLObjectElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOListElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptGroupElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionsCollection
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOutputElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParagraphElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParamElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLPreElement HTMLProgressElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLQuoteElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLScriptElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSelectElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSourceElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSpanElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLStyleElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCaptionElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCellElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableColElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableDataCellElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableHeaderCellElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableRowElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableSectionElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTextAreaElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTimeElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTitleElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTrackElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUListElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUnknownElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLVideoElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursor IDBCursorSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursorWithValue
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBDatabase IDBDatabaseSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBEnvironment IDBEnvironmentSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBFactory IDBFactorySync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBIndex IDBIndexSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBKeyRange IDBObjectStore
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBObjectStoreSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBOpenDBRequest
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBRequest IDBTransaction
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBTransactionSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBVersionChangeEvent
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ImageData IndexedDB
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Int16Array Int32Array
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Int8Array L10n LinkStyle
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystem
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystemSync
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Location LockedFile
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaQueryList MediaQueryListListener
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaRecorder MediaSource
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaStream MediaStreamTrack
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName MutationObserver
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Navigator NavigatorGeolocation
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorID NavigatorLanguage
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorOnLine
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorPlugins
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Node NodeFilter
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName NodeIterator NodeList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Notification OfflineAudioContext
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName OscillatorNode PannerNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ParentNode Performance
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceNavigation
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceTiming
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Permissions PermissionSettings
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Plugin PluginArray
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Position PositionError
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName PositionOptions
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName PowerManager ProcessingInstruction
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName PromiseResolver
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName PushManager Range
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCConfiguration
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnection
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnectionErrorCallback
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescription
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescriptionCallback
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ScriptProcessorNode
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Selection SettingsLock
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SettingsManager
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SharedWorker StyleSheet
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName StyleSheetList SVGAElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAngle SVGAnimateColorElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedAngle
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedBoolean
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedEnumeration
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedInteger
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLength
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLengthList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumber
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumberList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPoints
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPreserveAspectRatio
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedRect
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedString
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedTransformList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateMotionElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateTransformElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimationElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCircleElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGClipPathElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCursorElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGDefsElement SVGDescElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGElement SVGEllipseElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFilterElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontElement SVGFontFaceElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceFormatElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceNameElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceSrcElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceUriElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGForeignObjectElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGElement SVGGlyphElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGradientElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGHKernElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGImageElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLength SVGLengthList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLinearGradientElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLineElement SVGMaskElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMatrix SVGMissingGlyphElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMPathElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGNumber SVGNumberList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPathElement SVGPatternElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPoint SVGPolygonElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPolylineElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPreserveAspectRatio
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRadialGradientElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRect SVGRectElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGScriptElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSetElement SVGStopElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStringList SVGStylable
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStyleElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSVGElement SVGSwitchElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSymbolElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTests SVGTextElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTextPositioningElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTitleElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransform SVGTransformable
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransformList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTRefElement SVGTSpanElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGUseElement SVGViewElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGVKernElement
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPServerSocket
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPSocket Telephony
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName TelephonyCall Text
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName TextDecoder TextEncoder
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName TextMetrics TimeRanges
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Touch TouchList
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Transferable TreeWalker
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint16Array Uint32Array
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint8Array Uint8ClampedArray
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName URLSearchParams
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName URLUtilsReadOnly
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName UserProximityEvent
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName ValidityState VideoPlaybackQuality
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName WaveShaperNode WebBluetooth
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName WebGLRenderingContext
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName WebSMS WebSocket
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName WebVTT WifiManager
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName Window Worker WorkerConsole
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName WorkerLocation WorkerNavigator
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName XDomainRequest XMLDocument
                              syntax keyword typescriptBOM containedin=typescriptIdentifierName XMLHttpRequestEventTarget
                              hi def link typescriptBOM Structure
                            
                              "runtime syntax/yats/web-window.vim
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName applicationCache
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName closed
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName Components
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName controllers
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName dialogArguments
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName document
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frameElement
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frames
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName fullScreen
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName history
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerHeight
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerWidth
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName length
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName location
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName locationbar
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName menubar
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName messageManager
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName name navigator
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName opener
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerHeight
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerWidth
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageXOffset
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageYOffset
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName parent
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName performance
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName personalbar
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName returnValue
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screen
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenX
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenY
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollbars
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxX
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxY
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollX
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollY
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName self sidebar
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName status
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName statusbar
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName toolbar
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName top visualViewport
                              syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName window
                              syntax cluster props add=typescriptBOMWindowProp
                              hi def link typescriptBOMWindowProp Structure
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName alert nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName atob nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName blur nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName btoa nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearImmediate nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearInterval nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearTimeout nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName close nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName confirm nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName dispatchEvent nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName find nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName focus nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttention nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttentionWithCycleCount nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getComputedStyle nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getDefaulComputedStyle nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getSelection nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName matchMedia nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName maximize nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveBy nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveTo nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName open nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName openDialog nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName postMessage nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName print nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName prompt nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName removeEventListener nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeBy nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeTo nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName restore nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scroll nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollBy nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByLines nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByPages nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollTo nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setCursor nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setImmediate nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setInterval nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setResizable nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setTimeout nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName showModalDialog nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName sizeToContent nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName stop nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName updateCommands nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptBOMWindowMethod
                              hi def link typescriptBOMWindowMethod Structure
                              syntax keyword typescriptBOMWindowEvent contained onabort onbeforeunload onblur onchange
                              syntax keyword typescriptBOMWindowEvent contained onclick onclose oncontextmenu ondevicelight
                              syntax keyword typescriptBOMWindowEvent contained ondevicemotion ondeviceorientation
                              syntax keyword typescriptBOMWindowEvent contained ondeviceproximity ondragdrop onerror
                              syntax keyword typescriptBOMWindowEvent contained onfocus onhashchange onkeydown onkeypress
                              syntax keyword typescriptBOMWindowEvent contained onkeyup onload onmousedown onmousemove
                              syntax keyword typescriptBOMWindowEvent contained onmouseout onmouseover onmouseup
                              syntax keyword typescriptBOMWindowEvent contained onmozbeforepaint onpaint onpopstate
                              syntax keyword typescriptBOMWindowEvent contained onreset onresize onscroll onselect
                              syntax keyword typescriptBOMWindowEvent contained onsubmit onunload onuserproximity
                              syntax keyword typescriptBOMWindowEvent contained onpageshow onpagehide
                              hi def link typescriptBOMWindowEvent Keyword
                              syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName DOMParser
                              syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName QueryInterface
                              syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName XMLSerializer
                              hi def link typescriptBOMWindowCons Structure
                            
                              "runtime syntax/yats/web-navigator.vim
                              syntax keyword typescriptBOMNavigatorProp contained battery buildID connection cookieEnabled
                              syntax keyword typescriptBOMNavigatorProp contained doNotTrack maxTouchPoints oscpu
                              syntax keyword typescriptBOMNavigatorProp contained productSub push serviceWorker
                              syntax keyword typescriptBOMNavigatorProp contained vendor vendorSub
                              syntax cluster props add=typescriptBOMNavigatorProp
                              hi def link typescriptBOMNavigatorProp Keyword
                              syntax keyword typescriptBOMNavigatorMethod contained addIdleObserver geolocation nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMNavigatorMethod contained getDeviceStorage getDeviceStorages nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMNavigatorMethod contained getGamepads getUserMedia registerContentHandler nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMNavigatorMethod contained removeIdleObserver requestWakeLock nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMNavigatorMethod contained share vibrate watch registerProtocolHandler nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptBOMNavigatorMethod contained sendBeacon nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptBOMNavigatorMethod
                              hi def link typescriptBOMNavigatorMethod Keyword
                              syntax keyword typescriptServiceWorkerMethod contained register nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptServiceWorkerMethod
                              hi def link typescriptServiceWorkerMethod Keyword
                            
                              "runtime syntax/yats/web-location.vim
                              syntax keyword typescriptBOMLocationProp contained href protocol host hostname port
                              syntax keyword typescriptBOMLocationProp contained pathname search hash username password
                              syntax keyword typescriptBOMLocationProp contained origin
                              syntax cluster props add=typescriptBOMLocationProp
                              hi def link typescriptBOMLocationProp Keyword
                              syntax keyword typescriptBOMLocationMethod contained assign reload replace toString nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptBOMLocationMethod
                              hi def link typescriptBOMLocationMethod Keyword
                            
                              "runtime syntax/yats/web-history.vim
                              syntax keyword typescriptBOMHistoryProp contained length current next previous state
                              syntax keyword typescriptBOMHistoryProp contained scrollRestoration
                              syntax cluster props add=typescriptBOMHistoryProp
                              hi def link typescriptBOMHistoryProp Keyword
                              syntax keyword typescriptBOMHistoryMethod contained back forward go pushState replaceState nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptBOMHistoryMethod
                              hi def link typescriptBOMHistoryMethod Keyword
                            
                              "runtime syntax/yats/web-console.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName console
                              syntax keyword typescriptConsoleMethod contained count dir error group groupCollapsed nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptConsoleMethod contained groupEnd info log time timeEnd trace nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptConsoleMethod contained warn nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptConsoleMethod
                              hi def link typescriptConsoleMethod Keyword
                            
                              "runtime syntax/yats/web-xhr.vim
                              syntax keyword typescriptXHRGlobal containedin=typescriptIdentifierName XMLHttpRequest
                              hi def link typescriptXHRGlobal Structure
                              syntax keyword typescriptXHRProp contained onreadystatechange readyState response
                              syntax keyword typescriptXHRProp contained responseText responseType responseXML status
                              syntax keyword typescriptXHRProp contained statusText timeout ontimeout upload withCredentials
                              syntax cluster props add=typescriptXHRProp
                              hi def link typescriptXHRProp Keyword
                              syntax keyword typescriptXHRMethod contained abort getAllResponseHeaders getResponseHeader nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptXHRMethod contained open overrideMimeType send setRequestHeader nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptXHRMethod
                              hi def link typescriptXHRMethod Keyword
                            
                              "runtime syntax/yats/web-blob.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Blob BlobBuilder
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName File FileReader
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName FileReaderSync
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName URL nextgroup=typescriptGlobalURLDot,typescriptFuncCallArg
                              syntax match   typescriptGlobalURLDot /\./ contained nextgroup=typescriptURLStaticMethod,typescriptProp
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName URLUtils
                              syntax keyword typescriptFileMethod contained readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptFileMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptFileMethod
                              hi def link typescriptFileMethod Keyword
                              syntax keyword typescriptFileReaderProp contained error readyState result
                              syntax cluster props add=typescriptFileReaderProp
                              hi def link typescriptFileReaderProp Keyword
                              syntax keyword typescriptFileReaderMethod contained abort readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptFileReaderMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptFileReaderMethod
                              hi def link typescriptFileReaderMethod Keyword
                              syntax keyword typescriptFileListMethod contained item nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptFileListMethod
                              hi def link typescriptFileListMethod Keyword
                              syntax keyword typescriptBlobMethod contained append getBlob getFile nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptBlobMethod
                              hi def link typescriptBlobMethod Keyword
                              syntax keyword typescriptURLUtilsProp contained hash host hostname href origin password
                              syntax keyword typescriptURLUtilsProp contained pathname port protocol search searchParams
                              syntax keyword typescriptURLUtilsProp contained username
                              syntax cluster props add=typescriptURLUtilsProp
                              hi def link typescriptURLUtilsProp Keyword
                              syntax keyword typescriptURLStaticMethod contained createObjectURL revokeObjectURL nextgroup=typescriptFuncCallArg
                              hi def link typescriptURLStaticMethod Keyword
                            
                              "runtime syntax/yats/web-crypto.vim
                              syntax keyword typescriptCryptoGlobal containedin=typescriptIdentifierName crypto
                              hi def link typescriptCryptoGlobal Structure
                              syntax keyword typescriptSubtleCryptoMethod contained encrypt decrypt sign verify nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptSubtleCryptoMethod contained digest nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptSubtleCryptoMethod
                              hi def link typescriptSubtleCryptoMethod Keyword
                              syntax keyword typescriptCryptoProp contained subtle
                              syntax cluster props add=typescriptCryptoProp
                              hi def link typescriptCryptoProp Keyword
                              syntax keyword typescriptCryptoMethod contained getRandomValues nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptCryptoMethod
                              hi def link typescriptCryptoMethod Keyword
                            
                              "runtime syntax/yats/web-fetch.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Headers Request
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Response
                              syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName fetch nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptGlobalMethod
                              hi def link typescriptGlobalMethod Structure
                              syntax keyword typescriptHeadersMethod contained append delete get getAll has set nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptHeadersMethod
                              hi def link typescriptHeadersMethod Keyword
                              syntax keyword typescriptRequestProp contained method url headers context referrer
                              syntax keyword typescriptRequestProp contained mode credentials cache
                              syntax cluster props add=typescriptRequestProp
                              hi def link typescriptRequestProp Keyword
                              syntax keyword typescriptRequestMethod contained clone nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptRequestMethod
                              hi def link typescriptRequestMethod Keyword
                              syntax keyword typescriptResponseProp contained type url status statusText headers
                              syntax keyword typescriptResponseProp contained redirected
                              syntax cluster props add=typescriptResponseProp
                              hi def link typescriptResponseProp Keyword
                              syntax keyword typescriptResponseMethod contained clone nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptResponseMethod
                              hi def link typescriptResponseMethod Keyword
                            
                              "runtime syntax/yats/web-service-worker.vim
                              syntax keyword typescriptServiceWorkerProp contained controller ready
                              syntax cluster props add=typescriptServiceWorkerProp
                              hi def link typescriptServiceWorkerProp Keyword
                              syntax keyword typescriptServiceWorkerMethod contained register getRegistration nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptServiceWorkerMethod
                              hi def link typescriptServiceWorkerMethod Keyword
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Cache
                              syntax keyword typescriptCacheMethod contained match matchAll add addAll put delete nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptCacheMethod contained keys nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptCacheMethod
                              hi def link typescriptCacheMethod Keyword
                            
                              "runtime syntax/yats/web-encoding.vim
                              syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextEncoder
                              syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextDecoder
                              hi def link typescriptEncodingGlobal Structure
                              syntax keyword typescriptEncodingProp contained encoding fatal ignoreBOM
                              syntax cluster props add=typescriptEncodingProp
                              hi def link typescriptEncodingProp Keyword
                              syntax keyword typescriptEncodingMethod contained encode decode nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptEncodingMethod
                              hi def link typescriptEncodingMethod Keyword
                            
                              "runtime syntax/yats/web-geo.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName Geolocation
                              syntax keyword typescriptGeolocationMethod contained getCurrentPosition watchPosition nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptGeolocationMethod contained clearWatch nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptGeolocationMethod
                              hi def link typescriptGeolocationMethod Keyword
                            
                              "runtime syntax/yats/web-network.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName NetworkInformation
                              syntax keyword typescriptBOMNetworkProp contained downlink downlinkMax effectiveType
                              syntax keyword typescriptBOMNetworkProp contained rtt type
                              syntax cluster props add=typescriptBOMNetworkProp
                              hi def link typescriptBOMNetworkProp Keyword
                            
                              "runtime syntax/yats/web-payment.vim
                              syntax keyword typescriptGlobal containedin=typescriptIdentifierName PaymentRequest
                              syntax keyword typescriptPaymentMethod contained show abort canMakePayment nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptPaymentMethod
                              hi def link typescriptPaymentMethod Keyword
                              syntax keyword typescriptPaymentProp contained shippingAddress shippingOption result
                              syntax cluster props add=typescriptPaymentProp
                              hi def link typescriptPaymentProp Keyword
                              syntax keyword typescriptPaymentEvent contained onshippingaddresschange onshippingoptionchange
                              hi def link typescriptPaymentEvent Keyword
                              syntax keyword typescriptPaymentResponseMethod contained complete nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptPaymentResponseMethod
                              hi def link typescriptPaymentResponseMethod Keyword
                              syntax keyword typescriptPaymentResponseProp contained details methodName payerEmail
                              syntax keyword typescriptPaymentResponseProp contained payerPhone shippingAddress
                              syntax keyword typescriptPaymentResponseProp contained shippingOption
                              syntax cluster props add=typescriptPaymentResponseProp
                              hi def link typescriptPaymentResponseProp Keyword
                              syntax keyword typescriptPaymentAddressProp contained addressLine careOf city country
                              syntax keyword typescriptPaymentAddressProp contained country dependentLocality languageCode
                              syntax keyword typescriptPaymentAddressProp contained organization phone postalCode
                              syntax keyword typescriptPaymentAddressProp contained recipient region sortingCode
                              syntax cluster props add=typescriptPaymentAddressProp
                              hi def link typescriptPaymentAddressProp Keyword
                              syntax keyword typescriptPaymentShippingOptionProp contained id label amount selected
                              syntax cluster props add=typescriptPaymentShippingOptionProp
                              hi def link typescriptPaymentShippingOptionProp Keyword
                            
                              "runtime syntax/yats/dom-node.vim
                              syntax keyword typescriptDOMNodeProp contained attributes baseURI baseURIObject childNodes
                              syntax keyword typescriptDOMNodeProp contained firstChild lastChild localName namespaceURI
                              syntax keyword typescriptDOMNodeProp contained nextSibling nodeName nodePrincipal
                              syntax keyword typescriptDOMNodeProp contained nodeType nodeValue ownerDocument parentElement
                              syntax keyword typescriptDOMNodeProp contained parentNode prefix previousSibling textContent
                              syntax cluster props add=typescriptDOMNodeProp
                              hi def link typescriptDOMNodeProp Keyword
                              syntax keyword typescriptDOMNodeMethod contained appendChild cloneNode compareDocumentPosition nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMNodeMethod contained getUserData hasAttributes hasChildNodes nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMNodeMethod contained insertBefore isDefaultNamespace isEqualNode nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMNodeMethod contained isSameNode isSupported lookupNamespaceURI nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMNodeMethod contained lookupPrefix normalize removeChild nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMNodeMethod contained replaceChild setUserData nextgroup=typescriptFuncCallArg
                              syntax match typescriptDOMNodeMethod contained /contains/
                              syntax cluster props add=typescriptDOMNodeMethod
                              hi def link typescriptDOMNodeMethod Keyword
                              syntax keyword typescriptDOMNodeType contained ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE
                              syntax keyword typescriptDOMNodeType contained CDATA_SECTION_NODEN_NODE ENTITY_REFERENCE_NODE
                              syntax keyword typescriptDOMNodeType contained ENTITY_NODE PROCESSING_INSTRUCTION_NODEN_NODE
                              syntax keyword typescriptDOMNodeType contained COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE
                              syntax keyword typescriptDOMNodeType contained DOCUMENT_FRAGMENT_NODE NOTATION_NODE
                              hi def link typescriptDOMNodeType Keyword
                            
                              "runtime syntax/yats/dom-elem.vim
                              syntax keyword typescriptDOMElemAttrs contained accessKey clientHeight clientLeft
                              syntax keyword typescriptDOMElemAttrs contained clientTop clientWidth id innerHTML
                              syntax keyword typescriptDOMElemAttrs contained length onafterscriptexecute onbeforescriptexecute
                              syntax keyword typescriptDOMElemAttrs contained oncopy oncut onpaste onwheel scrollHeight
                              syntax keyword typescriptDOMElemAttrs contained scrollLeft scrollTop scrollWidth tagName
                              syntax keyword typescriptDOMElemAttrs contained classList className name outerHTML
                              syntax keyword typescriptDOMElemAttrs contained style
                              hi def link typescriptDOMElemAttrs Keyword
                              syntax keyword typescriptDOMElemFuncs contained getAttributeNS getAttributeNode getAttributeNodeNS
                              syntax keyword typescriptDOMElemFuncs contained getBoundingClientRect getClientRects
                              syntax keyword typescriptDOMElemFuncs contained getElementsByClassName getElementsByTagName
                              syntax keyword typescriptDOMElemFuncs contained getElementsByTagNameNS hasAttribute
                              syntax keyword typescriptDOMElemFuncs contained hasAttributeNS insertAdjacentHTML
                              syntax keyword typescriptDOMElemFuncs contained matches querySelector querySelectorAll
                              syntax keyword typescriptDOMElemFuncs contained removeAttribute removeAttributeNS
                              syntax keyword typescriptDOMElemFuncs contained removeAttributeNode requestFullscreen
                              syntax keyword typescriptDOMElemFuncs contained requestPointerLock scrollIntoView
                              syntax keyword typescriptDOMElemFuncs contained setAttribute setAttributeNS setAttributeNode
                              syntax keyword typescriptDOMElemFuncs contained setAttributeNodeNS setCapture supports
                              syntax keyword typescriptDOMElemFuncs contained getAttribute
                              hi def link typescriptDOMElemFuncs Keyword
                            
                              "runtime syntax/yats/dom-document.vim
                              syntax keyword typescriptDOMDocProp contained activeElement body cookie defaultView
                              syntax keyword typescriptDOMDocProp contained designMode dir domain embeds forms head
                              syntax keyword typescriptDOMDocProp contained images lastModified links location plugins
                              syntax keyword typescriptDOMDocProp contained postMessage readyState referrer registerElement
                              syntax keyword typescriptDOMDocProp contained scripts styleSheets title vlinkColor
                              syntax keyword typescriptDOMDocProp contained xmlEncoding characterSet compatMode
                              syntax keyword typescriptDOMDocProp contained contentType currentScript doctype documentElement
                              syntax keyword typescriptDOMDocProp contained documentURI documentURIObject firstChild
                              syntax keyword typescriptDOMDocProp contained implementation lastStyleSheetSet namespaceURI
                              syntax keyword typescriptDOMDocProp contained nodePrincipal ononline pointerLockElement
                              syntax keyword typescriptDOMDocProp contained popupNode preferredStyleSheetSet selectedStyleSheetSet
                              syntax keyword typescriptDOMDocProp contained styleSheetSets textContent tooltipNode
                              syntax cluster props add=typescriptDOMDocProp
                              hi def link typescriptDOMDocProp Keyword
                              syntax keyword typescriptDOMDocMethod contained caretPositionFromPoint close createNodeIterator nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained createRange createTreeWalker elementFromPoint nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained getElementsByName adoptNode createAttribute nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained createCDATASection createComment createDocumentFragment nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained createElement createElementNS createEvent nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained createExpression createNSResolver nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained createProcessingInstruction createTextNode nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained enableStyleSheetsForSet evaluate execCommand nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained exitPointerLock getBoxObjectFor getElementById nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained getElementsByClassName getElementsByTagName nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained getElementsByTagNameNS getSelection nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained hasFocus importNode loadOverlay open nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained queryCommandSupported querySelector nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMDocMethod contained querySelectorAll write writeln nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptDOMDocMethod
                              hi def link typescriptDOMDocMethod Keyword
                            
                              "runtime syntax/yats/dom-event.vim
                              syntax keyword typescriptDOMEventTargetMethod contained addEventListener removeEventListener nextgroup=typescriptEventFuncCallArg
                              syntax keyword typescriptDOMEventTargetMethod contained dispatchEvent waitUntil nextgroup=typescriptEventFuncCallArg
                              syntax cluster props add=typescriptDOMEventTargetMethod
                              hi def link typescriptDOMEventTargetMethod Keyword
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AnimationEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AudioProcessingEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeInputEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeUnloadEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BlobEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ClipboardEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CloseEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CompositionEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CSSFontFaceLoadEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CustomEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceLightEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceMotionEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceOrientationEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceProximityEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DOMTransactionEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DragEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName EditingBeforeInputEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ErrorEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName FocusEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName GamepadEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName HashChangeEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName IDBVersionChangeEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName KeyboardEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MediaStreamEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MessageEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MouseEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MutationEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName OfflineAudioCompletionEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PageTransitionEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PointerEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PopStateEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ProgressEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RelatedEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RTCPeerConnectionIceEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SensorEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName StorageEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGZoomEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TimeEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TouchEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TrackEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TransitionEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UIEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UserProximityEvent
                              syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName WheelEvent
                              hi def link typescriptDOMEventCons Structure
                              syntax keyword typescriptDOMEventProp contained bubbles cancelable currentTarget defaultPrevented
                              syntax keyword typescriptDOMEventProp contained eventPhase target timeStamp type isTrusted
                              syntax keyword typescriptDOMEventProp contained isReload
                              syntax cluster props add=typescriptDOMEventProp
                              hi def link typescriptDOMEventProp Keyword
                              syntax keyword typescriptDOMEventMethod contained initEvent preventDefault stopImmediatePropagation nextgroup=typescriptEventFuncCallArg
                              syntax keyword typescriptDOMEventMethod contained stopPropagation respondWith default nextgroup=typescriptEventFuncCallArg
                              syntax cluster props add=typescriptDOMEventMethod
                              hi def link typescriptDOMEventMethod Keyword
                            
                              "runtime syntax/yats/dom-storage.vim
                              syntax keyword typescriptDOMStorage contained sessionStorage localStorage
                              hi def link typescriptDOMStorage Keyword
                              syntax keyword typescriptDOMStorageProp contained length
                              syntax cluster props add=typescriptDOMStorageProp
                              hi def link typescriptDOMStorageProp Keyword
                              syntax keyword typescriptDOMStorageMethod contained getItem key setItem removeItem nextgroup=typescriptFuncCallArg
                              syntax keyword typescriptDOMStorageMethod contained clear nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptDOMStorageMethod
                              hi def link typescriptDOMStorageMethod Keyword
                            
                              "runtime syntax/yats/dom-form.vim
                              syntax keyword typescriptDOMFormProp contained acceptCharset action elements encoding
                              syntax keyword typescriptDOMFormProp contained enctype length method name target
                              syntax cluster props add=typescriptDOMFormProp
                              hi def link typescriptDOMFormProp Keyword
                              syntax keyword typescriptDOMFormMethod contained reportValidity reset submit nextgroup=typescriptFuncCallArg
                              syntax cluster props add=typescriptDOMFormMethod
                              hi def link typescriptDOMFormMethod Keyword
                            
                              "runtime syntax/yats/css.vim
                              syntax keyword typescriptDOMStyle contained alignContent alignItems alignSelf animation
                              syntax keyword typescriptDOMStyle contained animationDelay animationDirection animationDuration
                              syntax keyword typescriptDOMStyle contained animationFillMode animationIterationCount
                              syntax keyword typescriptDOMStyle contained animationName animationPlayState animationTimingFunction
                              syntax keyword typescriptDOMStyle contained appearance backfaceVisibility background
                              syntax keyword typescriptDOMStyle contained backgroundAttachment backgroundBlendMode
                              syntax keyword typescriptDOMStyle contained backgroundClip backgroundColor backgroundImage
                              syntax keyword typescriptDOMStyle contained backgroundOrigin backgroundPosition backgroundRepeat
                              syntax keyword typescriptDOMStyle contained backgroundSize border borderBottom borderBottomColor
                              syntax keyword typescriptDOMStyle contained borderBottomLeftRadius borderBottomRightRadius
                              syntax keyword typescriptDOMStyle contained borderBottomStyle borderBottomWidth borderCollapse
                              syntax keyword typescriptDOMStyle contained borderColor borderImage borderImageOutset
                              syntax keyword typescriptDOMStyle contained borderImageRepeat borderImageSlice borderImageSource
                              syntax keyword typescriptDOMStyle contained borderImageWidth borderLeft borderLeftColor
                              syntax keyword typescriptDOMStyle contained borderLeftStyle borderLeftWidth borderRadius
                              syntax keyword typescriptDOMStyle contained borderRight borderRightColor borderRightStyle
                              syntax keyword typescriptDOMStyle contained borderRightWidth borderSpacing borderStyle
                              syntax keyword typescriptDOMStyle contained borderTop borderTopColor borderTopLeftRadius
                              syntax keyword typescriptDOMStyle contained borderTopRightRadius borderTopStyle borderTopWidth
                              syntax keyword typescriptDOMStyle contained borderWidth bottom boxDecorationBreak
                              syntax keyword typescriptDOMStyle contained boxShadow boxSizing breakAfter breakBefore
                              syntax keyword typescriptDOMStyle contained breakInside captionSide caretColor caretShape
                              syntax keyword typescriptDOMStyle contained caret clear clip clipPath color columns
                              syntax keyword typescriptDOMStyle contained columnCount columnFill columnGap columnRule
                              syntax keyword typescriptDOMStyle contained columnRuleColor columnRuleStyle columnRuleWidth
                              syntax keyword typescriptDOMStyle contained columnSpan columnWidth content counterIncrement
                              syntax keyword typescriptDOMStyle contained counterReset cursor direction display
                              syntax keyword typescriptDOMStyle contained emptyCells flex flexBasis flexDirection
                              syntax keyword typescriptDOMStyle contained flexFlow flexGrow flexShrink flexWrap
                              syntax keyword typescriptDOMStyle contained float font fontFamily fontFeatureSettings
                              syntax keyword typescriptDOMStyle contained fontKerning fontLanguageOverride fontSize
                              syntax keyword typescriptDOMStyle contained fontSizeAdjust fontStretch fontStyle fontSynthesis
                              syntax keyword typescriptDOMStyle contained fontVariant fontVariantAlternates fontVariantCaps
                              syntax keyword typescriptDOMStyle contained fontVariantEastAsian fontVariantLigatures
                              syntax keyword typescriptDOMStyle contained fontVariantNumeric fontVariantPosition
                              syntax keyword typescriptDOMStyle contained fontWeight grad grid gridArea gridAutoColumns
                              syntax keyword typescriptDOMStyle contained gridAutoFlow gridAutoPosition gridAutoRows
                              syntax keyword typescriptDOMStyle contained gridColumn gridColumnStart gridColumnEnd
                              syntax keyword typescriptDOMStyle contained gridRow gridRowStart gridRowEnd gridTemplate
                              syntax keyword typescriptDOMStyle contained gridTemplateAreas gridTemplateRows gridTemplateColumns
                              syntax keyword typescriptDOMStyle contained height hyphens imageRendering imageResolution
                              syntax keyword typescriptDOMStyle contained imageOrientation imeMode inherit justifyContent
                              syntax keyword typescriptDOMStyle contained left letterSpacing lineBreak lineHeight
                              syntax keyword typescriptDOMStyle contained listStyle listStyleImage listStylePosition
                              syntax keyword typescriptDOMStyle contained listStyleType margin marginBottom marginLeft
                              syntax keyword typescriptDOMStyle contained marginRight marginTop marks mask maskType
                              syntax keyword typescriptDOMStyle contained maxHeight maxWidth minHeight minWidth
                              syntax keyword typescriptDOMStyle contained mixBlendMode objectFit objectPosition
                              syntax keyword typescriptDOMStyle contained opacity order orphans outline outlineColor
                              syntax keyword typescriptDOMStyle contained outlineOffset outlineStyle outlineWidth
                              syntax keyword typescriptDOMStyle contained overflow overflowWrap overflowX overflowY
                              syntax keyword typescriptDOMStyle contained overflowClipBox padding paddingBottom
                              syntax keyword typescriptDOMStyle contained paddingLeft paddingRight paddingTop pageBreakAfter
                              syntax keyword typescriptDOMStyle contained pageBreakBefore pageBreakInside perspective
                              syntax keyword typescriptDOMStyle contained perspectiveOrigin pointerEvents position
                              syntax keyword typescriptDOMStyle contained quotes resize right shapeImageThreshold
                              syntax keyword typescriptDOMStyle contained shapeMargin shapeOutside tableLayout tabSize
                              syntax keyword typescriptDOMStyle contained textAlign textAlignLast textCombineHorizontal
                              syntax keyword typescriptDOMStyle contained textDecoration textDecorationColor textDecorationLine
                              syntax keyword typescriptDOMStyle contained textDecorationStyle textIndent textOrientation
                              syntax keyword typescriptDOMStyle contained textOverflow textRendering textShadow
                              syntax keyword typescriptDOMStyle contained textTransform textUnderlinePosition top
                              syntax keyword typescriptDOMStyle contained touchAction transform transformOrigin
                              syntax keyword typescriptDOMStyle contained transformStyle transition transitionDelay
                              syntax keyword typescriptDOMStyle contained transitionDuration transitionProperty
                              syntax keyword typescriptDOMStyle contained transitionTimingFunction unicodeBidi unicodeRange
                              syntax keyword typescriptDOMStyle contained userSelect userZoom verticalAlign visibility
                              syntax keyword typescriptDOMStyle contained whiteSpace width willChange wordBreak
                              syntax keyword typescriptDOMStyle contained wordSpacing wordWrap writingMode zIndex
                              hi def link typescriptDOMStyle Keyword
                            
                            
                            
                              let typescript_props = 1
                            
                              "runtime syntax/yats/event.vim
                              syntax keyword typescriptAnimationEvent contained animationend animationiteration
                              syntax keyword typescriptAnimationEvent contained animationstart beginEvent endEvent
                              syntax keyword typescriptAnimationEvent contained repeatEvent
                              syntax cluster events add=typescriptAnimationEvent
                              hi def link typescriptAnimationEvent Title
                              syntax keyword typescriptCSSEvent contained CssRuleViewRefreshed CssRuleViewChanged
                              syntax keyword typescriptCSSEvent contained CssRuleViewCSSLinkClicked transitionend
                              syntax cluster events add=typescriptCSSEvent
                              hi def link typescriptCSSEvent Title
                              syntax keyword typescriptDatabaseEvent contained blocked complete error success upgradeneeded
                              syntax keyword typescriptDatabaseEvent contained versionchange
                              syntax cluster events add=typescriptDatabaseEvent
                              hi def link typescriptDatabaseEvent Title
                              syntax keyword typescriptDocumentEvent contained DOMLinkAdded DOMLinkRemoved DOMMetaAdded
                              syntax keyword typescriptDocumentEvent contained DOMMetaRemoved DOMWillOpenModalDialog
                              syntax keyword typescriptDocumentEvent contained DOMModalDialogClosed unload
                              syntax cluster events add=typescriptDocumentEvent
                              hi def link typescriptDocumentEvent Title
                              syntax keyword typescriptDOMMutationEvent contained DOMAttributeNameChanged DOMAttrModified
                              syntax keyword typescriptDOMMutationEvent contained DOMCharacterDataModified DOMContentLoaded
                              syntax keyword typescriptDOMMutationEvent contained DOMElementNameChanged DOMNodeInserted
                              syntax keyword typescriptDOMMutationEvent contained DOMNodeInsertedIntoDocument DOMNodeRemoved
                              syntax keyword typescriptDOMMutationEvent contained DOMNodeRemovedFromDocument DOMSubtreeModified
                              syntax cluster events add=typescriptDOMMutationEvent
                              hi def link typescriptDOMMutationEvent Title
                              syntax keyword typescriptDragEvent contained drag dragdrop dragend dragenter dragexit
                              syntax keyword typescriptDragEvent contained draggesture dragleave dragover dragstart
                              syntax keyword typescriptDragEvent contained drop
                              syntax cluster events add=typescriptDragEvent
                              hi def link typescriptDragEvent Title
                              syntax keyword typescriptElementEvent contained invalid overflow underflow DOMAutoComplete
                              syntax keyword typescriptElementEvent contained command commandupdate
                              syntax cluster events add=typescriptElementEvent
                              hi def link typescriptElementEvent Title
                              syntax keyword typescriptFocusEvent contained blur change DOMFocusIn DOMFocusOut focus
                              syntax keyword typescriptFocusEvent contained focusin focusout
                              syntax cluster events add=typescriptFocusEvent
                              hi def link typescriptFocusEvent Title
                              syntax keyword typescriptFormEvent contained reset submit
                              syntax cluster events add=typescriptFormEvent
                              hi def link typescriptFormEvent Title
                              syntax keyword typescriptFrameEvent contained DOMFrameContentLoaded
                              syntax cluster events add=typescriptFrameEvent
                              hi def link typescriptFrameEvent Title
                              syntax keyword typescriptInputDeviceEvent contained click contextmenu DOMMouseScroll
                              syntax keyword typescriptInputDeviceEvent contained dblclick gamepadconnected gamepaddisconnected
                              syntax keyword typescriptInputDeviceEvent contained keydown keypress keyup MozGamepadButtonDown
                              syntax keyword typescriptInputDeviceEvent contained MozGamepadButtonUp mousedown mouseenter
                              syntax keyword typescriptInputDeviceEvent contained mouseleave mousemove mouseout
                              syntax keyword typescriptInputDeviceEvent contained mouseover mouseup mousewheel MozMousePixelScroll
                              syntax keyword typescriptInputDeviceEvent contained pointerlockchange pointerlockerror
                              syntax keyword typescriptInputDeviceEvent contained wheel
                              syntax cluster events add=typescriptInputDeviceEvent
                              hi def link typescriptInputDeviceEvent Title
                              syntax keyword typescriptMediaEvent contained audioprocess canplay canplaythrough
                              syntax keyword typescriptMediaEvent contained durationchange emptied ended ended loadeddata
                              syntax keyword typescriptMediaEvent contained loadedmetadata MozAudioAvailable pause
                              syntax keyword typescriptMediaEvent contained play playing ratechange seeked seeking
                              syntax keyword typescriptMediaEvent contained stalled suspend timeupdate volumechange
                              syntax keyword typescriptMediaEvent contained waiting complete
                              syntax cluster events add=typescriptMediaEvent
                              hi def link typescriptMediaEvent Title
                              syntax keyword typescriptMenuEvent contained DOMMenuItemActive DOMMenuItemInactive
                              syntax cluster events add=typescriptMenuEvent
                              hi def link typescriptMenuEvent Title
                              syntax keyword typescriptNetworkEvent contained datachange dataerror disabled enabled
                              syntax keyword typescriptNetworkEvent contained offline online statuschange connectionInfoUpdate
                              syntax cluster events add=typescriptNetworkEvent
                              hi def link typescriptNetworkEvent Title
                              syntax keyword typescriptProgressEvent contained abort error load loadend loadstart
                              syntax keyword typescriptProgressEvent contained progress timeout uploadprogress
                              syntax cluster events add=typescriptProgressEvent
                              hi def link typescriptProgressEvent Title
                              syntax keyword typescriptResourceEvent contained cached error load
                              syntax cluster events add=typescriptResourceEvent
                              hi def link typescriptResourceEvent Title
                              syntax keyword typescriptScriptEvent contained afterscriptexecute beforescriptexecute
                              syntax cluster events add=typescriptScriptEvent
                              hi def link typescriptScriptEvent Title
                              syntax keyword typescriptSensorEvent contained compassneedscalibration devicelight
                              syntax keyword typescriptSensorEvent contained devicemotion deviceorientation deviceproximity
                              syntax keyword typescriptSensorEvent contained orientationchange userproximity
                              syntax cluster events add=typescriptSensorEvent
                              hi def link typescriptSensorEvent Title
                              syntax keyword typescriptSessionHistoryEvent contained pagehide pageshow popstate
                              syntax cluster events add=typescriptSessionHistoryEvent
                              hi def link typescriptSessionHistoryEvent Title
                              syntax keyword typescriptStorageEvent contained change storage
                              syntax cluster events add=typescriptStorageEvent
                              hi def link typescriptStorageEvent Title
                              syntax keyword typescriptSVGEvent contained SVGAbort SVGError SVGLoad SVGResize SVGScroll
                              syntax keyword typescriptSVGEvent contained SVGUnload SVGZoom
                              syntax cluster events add=typescriptSVGEvent
                              hi def link typescriptSVGEvent Title
                              syntax keyword typescriptTabEvent contained visibilitychange
                              syntax cluster events add=typescriptTabEvent
                              hi def link typescriptTabEvent Title
                              syntax keyword typescriptTextEvent contained compositionend compositionstart compositionupdate
                              syntax keyword typescriptTextEvent contained copy cut paste select text
                              syntax cluster events add=typescriptTextEvent
                              hi def link typescriptTextEvent Title
                              syntax keyword typescriptTouchEvent contained touchcancel touchend touchenter touchleave
                              syntax keyword typescriptTouchEvent contained touchmove touchstart
                              syntax cluster events add=typescriptTouchEvent
                              hi def link typescriptTouchEvent Title
                              syntax keyword typescriptUpdateEvent contained checking downloading error noupdate
                              syntax keyword typescriptUpdateEvent contained obsolete updateready
                              syntax cluster events add=typescriptUpdateEvent
                              hi def link typescriptUpdateEvent Title
                              syntax keyword typescriptValueChangeEvent contained hashchange input readystatechange
                              syntax cluster events add=typescriptValueChangeEvent
                              hi def link typescriptValueChangeEvent Title
                              syntax keyword typescriptViewEvent contained fullscreen fullscreenchange fullscreenerror
                              syntax keyword typescriptViewEvent contained resize scroll
                              syntax cluster events add=typescriptViewEvent
                              hi def link typescriptViewEvent Title
                              syntax keyword typescriptWebsocketEvent contained close error message open
                              syntax cluster events add=typescriptWebsocketEvent
                              hi def link typescriptWebsocketEvent Title
                              syntax keyword typescriptWindowEvent contained DOMWindowCreated DOMWindowClose DOMTitleChanged
                              syntax cluster events add=typescriptWindowEvent
                              hi def link typescriptWindowEvent Title
                              syntax keyword typescriptUncategorizedEvent contained beforeunload message open show
                              syntax cluster events add=typescriptUncategorizedEvent
                              hi def link typescriptUncategorizedEvent Title
                              syntax keyword typescriptServiceWorkerEvent contained install activate fetch
                              syntax cluster events add=typescriptServiceWorkerEvent
                              hi def link typescriptServiceWorkerEvent Title
                            
                            
                            endif
                            
                            " patch
                            "runtime syntax/basic/patch.vim
                            " patch for generated code
                            syntax keyword typescriptGlobal Promise
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
                            syntax keyword typescriptGlobal Map WeakMap
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
                            
                            "runtime syntax/basic/members.vim
                            syntax keyword typescriptConstructor           contained constructor
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            
                            syntax cluster memberNextGroup contains=typescriptMemberOptionality,typescriptTypeAnnotation,@typescriptCallSignature
                            
                            syntax match typescriptMember /\K\k*/
                              \ nextgroup=@memberNextGroup
                              \ contained skipwhite
                            
                            syntax match typescriptMethodAccessor contained /\v(get|set)\s\K/me=e-1
                              \ nextgroup=@typescriptMembers
                            
                            syntax cluster typescriptPropertyMemberDeclaration contains=
                              \ typescriptClassStatic,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptMethodAccessor,
                              \ @typescriptMembers
                              " \ typescriptMemberVariableDeclaration
                            
                            syntax match typescriptMemberOptionality /?\|!/ contained
                              \ nextgroup=typescriptTypeAnnotation,@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            syntax cluster typescriptMembers contains=typescriptMember,typescriptStringMember,typescriptComputedMember
                            
                            syntax keyword typescriptClassStatic static
                              \ nextgroup=@typescriptMembers,typescriptAsyncFuncKeyword,typescriptReadonlyModifier
                              \ skipwhite contained
                            
                            syntax keyword typescriptAccessibilityModifier public private protected contained
                            
                            syntax keyword typescriptReadonlyModifier readonly contained
                            
                            syntax region  typescriptStringMember   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty
                            
                            syntax region  typescriptComputedMember   contained matchgroup=typescriptProperty
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue,typescriptMember,typescriptMappedIn
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty
                            
                            "runtime syntax/basic/class.vim
                            "don't add typescriptMembers to nextgroup, let outer scope match it
                            " so we won't match abstract method outside abstract class
                            syntax keyword typescriptAbstract              abstract
                              \ nextgroup=typescriptClassKeyword
                              \ skipwhite skipnl
                            syntax keyword typescriptClassKeyword          class
                              \ nextgroup=typescriptClassName,typescriptClassExtends,typescriptClassBlock
                              \ skipwhite
                            
                            syntax match   typescriptClassName             contained /\K\k*/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptClassTypeParameter
                              \ skipwhite skipnl
                            
                            syntax region typescriptClassTypeParameter
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends
                              \ contained skipwhite skipnl
                            
                            syntax keyword typescriptClassExtends          contained extends implements nextgroup=typescriptClassHeritage skipwhite skipnl
                            
                            syntax match   typescriptClassHeritage         contained /\v(\k|\.|\(|\))+/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptMixinComma,typescriptClassTypeArguments
                              \ contains=@typescriptValue
                              \ skipwhite skipnl
                              \ contained
                            
                            syntax region typescriptClassTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptClassExtends,typescriptClassBlock,typescriptMixinComma
                              \ contained skipwhite skipnl
                            
                            syntax match typescriptMixinComma /,/ contained nextgroup=typescriptClassHeritage skipwhite skipnl
                            
                            " we need add arrowFunc to class block for high order arrow func
                            " see test case
                            syntax region  typescriptClassBlock matchgroup=typescriptBraces start=/{/ end=/}/
                              \ contains=@typescriptPropertyMemberDeclaration,typescriptAbstract,@typescriptComments,typescriptBlock,typescriptAssign,typescriptDecorator,typescriptAsyncFuncKeyword,typescriptArrowFunc
                              \ contained fold
                            
                            syntax keyword typescriptInterfaceKeyword          interface nextgroup=typescriptInterfaceName skipwhite
                            syntax match   typescriptInterfaceName             contained /\k\+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends,typescriptInterfaceTypeParameter
                              \ skipwhite skipnl
                            syntax region typescriptInterfaceTypeParameter
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends
                              \ contained
                              \ skipwhite skipnl
                            
                            syntax keyword typescriptInterfaceExtends          contained extends nextgroup=typescriptInterfaceHeritage skipwhite skipnl
                            
                            syntax match typescriptInterfaceHeritage contained /\v(\k|\.)+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma,typescriptInterfaceTypeArguments
                              \ skipwhite
                            
                            syntax region typescriptInterfaceTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma
                              \ contained skipwhite
                            
                            syntax match typescriptInterfaceComma /,/ contained nextgroup=typescriptInterfaceHeritage skipwhite skipnl
                            
                            "runtime syntax/basic/cluster.vim
                            "Block VariableStatement EmptyStatement ExpressionStatement IfStatement IterationStatement ContinueStatement BreakStatement ReturnStatement WithStatement LabelledStatement SwitchStatement ThrowStatement TryStatement DebuggerStatement
                            syntax cluster typescriptStatement
                              \ contains=typescriptBlock,typescriptVariable,
                              \ @typescriptTopExpression,typescriptAssign,
                              \ typescriptConditional,typescriptRepeat,typescriptBranch,
                              \ typescriptLabel,typescriptStatementKeyword,
                              \ typescriptFuncKeyword,
                              \ typescriptTry,typescriptExceptions,typescriptDebugger,
                              \ typescriptExport,typescriptInterfaceKeyword,typescriptEnum,
                              \ typescriptModule,typescriptAliasKeyword,typescriptImport
                            
                            syntax cluster typescriptPrimitive  contains=typescriptString,typescriptTemplate,typescriptRegexpString,typescriptNumber,typescriptBoolean,typescriptNull,typescriptArray
                            
                            syntax cluster typescriptEventTypes            contains=typescriptEventString,typescriptTemplate,typescriptNumber,typescriptBoolean,typescriptNull
                            
                            " top level expression: no arrow func
                            " also no func keyword. funcKeyword is contained in statement
                            " funcKeyword allows overloading (func without body)
                            " funcImpl requires body
                            syntax cluster typescriptTopExpression
                              \ contains=@typescriptPrimitive,
                              \ typescriptIdentifier,typescriptIdentifierName,
                              \ typescriptOperator,typescriptUnaryOp,
                              \ typescriptParenExp,typescriptRegexpString,
                              \ typescriptGlobal,typescriptAsyncFuncKeyword,
                              \ typescriptClassKeyword,typescriptTypeCast
                            
                            " no object literal, used in type cast and arrow func
                            " TODO: change func keyword to funcImpl
                            syntax cluster typescriptExpression
                              \ contains=@typescriptTopExpression,
                              \ typescriptArrowFuncDef,
                              \ typescriptFuncImpl
                            
                            syntax cluster typescriptValue
                              \ contains=@typescriptExpression,typescriptObjectLiteral
                            
                            syntax cluster typescriptEventExpression       contains=typescriptArrowFuncDef,typescriptParenExp,@typescriptValue,typescriptRegexpString,@typescriptEventTypes,typescriptOperator,typescriptGlobal,jsxRegion
                            
                            "runtime syntax/basic/function.vim
                            syntax keyword typescriptAsyncFuncKeyword      async
                              \ nextgroup=typescriptFuncKeyword,typescriptArrowFuncDef
                              \ skipwhite
                            
                            syntax keyword typescriptAsyncFuncKeyword      await
                              \ nextgroup=@typescriptValue
                              \ skipwhite
                            
                            syntax keyword typescriptFuncKeyword           function
                              \ nextgroup=typescriptAsyncFunc,typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            syntax match   typescriptAsyncFunc             contained /*/
                              \ nextgroup=typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            syntax match   typescriptFuncName              contained /\K\k*/
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite
                            
                            " destructuring ({ a: ee }) =>
                            syntax match   typescriptArrowFuncDef          contained /({\_[^}]*}\(:\_[^)]\)\?)\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            " matches `(a) =>` or `([a]) =>` or
                            " `(
                            "  a) =>`
                            syntax match   typescriptArrowFuncDef          contained /(\(\_s*[a-zA-Z\$_\[]\_[^)]*\)*)\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            syntax match   typescriptArrowFuncDef          contained /\K\k*\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
                            " TODO: optimize this pattern
                            syntax region   typescriptArrowFuncDef          contained start=/(\_[^)]*):/ end=/=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc,typescriptTypeAnnotation
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty keepend
                            
                            syntax match   typescriptArrowFunc             /=>/
                            syntax match   typescriptArrowFuncArg          contained /\K\k*/
                            syntax region  typescriptArrowFuncArg          contained start=/<\|(/ end=/\ze=>/ contains=@typescriptCallSignature
                            
                            syntax region typescriptReturnAnnotation contained start=/:/ end=/{/me=e-1 contains=@typescriptType nextgroup=typescriptBlock
                            
                            
                            syntax region typescriptFuncImpl contained start=/function/ end=/{/me=e-1
                              \ contains=typescriptFuncKeyword
                              \ nextgroup=typescriptBlock
                            
                            syntax cluster typescriptCallImpl contains=typescriptGenericImpl,typescriptParamImpl
                            syntax region typescriptGenericImpl matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptParamImpl
                              \ contained skipwhite
                            syntax region typescriptParamImpl matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptReturnAnnotation,typescriptBlock
                              \ contained skipwhite skipnl
                            
                            "runtime syntax/basic/decorator.vim
                            syntax match typescriptDecorator /@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>/
                              \ nextgroup=typescriptArgumentList
                              \ contains=@_semantic,typescriptDotNotation
                            
                            " Define the default highlighting.
                            hi def link typescriptReserved             Error
                            
                            hi def link typescriptEndColons            Exception
                            hi def link typescriptSymbols              Normal
                            hi def link typescriptBraces               Function
                            hi def link typescriptParens               Normal
                            hi def link typescriptComment              Comment
                            hi def link typescriptLineComment          Comment
                            hi def link typescriptDocComment           Comment
                            hi def link typescriptCommentTodo          Todo
                            hi def link typescriptRef                  Include
                            hi def link typescriptDocNotation          SpecialComment
                            hi def link typescriptDocTags              SpecialComment
                            hi def link typescriptDocNGParam           typescriptDocParam
                            hi def link typescriptDocParam             Function
                            hi def link typescriptDocNumParam          Function
                            hi def link typescriptDocEventRef          Function
                            hi def link typescriptDocNamedParamType    Type
                            hi def link typescriptDocParamName         Type
                            hi def link typescriptDocParamType         Type
                            hi def link typescriptString               String
                            hi def link typescriptSpecial              Special
                            hi def link typescriptStringLiteralType    String
                            hi def link typescriptStringMember         String
                            hi def link typescriptTemplate             String
                            hi def link typescriptEventString          String
                            hi def link typescriptASCII                Special
                            hi def link typescriptTemplateSB           Label
                            hi def link typescriptRegexpString         String
                            hi def link typescriptGlobal               Constant
                            hi def link typescriptPrototype            Type
                            hi def link typescriptConditional          Conditional
                            hi def link typescriptConditionalElse      Conditional
                            hi def link typescriptCase                 Conditional
                            hi def link typescriptDefault              typescriptCase
                            hi def link typescriptBranch               Conditional
                            hi def link typescriptIdentifier           Structure
                            hi def link typescriptVariable             Identifier
                            hi def link typescriptEnumKeyword          Identifier
                            hi def link typescriptRepeat               Repeat
                            hi def link typescriptForOperator          Repeat
                            hi def link typescriptStatementKeyword     Statement
                            hi def link typescriptMessage              Keyword
                            hi def link typescriptOperator             Identifier
                            hi def link typescriptKeywordOp            Identifier
                            hi def link typescriptCastKeyword          Special
                            hi def link typescriptType                 Type
                            hi def link typescriptNull                 Boolean
                            hi def link typescriptNumber               Number
                            hi def link typescriptExponent             Number
                            hi def link typescriptBoolean              Boolean
                            hi def link typescriptObjectLabel          typescriptLabel
                            hi def link typescriptLabel                Label
                            hi def link typescriptStringProperty       String
                            hi def link typescriptImport               Special
                            hi def link typescriptAmbientDeclaration   Special
                            hi def link typescriptExport               Special
                            hi def link typescriptModule               Special
                            hi def link typescriptTry                  Special
                            hi def link typescriptExceptions           Special
                            
                            hi def link typescriptMember              Function
                            hi def link typescriptMethodAccessor       Operator
                            
                            hi def link typescriptAsyncFuncKeyword     Keyword
                            hi def link typescriptAsyncFor             Keyword
                            hi def link typescriptFuncKeyword          Keyword
                            hi def link typescriptAsyncFunc            Keyword
                            hi def link typescriptArrowFunc            Type
                            hi def link typescriptFuncName             Function
                            hi def link typescriptFuncArg              PreProc
                            hi def link typescriptArrowFuncArg         PreProc
                            hi def link typescriptFuncComma            Operator
                            
                            hi def link typescriptClassKeyword         Keyword
                            hi def link typescriptClassExtends         Keyword
                            " hi def link typescriptClassName            Function
                            hi def link typescriptAbstract             Special
                            " hi def link typescriptClassHeritage        Function
                            " hi def link typescriptInterfaceHeritage    Function
                            hi def link typescriptClassStatic          StorageClass
                            hi def link typescriptReadonlyModifier     Keyword
                            hi def link typescriptInterfaceKeyword     Keyword
                            hi def link typescriptInterfaceExtends     Keyword
                            hi def link typescriptInterfaceName        Function
                            
                            hi def link shellbang                      Comment
                            
                            hi def link typescriptTypeParameter         Identifier
                            hi def link typescriptConstraint            Keyword
                            hi def link typescriptPredefinedType        Type
                            hi def link typescriptReadonlyArrayKeyword  Keyword
                            hi def link typescriptUnion                 Operator
                            hi def link typescriptFuncTypeArrow         Function
                            hi def link typescriptConstructorType       Function
                            hi def link typescriptTypeQuery             Keyword
                            hi def link typescriptAccessibilityModifier Keyword
                            hi def link typescriptOptionalMark          PreProc
                            hi def link typescriptFuncType              Special
                            hi def link typescriptMappedIn              Special
                            hi def link typescriptCall                  PreProc
                            hi def link typescriptParamImpl             PreProc
                            hi def link typescriptConstructSignature    Identifier
                            hi def link typescriptAliasDeclaration      Identifier
                            hi def link typescriptAliasKeyword          Keyword
                            hi def link typescriptUserDefinedType       Keyword
                            hi def link typescriptTypeReference         Identifier
                            hi def link typescriptConstructor           Keyword
                            hi def link typescriptDecorator             Special
                            
                            hi link typeScript             NONE
                            
                            let b:current_syntax = "typescript"
                            if main_syntax == 'typescript'
                              unlet main_syntax
                            endif
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ftplugin/typescript.vim
Sourced 3 times
Total time:   0.001299
 Self time:   0.001299

count  total (s)   self (s)
    3              0.000037 let b:prettier_ft_default_args = {
                              \ 'parser': 'typescript',
                              \ }
                            
    3              0.000015 augroup Prettier
    3              0.000883   autocmd!
    3              0.000025   if get(g:, 'prettier#autoformat')
    3              0.000044     autocmd BufWritePre *.ts,*.tsx call prettier#Autoformat()
    3              0.000004   endif
    3              0.000016 augroup end

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/after/ftplugin/typescript.vim
Sourced 3 times
Total time:   0.001224
 Self time:   0.000605

count  total (s)   self (s)
                            " Vim plugin file
                            " Language:    JavaScript Parameter Complete function
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2014/11/11
                            " Version:     0.1
                            " URL:         https://github.com/othree/jspc.vim
                            
    3   0.000899   0.000279 call jspc#init()
                            
                            

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/jspc.vim
Sourced 1 time
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
                            " Vim plugin file
                            " Language:    JavaScript Parameter Complete function
                            " Maintainer:  othree <othree@gmail.com>
                            " Last Change: 2014/11/10
                            " Version:     0.1
                            " URL:         https://github.com/othree/jspc.vim
                            
    1              0.000012 function! jspc#init()
                              let b:jspc_omnifunc = &omnifunc
                              let b:jspc_finding = 0
                              setlocal omnifunc=jspc#omni
                            endfunction
                            
    1              0.000006 function! jspc#filetype(filetype)
                              return substitute(a:filetype, "[^a-z].*", "", "")
                            endfunction
                            
    1              0.000006 function! jspc#omni(findstart, base)
                              if a:findstart == 1
                                let v = -1
                                let v = jspc#complete(a:findstart, a:base)
                                if v >= 0
                                  let b:jspc_finding = 1
                                elseif b:jspc_omnifunc != '' 
                                  execute "let v = " . b:jspc_omnifunc . "(a:findstart, a:base)"
                                endif
                                return v
                              else
                                let v = []
                                if b:jspc_finding == 1
                                  let b:jspc_finding = 0
                                  let v = jspc#complete(a:findstart, a:base)
                                elseif b:jspc_omnifunc != '' 
                                  execute "let v = " . b:jspc_omnifunc . "(a:findstart, a:base)"
                                endif
                                return v
                              endif
                            endfunc
                            
    1              0.000004 function! jspc#meet(context)
                              return a:context =~ "[\"']\k*$"
                            endfunction
                            
    1              0.000005 function! jspc#complete(findstart, base)
                              if a:findstart == 1
                                let line = getline('.')
                                let start = col('.') - 1
                                while start >= 0 && (line[start - 1] !~ "[\"']" || line[start - 2] == "\\")
                                  let start -= 1
                                endwhile
                                return start
                              else
                                let pattern = '\k\zs \+\|(\|:'
                                let line = getline('.')
                                let col = col('.')
                                let end = -1
                                let index = match(line, pattern, end)
                                let type = 'p' "parameter
                            
                                while index >= 0 && index < col
                                  let end = index
                                  let index = match(line, pattern, index + 1)
                                endwhile
                            
                                if end == -1
                                  return []
                                endif
                            
                                if line[end-1] =~ "[\"']"
                                  let end = end - 1
                                  let type = 'o' "options object
                                endif
                            
                                let candidates = line[0 : end-1]
                                let start = match(candidates, '\(\k\+\.\)\?[a-zA-Z0-9_\-$]\+$')
                                let end = strlen(candidates)
                                let method = candidates[start : end]
                            
                                execute "let res = jspc#". jspc#filetype(&filetype) ."#getlist(method)"
                                let expr = 'v:val =~? '."'^".escape(a:base, '\\/.*$^~[]').".*'"
                                let res = filter(deepcopy(res), expr)
                            
                                return res
                              endif
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/indent/typescript.vim
Sourced 3 times
Total time:   0.001191
 Self time:   0.001191

count  total (s)   self (s)
                            " Vim indent file
                            " Language: TypeScript
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    3              0.000021 if exists("b:did_indent")
                              finish
    3              0.000003 endif
    3              0.000012 let b:did_indent = 1
                            
    3              0.000025 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    3              0.000015 setlocal indentexpr=GetTypescriptIndent()
    3              0.000011 setlocal formatexpr=Fixedgq(v:lnum,v:count)
    3              0.000013 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            
                            " Only define the function once.
    3              0.000015 if exists("*GetTypescriptIndent")
    2              0.000002   finish
    1              0.000002 endif
                            
    1              0.000015 let s:cpo_save = &cpo
    1              0.000030 set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
    1              0.000013 let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'
                            
                            " Regex of syntax group names that are or delimit string or are comments.
    1              0.000006 let s:syng_strcom = 'string\|regex\|comment\c'
                            
                            " Regex of syntax group names that are strings.
    1              0.000004 let s:syng_string = 'regex\c'
                            
                            " Regex of syntax group names that are strings or documentation.
    1              0.000005 let s:syng_multiline = 'comment\c'
                            
                            " Regex of syntax group names that are line comment.
    1              0.000005 let s:syng_linecom = 'linecomment\c'
                            
                            " Expression used to check whether we should skip a match with searchpair().
    1              0.000011 let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"
                            
    1              0.000005 let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
                            
                            " Regex that defines continuation lines, not including (, {, or [.
    1              0.000010 let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=].*,\)' . s:line_term
                            
                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
    1              0.000006 let s:msl_regex = s:continuation_regex
                            
    1              0.000008 let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term
                            
                            " Regex that defines blocks.
    1              0.000009 let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
                            
    1              0.000004 let s:var_stmt = '^\s*var'
                            
    1              0.000005 let s:comma_first = '^\s*,'
    1              0.000005 let s:comma_last = ',\s*$'
                            
    1              0.000004 let s:ternary = '^\s\+[?:]'
    1              0.000005 let s:ternary_q = '^\s\+?[.?]\@!'
                            
                            " 2. Auxiliary Functions {{{1
                            " ======================
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
    1              0.000010 function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
    1              0.000006 function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction
                            
                            " Check if the character at lnum:col is inside a multi-line comment.
    1              0.000005 function s:IsInMultilineComment(lnum, col)
                              return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction
                            
                            " Check if the character at lnum:col is a line comment.
    1              0.000005 function s:IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
    1              0.000004 function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
    1              0.000005 function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
    1              0.000005 function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction
                            
                            " Find if the string is inside var statement (but not the first string)
    1              0.000004 function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')
                            
                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)
                            
                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif
                            
                                  " other js keywords, not a var
                                  return 0
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                            
                              " beginning of program, not a var
                              return 0
                            endfunction
                            
                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
    1              0.000004 function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))
                            
                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - shiftwidth()
                                else
                                  return indent(lvar) + shiftwidth()
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
    1              0.000005 function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction
                            
    1              0.000004 function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction
                            
    1              0.000005 function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif
                            
                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)
                            
                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif
                            
                              return a:ind
                            endfunction
                            
    1              0.000004 function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction
                            
    1              0.000004 function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction
                            
                            " 3. GetTypescriptIndent Function {{{1
                            " =========================
                            
    1              0.000004 function GetTypescriptIndent()
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)
                            
                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))
                            
                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif
                            
                            
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
                              endif
                            
                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
                              endif
                            
                              " If we are in a multi-line comment, cindent does the right thing.
                              if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif
                            
                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif
                            
                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
                              endif
                            
                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())
                            
                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + shiftwidth()
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif
                            
                              return ind
                            endfunction
                            
                            " }}}1
                            
    1              0.000024 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save
                            
    1              0.000005 function! Fixedgq(lnum, count)
                                let l:tw = &tw ? &tw : 80;
                            
                                let l:count = a:count
                                let l:first_char = indent(a:lnum) + 1
                            
                                if mode() == 'i' " gq was not pressed, but tw was set
                                    return 1
                                endif
                            
                                " This gq is only meant to do code with strings, not comments
                                if s:IsLineComment(a:lnum, l:first_char) || s:IsInMultilineComment(a:lnum, l:first_char)
                                    return 1
                                endif
                            
                                if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
                                    return 1
                                endif
                            
                                " Put all the lines on one line and do normal spliting after that
                                if l:count > 1
                                    while l:count > 1
                                        let l:count -= 1
                                        normal! J
                                    endwhile
                                endif
                            
                                let l:winview = winsaveview()
                            
                                call cursor(a:lnum, l:tw + 1)
                                let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
                                call cursor(a:lnum, l:tw + 1)
                                let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)
                            
                                " No need for special treatment, normal gq handles edgecases better
                                if breakpoint[1] == orig_breakpoint[1]
                                    call winrestview(l:winview)
                                    return 1
                                endif
                            
                                " Try breaking after string
                                if breakpoint[1] <= indent(a:lnum)
                                    call cursor(a:lnum, l:tw + 1)
                                    let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
                                endif
                            
                            
                                if breakpoint[1] != 0
                                    call feedkeys("r\<CR>")
                                else
                                    let l:count = l:count - 1
                                endif
                            
                                " run gq on new lines
                                if l:count == 1
                                    call feedkeys("gqq")
                                endif
                            
                                return 0
                            endfunction

SCRIPT  /usr/share/nvim/runtime/indent/typescript.vim
Sourced 3 times
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
                            " Vim indent file
                            " Language: TypeScript
                            " Maintainer: See https://github.com/HerringtonDarkholme/yats.vim
                            " Last Change: 2019 Jun 06
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    3              0.000022 if exists("b:did_indent")
    3              0.000006   finish
                            endif
                            let b:did_indent = 1
                            
                            setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
                            setlocal indentexpr=GetTypescriptIndent()
                            setlocal formatexpr=Fixedgq(v:lnum,v:count)
                            setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            
                            " Only define the function once.
                            if exists("*GetTypescriptIndent")
                              finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
                            let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'
                            
                            " Regex of syntax group names that are or delimit string or are comments.
                            let s:syng_strcom = 'string\|regex\|comment\c'
                            
                            " Regex of syntax group names that are strings.
                            let s:syng_string = 'regex\c'
                            
                            " Regex of syntax group names that are strings or documentation.
                            let s:syng_multiline = 'comment\c'
                            
                            " Regex of syntax group names that are line comment.
                            let s:syng_linecom = 'linecomment\c'
                            
                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"
                            
                            let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
                            
                            " Regex that defines continuation lines, not including (, {, or [.
                            let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=].*,\)' . s:line_term
                            
                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
                            let s:msl_regex = s:continuation_regex
                            
                            let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term
                            
                            " Regex that defines blocks.
                            let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
                            
                            let s:var_stmt = '^\s*var'
                            
                            let s:comma_first = '^\s*,'
                            let s:comma_last = ',\s*$'
                            
                            let s:ternary = '^\s\+[?|:]'
                            let s:ternary_q = '^\s\+?'
                            
                            " 2. Auxiliary Functions {{{1
                            " ======================
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
                            function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
                            function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction
                            
                            " Check if the character at lnum:col is inside a multi-line comment.
                            function s:IsInMultilineComment(lnum, col)
                              return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction
                            
                            " Check if the character at lnum:col is a line comment.
                            function s:IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
                            function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
                            function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
                            function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction
                            
                            " Find if the string is inside var statement (but not the first string)
                            function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')
                            
                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)
                            
                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif
                            
                                  " other js keywords, not a var
                                  return 0
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                            
                              " beginning of program, not a var
                              return 0
                            endfunction
                            
                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
                            function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))
                            
                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - shiftwidth()
                                else
                                  return indent(lvar) + shiftwidth()
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
                            function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction
                            
                            function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction
                            
                            function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif
                            
                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)
                            
                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif
                            
                              return a:ind
                            endfunction
                            
                            function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction
                            
                            function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction
                            
                            " 3. GetTypescriptIndent Function {{{1
                            " =========================
                            
                            function GetTypescriptIndent()
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)
                            
                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))
                            
                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif
                            
                            
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
                              endif
                            
                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
                              endif
                            
                              " If we are in a multi-line comment, cindent does the right thing.
                              if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif
                            
                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif
                            
                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
                              endif
                            
                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())
                            
                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + shiftwidth()
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif
                            
                              return ind
                            endfunction
                            
                            " }}}1
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            function! Fixedgq(lnum, count)
                                let l:tw = &tw ? &tw : 80;
                            
                                let l:count = a:count
                                let l:first_char = indent(a:lnum) + 1
                            
                                if mode() == 'i' " gq was not pressed, but tw was set
                                    return 1
                                endif
                            
                                " This gq is only meant to do code with strings, not comments
                                if s:IsLineComment(a:lnum, l:first_char) || s:IsInMultilineComment(a:lnum, l:first_char)
                                    return 1
                                endif
                            
                                if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
                                    return 1
                                endif
                            
                                " Put all the lines on one line and do normal spliting after that
                                if l:count > 1
                                    while l:count > 1
                                        let l:count -= 1
                                        normal J
                                    endwhile
                                endif
                            
                                let l:winview = winsaveview()
                            
                                call cursor(a:lnum, l:tw + 1)
                                let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
                                call cursor(a:lnum, l:tw + 1)
                                let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)
                            
                                " No need for special treatment, normal gq handles edgecases better
                                if breakpoint[1] == orig_breakpoint[1]
                                    call winrestview(l:winview)
                                    return 1
                                endif
                            
                                " Try breaking after string
                                if breakpoint[1] <= indent(a:lnum)
                                    call cursor(a:lnum, l:tw + 1)
                                    let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
                                endif
                            
                            
                                if breakpoint[1] != 0
                                    call feedkeys("r\<CR>")
                                else
                                    let l:count = l:count - 1
                                endif
                            
                                " run gq on new lines
                                if l:count == 1
                                    call feedkeys("gqq")
                                endif
                            
                                return 0
                            endfunction

SCRIPT  /home/ajs/config/nvim/repos/github.com/mhartington/nvim-typescript/autoload/nvim_typescript.vim
Sourced 1 time
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
    1              0.000005 function! nvim_typescript#DefaultKeyMap()
                              if get(g:, 'nvim_typescript#default_mappings', 1)
                                execute 'nnoremap <buffer> <silent> K'  ':TSDoc<CR>'
                                execute 'nnoremap <buffer> <silent> <leader>tdp'  ':TSDefPreview<CR>'
                                execute 'nnoremap <buffer> <silent> <c-]>'  ':TSTypeDef<CR>'
                              endif
                            endfunction

SCRIPT  /usr/share/nvim/runtime/autoload/provider/node.vim
Sourced 1 time
Total time:   1.683879
 Self time:   0.000157

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_node_provider')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_node_provider = 1
                            
    1              0.000004 function! s:is_minimum_version(version, min_major, min_minor) abort
                              if empty(a:version)
                                let nodejs_version = get(split(system(['node', '-v']), "\n"), 0, '')
                                if v:shell_error || nodejs_version[0] !=# 'v'
                                  return 0
                                endif
                              else
                                let nodejs_version = a:version
                              endif
                              " Remove surrounding junk.  Example: 'v4.12.0' => '4.12.0'
                              let nodejs_version = matchstr(nodejs_version, '\(\d\.\?\)\+')
                              " [major, minor, patch]
                              let v_list = split(nodejs_version, '\.')
                              return len(v_list) == 3
                                \ && ((str2nr(v_list[0]) > str2nr(a:min_major))
                                \     || (str2nr(v_list[0]) == str2nr(a:min_major)
                                \         && str2nr(v_list[1]) >= str2nr(a:min_minor)))
                            endfunction
                            
    1              0.000005 let s:NodeHandler = {
                            \ 'stdout_buffered': v:true,
                            \ 'result': ''
                            \ }
    1              0.000003 function! s:NodeHandler.on_exit(job_id, data, event) abort
                              let bin_dir = join(get(self, 'stdout', []), '')
                              let entry_point = bin_dir . self.entry_point
                              let self.result = filereadable(entry_point) ? entry_point : ''
                            endfunction
                            
                            " Support for --inspect-brk requires node 6.12+ or 7.6+ or 8+
                            " Return 1 if it is supported
                            " Return 0 otherwise
    1              0.000002 function! provider#node#can_inspect() abort
                              if !executable('node')
                                return 0
                              endif
                              let ver = get(split(system(['node', '-v']), "\n"), 0, '')
                              if v:shell_error || ver[0] !=# 'v'
                                return 0
                              endif
                              return (ver[1] ==# '6' && s:is_minimum_version(ver, 6, 12))
                                \ || s:is_minimum_version(ver, 7, 6)
                            endfunction
                            
    1              0.000002 function! provider#node#Detect() abort
                              if exists('g:node_host_prog')
                                return expand(g:node_host_prog)
                              endif
                              if !s:is_minimum_version(v:null, 6, 0)
                                return ''
                              endif
                            
                              let npm_opts = {}
                              if executable('npm')
                                let npm_opts = deepcopy(s:NodeHandler)
                                let npm_opts.entry_point = '/neovim/bin/cli.js'
                                let npm_opts.job_id = jobstart('npm --loglevel silent root -g', npm_opts)
                              endif
                            
                              let yarn_opts = {}
                              if executable('yarn')
                                let yarn_opts = deepcopy(s:NodeHandler)
                                let yarn_opts.entry_point = '/node_modules/neovim/bin/cli.js'
                                " `yarn global dir` is slow (> 250ms), try the default path first
                                " XXX: The following code is not portable
                                " https://github.com/yarnpkg/yarn/issues/2049#issuecomment-263183768
                                if has('unix')
                                  let yarn_default_path = $HOME . '/.config/yarn/global/' . yarn_opts.entry_point
                                  if filereadable(yarn_default_path)
                                    return yarn_default_path
                                  endif
                                endif
                                let yarn_opts.job_id = jobstart('yarn global dir', yarn_opts)
                              endif
                            
                              " npm returns the directory faster, so let's check that first
                              if !empty(npm_opts)
                                let result = jobwait([npm_opts.job_id])
                                if result[0] == 0 && npm_opts.result != ''
                                  return npm_opts.result
                                endif
                              endif
                            
                              if !empty(yarn_opts)
                                let result = jobwait([yarn_opts.job_id])
                                if result[0] == 0 && yarn_opts.result != ''
                                  return yarn_opts.result
                                endif
                              endif
                            
                              return ''
                            endfunction
                            
    1              0.000001 function! provider#node#Prog() abort
                              return s:prog
                            endfunction
                            
    1              0.000002 function! provider#node#Require(host) abort
                              if s:err != ''
                                echoerr s:err
                                return
                              endif
                            
                              let args = ['node']
                            
                              if !empty($NVIM_NODE_HOST_DEBUG) && provider#node#can_inspect()
                                call add(args, '--inspect-brk')
                              endif
                            
                              call add(args, provider#node#Prog())
                            
                              return provider#Poll(args, a:host.orig_name, '$NVIM_NODE_LOG_FILE')
                            endfunction
                            
    1              0.000002 function! provider#node#Call(method, args) abort
                              if s:err != ''
                                echoerr s:err
                                return
                              endif
                            
                              if !exists('s:host')
                                try
                                  let s:host = remote#host#Require('node')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call('rpcrequest', insert(insert(a:args, 'node_'.a:method), s:host))
                            endfunction
                            
                            
    1              0.000002 let s:err = ''
    1   1.683653   0.000015 let s:prog = provider#node#Detect()
    1              0.000012 let g:loaded_node_provider = empty(s:prog) ? 1 : 2
                            
    1              0.000002 if g:loaded_node_provider != 2
                              let s:err = 'Cannot find the "neovim" node package. Try :checkhealth'
    1              0.000002 endif
                            
    1   0.000106   0.000023 call remote#host#RegisterPlugin('node-provider', 'node', [])

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ale_linters/typescript/eslint.vim
Sourced 1 time
Total time:   0.000946
 Self time:   0.000394

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: eslint for JavaScript files
                            
    1   0.000620   0.000068 call ale#linter#Define('typescript', {
                            \   'name': 'eslint',
                            \   'executable': function('ale#handlers#eslint#GetExecutable'),
                            \   'command': function('ale#handlers#eslint#GetCommand'),
                            \   'callback': 'ale#handlers#eslint#HandleJSON',
                            \})

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ale_linters/typescript/standard.vim
Sourced 1 time
Total time:   0.001169
 Self time:   0.000321

count  total (s)   self (s)
                            " Author: Ahmed El Gabri <@ahmedelgabri>
                            " Description: standardjs for typescript files
                            
    1   0.000091   0.000048 call ale#Set('typescript_standard_executable', 'standard')
    1   0.000044   0.000022 call ale#Set('typescript_standard_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000032   0.000012 call ale#Set('typescript_standard_options', '')
                            
    1              0.000007 function! ale_linters#typescript#standard#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'typescript_standard', [
                                \   'node_modules/standardx/bin/cmd.js',
                                \   'node_modules/standard/bin/cmd.js',
                                \   'node_modules/.bin/standard',
                                \])
                            endfunction
                            
    1              0.000004 function! ale_linters#typescript#standard#GetCommand(buffer) abort
                                let l:executable = ale_linters#typescript#standard#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'typescript_standard_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \   . (!empty(l:options) ? ' ' . l:options : '')
                                \   . ' --stdin %s'
                            endfunction
                            
                            " standard uses eslint and the output format is the same
    1   0.000805   0.000041 call ale#linter#Define('typescript', {
                            \   'name': 'standard',
                            \   'executable': function('ale_linters#typescript#standard#GetExecutable'),
                            \   'command': function('ale_linters#typescript#standard#GetCommand'),
                            \   'callback': 'ale#handlers#eslint#Handle',
                            \})

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ale_linters/typescript/tslint.vim
Sourced 1 time
Total time:   0.001664
 Self time:   0.000492

count  total (s)   self (s)
                            " Author: Prashanth Chandra <https://github.com/prashcr>, Jonathan Clem <https://jclem.net>
                            " Description: tslint for TypeScript files
                            
    1   0.000654   0.000228 call ale#handlers#tslint#InitVariables()
                            
    1              0.000006 function! ale_linters#typescript#tslint#Handle(buffer, lines) abort
                                " Do not output any errors for empty files if the option is on.
                                if ale#Var(a:buffer, 'typescript_tslint_ignore_empty_files')
                                \&& getbufline(a:buffer, 1, '$') == ['']
                                    return []
                                endif
                            
                                let l:dir = expand('#' . a:buffer . ':p:h')
                                let l:output = []
                            
                                for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
                                    if get(l:error, 'ruleName', '') is# 'no-implicit-dependencies'
                                        continue
                                    endif
                            
                                    let l:item = {
                                    \   'type': (get(l:error, 'ruleSeverity', '') is# 'WARNING' ? 'W' : 'E'),
                                    \   'text': l:error.failure,
                                    \   'lnum': l:error.startPosition.line + 1,
                                    \   'col': l:error.startPosition.character + 1,
                                    \   'end_lnum': l:error.endPosition.line + 1,
                                    \   'end_col': l:error.endPosition.character + 1,
                                    \}
                            
                                    let l:filename = ale#path#GetAbsPath(l:dir, l:error.name)
                            
                                    " Assume temporary files are this file.
                                    if !ale#path#IsTempName(l:filename)
                                        let l:item.filename = l:filename
                                    endif
                            
                                    if has_key(l:error, 'ruleName')
                                        let l:item.code = l:error.ruleName
                                    endif
                            
                                    call add(l:output, l:item)
                                endfor
                            
                                return l:output
                            endfunction
                            
    1              0.000006 function! ale_linters#typescript#tslint#GetCommand(buffer) abort
                                let l:tslint_config_path = ale#path#ResolveLocalPath(
                                \   a:buffer,
                                \   'tslint.json',
                                \   ale#Var(a:buffer, 'typescript_tslint_config_path')
                                \)
                                let l:tslint_config_option = !empty(l:tslint_config_path)
                                \   ? ' -c ' . ale#Escape(l:tslint_config_path)
                                \   : ''
                            
                                let l:tslint_rules_dir = ale#Var(a:buffer, 'typescript_tslint_rules_dir')
                                let l:tslint_rules_option = !empty(l:tslint_rules_dir)
                                \  ? ' -r ' . ale#Escape(l:tslint_rules_dir)
                                \  : ''
                            
                                return ale#path#BufferCdString(a:buffer)
                                \   . ale#Escape(ale#handlers#tslint#GetExecutable(a:buffer))
                                \   . ' --format json'
                                \   . l:tslint_config_option
                                \   . l:tslint_rules_option
                                \   . ' %t'
                            endfunction
                            
    1   0.000789   0.000043 call ale#linter#Define('typescript', {
                            \   'name': 'tslint',
                            \   'executable': function('ale#handlers#tslint#GetExecutable'),
                            \   'command': function('ale_linters#typescript#tslint#GetCommand'),
                            \   'callback': 'ale_linters#typescript#tslint#Handle',
                            \})

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/tslint.vim
Sourced 1 time
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
    1              0.000014 function! ale#handlers#tslint#InitVariables() abort
                                call ale#Set('typescript_tslint_executable', 'tslint')
                                call ale#Set('typescript_tslint_config_path', '')
                                call ale#Set('typescript_tslint_rules_dir', '')
                                call ale#Set('typescript_tslint_use_global', get(g:, 'ale_use_global_executables', 0))
                                call ale#Set('typescript_tslint_ignore_empty_files', 0)
                            endfunction
                            
    1              0.000005 function! ale#handlers#tslint#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'typescript_tslint', [
                                \   'node_modules/.bin/tslint',
                                \])
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ale_linters/typescript/tsserver.vim
Sourced 1 time
Total time:   0.001078
 Self time:   0.000253

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: tsserver integration for ALE
                            
    1   0.000047   0.000022 call ale#Set('typescript_tsserver_executable', 'tsserver')
    1   0.000036   0.000014 call ale#Set('typescript_tsserver_config_path', '')
    1   0.000034   0.000017 call ale#Set('typescript_tsserver_use_global', get(g:, 'ale_use_global_executables', 0))
                            
    1   0.000811   0.000051 call ale#linter#Define('typescript', {
                            \   'name': 'tsserver',
                            \   'lsp': 'tsserver',
                            \   'executable': {b -> ale#node#FindExecutable(b, 'typescript_tsserver', [
                            \       'node_modules/.bin/tsserver',
                            \   ])},
                            \   'command': '%e',
                            \   'project_root': function('ale#handlers#tsserver#GetProjectRoot'),
                            \   'language': '',
                            \})

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ale_linters/typescript/typecheck.vim
Sourced 1 time
Total time:   0.000951
 Self time:   0.000200

count  total (s)   self (s)
                            " Author: Prashanth Chandra https://github.com/prashcr, Aleh Kashnikau https://github.com/mkusher
                            " Description: type checker for TypeScript files
                            
    1              0.000008 function! ale_linters#typescript#typecheck#Handle(buffer, lines) abort
                                " Matches patterns like the following:
                                "
                                " hello.ts[7, 41]: Property 'a' does not exist on type 'A'
                                " hello.ts[16, 7]: Type 'A' is not assignable to type 'B'
                                "
                                let l:pattern = '.\+\.ts\[\(\d\+\), \(\d\+\)\]: \(.\+\)'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    let l:line = l:match[1] + 0
                                    let l:column = l:match[2] + 0
                                    let l:text = l:match[3]
                            
                                    call add(l:output, {
                                    \   'lnum': l:line,
                                    \   'col': l:column,
                                    \   'text': l:text,
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000785   0.000034 call ale#linter#Define('typescript', {
                            \   'name': 'typecheck',
                            \   'executable': 'typecheck',
                            \   'command': 'typecheck %s',
                            \   'callback': 'ale_linters#typescript#typecheck#Handle',
                            \})

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/ale_linters/typescript/xo.vim
Sourced 1 time
Total time:   0.001024
 Self time:   0.000247

count  total (s)   self (s)
    1   0.000045   0.000021 call ale#Set('typescript_xo_executable', 'xo')
    1   0.000034   0.000016 call ale#Set('typescript_xo_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000027   0.000011 call ale#Set('typescript_xo_options', '')
                            
    1              0.000006 function! ale_linters#typescript#xo#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'typescript_xo', [
                                \   'node_modules/.bin/xo',
                                \])
                            endfunction
                            
    1              0.000004 function! ale_linters#typescript#xo#GetCommand(buffer) abort
                                return ale#Escape(ale_linters#typescript#xo#GetExecutable(a:buffer))
                                \   . ale#Pad(ale#Var(a:buffer, 'typescript_xo_options'))
                                \   . ' --reporter json --stdin --stdin-filename %s'
                            endfunction
                            
                            " xo uses eslint and the output format is the same
    1   0.000756   0.000037 call ale#linter#Define('typescript', {
                            \   'name': 'xo',
                            \   'executable': function('ale_linters#typescript#xo#GetExecutable'),
                            \   'command': function('ale_linters#typescript#xo#GetCommand'),
                            \   'callback': 'ale#handlers#eslint#HandleJSON',
                            \})

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim
Sourced 1 time
Total time:   0.000661
 Self time:   0.000566

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for working with eslint, for checking or fixing files.
                            
    1              0.000025 let s:sep = has('win32') ? '\' : '/'
                            
    1   0.000050   0.000022 call ale#Set('javascript_eslint_options', '')
    1   0.000032   0.000014 call ale#Set('javascript_eslint_executable', 'eslint')
    1   0.000031   0.000015 call ale#Set('javascript_eslint_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000030   0.000012 call ale#Set('javascript_eslint_suppress_eslintignore', 0)
    1   0.000027   0.000012 call ale#Set('javascript_eslint_suppress_missing_config', 0)
                            
    1              0.000007 function! ale#handlers#eslint#FindConfig(buffer) abort
                                for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    for l:basename in [
                                    \   '.eslintrc.js',
                                    \   '.eslintrc.yaml',
                                    \   '.eslintrc.yml',
                                    \   '.eslintrc.json',
                                    \   '.eslintrc',
                                    \]
                                        let l:config = ale#path#Simplify(join([l:path, l:basename], s:sep))
                            
                                        if filereadable(l:config)
                                            return l:config
                                        endif
                                    endfor
                                endfor
                            
                                return ale#path#FindNearestFile(a:buffer, 'package.json')
                            endfunction
                            
    1              0.000004 function! ale#handlers#eslint#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [
                                \   'node_modules/.bin/eslint_d',
                                \   'node_modules/eslint/bin/eslint.js',
                                \   'node_modules/.bin/eslint',
                                \])
                            endfunction
                            
    1              0.000004 function! ale#handlers#eslint#GetCommand(buffer) abort
                                let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
                                let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
                                " ESLint 6 loads plugins/configs/parsers from the project root
                                " By default, the project root is simply the CWD of the running process.
                                " https://github.com/eslint/rfcs/blob/master/designs/2018-simplified-package-loading/README.md
                                " https://github.com/dense-analysis/ale/issues/2787
                                " Identify project root from presence of node_modules dir.
                                " Note: If node_modules not present yet, can't load local deps anyway.
                                let l:modules_dir = ale#path#FindNearestDirectory(a:buffer, 'node_modules')
                                let l:project_dir = !empty(l:modules_dir) ? fnamemodify(l:modules_dir, ':h:h') : ''
                                let l:cd_command = !empty(l:project_dir) ? ale#path#CdString(l:project_dir) : ''
                            
                                return l:cd_command
                                \   . ale#node#Executable(a:buffer, l:executable)
                                \   . (!empty(l:options) ? ' ' . l:options : '')
                                \   . ' -f json --stdin --stdin-filename %s'
                            endfunction
                            
    1              0.000007 function! s:AddHintsForTypeScriptParsingErrors(output) abort
                                for l:item in a:output
                                    let l:item.text = substitute(
                                    \   l:item.text,
                                    \   '^\(Parsing error\)',
                                    \   '\1 (You may need configure typescript-eslint-parser)',
                                    \   '',
                                    \)
                                endfor
                            endfunction
                            
    1              0.000005 function! s:CheckForBadConfig(buffer, lines) abort
                                let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'
                                \   . '|^Cannot read config file'
                                \   . '|^.*Configuration for rule .* is invalid'
                                \   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
                                for l:line in a:lines[:10]
                                    let l:match = matchlist(l:line, l:config_error_pattern)
                            
                                    if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')
                                        \&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
    1              0.000004 function! s:parseJSON(buffer, lines) abort
                                let l:parsed = []
                            
                                for l:line in a:lines
                                    try
                                        let l:parsed = extend(l:parsed, json_decode(l:line))
                                    catch
                                    endtry
                                endfor
                            
                                if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
                                endif
                            
                                let l:errors = l:parsed[0]['messages']
                            
                                if empty(l:errors)
                                    return []
                                endif
                            
                                let l:output = []
                            
                                for l:error in l:errors
                                    let l:obj = ({
                                    \   'lnum': get(l:error, 'line', 0),
                                    \   'text': get(l:error, 'message', ''),
                                    \   'type': 'E',
                                    \})
                            
                                    if get(l:error, 'severity', 0) is# 1
                                        let l:obj.type = 'W'
                                    endif
                            
                                    if has_key(l:error, 'ruleId')
                                        let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
                                        if !empty(l:code)
                                            let l:obj.code = l:code
                                        endif
                                    endif
                            
                                    if has_key(l:error, 'column')
                                        let l:obj.col = l:error['column']
                                    endif
                            
                                    if has_key(l:error, 'endColumn')
                                        let l:obj.end_col = l:error['endColumn'] - 1
                                    endif
                            
                                    if has_key(l:error, 'endLine')
                                        let l:obj.end_lnum = l:error['endLine']
                                    endif
                            
                                    call add(l:output, l:obj)
                                endfor
                            
                                return l:output
                            endfunction
                            
    1              0.000015 let s:col_end_patterns = [
                            \   '\vParsing error: Unexpected token (.+) ?',
                            \   '\v''(.+)'' is not defined.',
                            \   '\v%(Unexpected|Redundant use of) [''`](.+)[''`]',
                            \   '\vUnexpected (console) statement',
                            \]
                            
    1              0.000004 function! s:parseLines(buffer, lines) abort
                                " Matches patterns line the following:
                                "
                                " /path/to/some-filename.js:47:14: Missing trailing comma. [Warning/comma-dangle]
                                " /path/to/some-filename.js:56:41: Missing semicolon. [Error/semi]
                                let l:pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\) \[\(.\+\)\]$'
                                " This second pattern matches lines like the following:
                                "
                                " /path/to/some-filename.js:13:3: Parsing error: Unexpected token
                                let l:parsing_pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\)$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, [l:pattern, l:parsing_pattern])
                                    let l:text = l:match[3]
                            
                                    let l:obj = {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'text': l:text,
                                    \   'type': 'E',
                                    \}
                            
                                    " Take the error type from the output if available.
                                    let l:split_code = split(l:match[4], '/')
                            
                                    if get(l:split_code, 0, '') is# 'Warning'
                                        let l:obj.type = 'W'
                                    endif
                            
                                    " The code can be something like 'Error/foo/bar', or just 'Error'
                                    if !empty(get(l:split_code, 1))
                                        let l:obj.code = join(l:split_code[1:], '/')
                                    endif
                            
                                    for l:col_match in ale#util#GetMatches(l:text, s:col_end_patterns)
                                        let l:obj.end_col = l:obj.col + len(l:col_match[1]) - 1
                                    endfor
                            
                                    call add(l:output, l:obj)
                                endfor
                            
                                return l:output
                            endfunction
                            
    1              0.000005 function! s:FilterResult(buffer, obj) abort
                                if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                    if a:obj.text =~# '^File ignored'
                                        return 0
                                    endif
                                endif
                            
                                if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'
                                \&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    return 0
                                endif
                            
                                return 1
                            endfunction
                            
    1              0.000004 function! s:HandleESLintOutput(buffer, lines, type) abort
                                if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{
                                    \   'lnum': 1,
                                    \   'text': 'eslint configuration error (type :ALEDetail for more information)',
                                    \   'detail': join(a:lines, "\n"),
                                    \}]
                                endif
                            
                                if a:lines == ['Could not connect']
                                    return [{
                                    \   'lnum': 1,
                                    \   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',
                                    \}]
                                endif
                            
                                if a:type is# 'json'
                                    let l:output = s:parseJSON(a:buffer, a:lines)
                                else
                                    let l:output = s:parseLines(a:buffer, a:lines)
                                endif
                            
                                call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
                                if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
                                    call s:AddHintsForTypeScriptParsingErrors(l:output)
                                endif
                            
                                return l:output
                            endfunction
                            
    1              0.000004 function! ale#handlers#eslint#HandleJSON(buffer, lines) abort
                                return s:HandleESLintOutput(a:buffer, a:lines, 'json')
                            endfunction
                            
    1              0.000004 function! ale#handlers#eslint#Handle(buffer, lines) abort
                                return s:HandleESLintOutput(a:buffer, a:lines, 'lines')
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim
Sourced 1 time
Total time:   0.004247
 Self time:   0.004153

count  total (s)   self (s)
                            "===============================================================================
                            " Initialization
                            "===============================================================================
                            
                            " Tweak key settings. If the key is set using 'expr-quote' (h: expr-quote), then
                            " there's nothing that we need to do. If it's set using raw strings, then we
                            " need to convert it.  We need to resort to such voodoo exec magic here to get
                            " it to work the way we like. '<C-n>' is converted to '\<C-n>' by the end and
                            " the global vars are replaced by their new value. This is ok since the mapping
                            " using '<C-n>' should already have completed in the plugin file.
    1              0.000048 for s:key in [ 'g:multi_cursor_next_key',
                                       \ 'g:multi_cursor_prev_key',
                                       \ 'g:multi_cursor_skip_key',
    4              0.000015            \ 'g:multi_cursor_quit_key' ]
    4              0.000048   if exists(s:key)
                                " Translate raw strings like "<C-n>" into key code like "\<C-n>"
    4              0.000048     exec 'let s:temp = '.s:key
    4              0.000066     if s:temp =~ '^<.*>$'
    4              0.000056       exec 'let '.s:key.' = "\'.s:temp.'"'
    4              0.000007     endif
                              else
                                " If the user didn't define it, initialize it to an empty string so the
                                " logic later don't break
                                exec 'let '.s:key.' = ""'
    4              0.000006   endif
    5              0.000013 endfor
    1              0.000011 unlet! s:key s:temp
                            
                            " These keys will not be replicated at every cursor location. Make sure that
                            " this assignment happens AFTER the key tweak setting above
    1              0.000026 let s:special_keys = {
                                  \ 'v': [ g:multi_cursor_next_key, g:multi_cursor_prev_key, g:multi_cursor_skip_key ],
                                  \ 'n': [ g:multi_cursor_next_key ],
                                  \ }
                            
                            " The highlight group we use for all the cursors
    1              0.000006 let s:hi_group_cursor = 'multiple_cursors_cursor'
                            
                            " The highlight group we use for all the visual selection
    1              0.000008 let s:hi_group_visual = 'multiple_cursors_visual'
                            
                            " Used for preventing multiple calls on before function
    1              0.000007 let s:before_function_called = 0
                            
                            " Used for searching whole words (search pattern is wrapped with \< and \>)
                            " Keep old behaviour by default (act like g*)
    1              0.000005 let s:use_word_boundary = 1
                            
                            " Set up highlighting
    1              0.000101 if !hlexists(s:hi_group_cursor)
    1              0.000082   exec "highlight ".s:hi_group_cursor." term=reverse cterm=reverse gui=reverse"
    1              0.000006 endif
    1              0.000040 if !hlexists(s:hi_group_visual)
    1              0.000056   exec "highlight link ".s:hi_group_visual." Visual"
    1              0.000003 endif
                            
                            " Temporary buffer that is used for individual paste buffer save/restore
                            " operations
    1              0.000010 let s:paste_buffer_temporary_text = ''
    1              0.000006 let s:paste_buffer_temporary_type = ''
                            
                            "===============================================================================
                            " Internal Mappings
                            "===============================================================================
                            
    1              0.000163 inoremap <silent> <Plug>(multiple-cursors-input) <C-o>:call <SID>process_user_input()<CR>
    1              0.000072 nnoremap <silent> <Plug>(multiple-cursors-input) :call <SID>process_user_input()<CR>
    1              0.000049 xnoremap <silent> <Plug>(multiple-cursors-input) :<C-u>call <SID>process_user_input()<CR>
                            
    1              0.000047 inoremap <silent> <Plug>(multiple-cursors-apply) <C-o>:call <SID>apply_user_input_next('i')<CR>
    1              0.000062 nnoremap <silent> <Plug>(multiple-cursors-apply) :call <SID>apply_user_input_next('n')<CR>
    1              0.000041 xnoremap <silent> <Plug>(multiple-cursors-apply) :<C-u>call <SID>apply_user_input_next('v')<CR>
                            
    1              0.000045 inoremap <silent> <Plug>(multiple-cursors-detect) <C-o>:call <SID>detect_bad_input()<CR>
    1              0.000036 nnoremap <silent> <Plug>(multiple-cursors-detect) :call <SID>detect_bad_input()<CR>
    1              0.000035 xnoremap <silent> <Plug>(multiple-cursors-detect) :<C-u>call <SID>detect_bad_input()<CR>
                            
    1              0.000032 inoremap <silent> <Plug>(multiple-cursors-wait) <C-o>:call <SID>wait_for_user_input('')<CR>
    1              0.000035 nnoremap <silent> <Plug>(multiple-cursors-wait) :call <SID>wait_for_user_input('')<CR>
    1              0.000033 xnoremap <silent> <Plug>(multiple-cursors-wait) :<C-u>call <SID>wait_for_user_input('')<CR>
                            
                            " Note that although these mappings are seemingly triggerd from Visual mode,
                            " they are in fact triggered from Normal mode. We quit visual mode to allow the
                            " virtual highlighting to take over
    1              0.000045 nnoremap <silent> <Plug>(multiple-cursors-prev) :<C-u>call multiple_cursors#prev()<CR>
    1              0.000042 nnoremap <silent> <Plug>(multiple-cursors-skip) :<C-u>call multiple_cursors#skip()<CR>
    1              0.000116 nnoremap <silent> <Plug>(multiple-cursors-new) :<C-u>call multiple_cursors#new('v', 0)<CR>
    1              0.000037 nnoremap <silent> <Plug>(multiple-cursors-new-word) :<C-u>call multiple_cursors#new('v', 1)<CR>
                            
                            "===============================================================================
                            " Public Functions
                            "===============================================================================
                            
                            " Print some debugging info
    1              0.000011 function! multiple_cursors#debug()
                              call s:cm.debug()
                            endfunction
                            
    1              0.000005 function! multiple_cursors#get_latency_debug_file()
                              return s:latency_debug_file
                            endfunction
                            
                            
    1              0.000006 function! s:fire_pre_triggers()
                              if !s:before_function_called
                                silent doautocmd User MultipleCursorsPre
                                if exists('*Multiple_cursors_before')
                                  exe "call Multiple_cursors_before()"
                                endif
                                let s:before_function_called = 1
                              endif
                            endfunction
                            
                            " Creates a new cursor. Different logic applies depending on the mode the user
                            " is in and the current state of the buffer.
                            " 1. In normal mode, a new cursor is created at the end of the word under Vim's
                            " normal cursor
                            " 2. In visual mode, if the visual selection covers more than one line, a new
                            " cursor is created at the beginning of each line
                            " 3. In visual mode, if the visual selection covers a single line, a new cursor
                            " is created at the end of the visual selection. Another cursor will be
                            " attempted to be created at the next occurrence of the visual selection
    1              0.000007 function! multiple_cursors#new(mode, word_boundary)
                              " Call before function if exists only once until it is canceled (<Esc>)
                              call s:fire_pre_triggers()
                              let s:use_word_boundary = a:word_boundary
                              if a:mode ==# 'n'
                                " Reset all existing cursors, don't restore view and setting
                                call s:cm.reset(0, 0)
                            
                                " Select the word under cursor to set the '< and '> marks
                                exec "normal! viw"
                                call s:exit_visual_mode()
                            
                                " Add cursor with the current visual selection
                                call s:cm.add(s:pos("'>"), s:region("'<", "'>"))
                                call s:wait_for_user_input('v')
                              elseif a:mode ==# 'v'
                                " If the visual area covers the same line, then do a search for next
                                " occurrence
                                let start = line("'<")
                                let finish = line("'>")
                                if start != finish
                                  call s:cm.reset(0, 0)
                                  let col = col("'<")
                                  for line in range(line("'<"), line("'>"))
                                    let pos = [line, col]
                                    call s:cm.add(pos)
                                  endfor
                                  " Start in normal mode
                                  call s:wait_for_user_input('n')
                                else
                                  " Came directly from visual mode
                                  if s:cm.is_empty()
                                    call s:cm.reset(0, 0)
                            
                                    if visualmode() ==# 'V'
                                      let left = [line('.'), 1]
                                      let right = [line('.'), col('$')-1]
                                      if right[1] == 0 " empty line
                                        return
                                      endif
                                      call s:cm.add(right, [left, right])
                                    else
                                      call s:cm.add(s:pos("'>"), s:region("'<", "'>"))
                                    endif
                                  endif
                                  let content = s:get_text(s:region("'<", "'>"))
                                  let next = s:find_next(content)
                                  if s:cm.add(next[1], next)
                                    call s:update_visual_markers(next)
                                  else
                                    call cursor(s:cm.get_current().position)
                                    echohl WarningMsg | echo 'No more matches' | echohl None
                                  endif
                                  call s:wait_for_user_input('v')
                                endif
                              endif
                            endfunction
                            
                            " Quit out of multicursor mode, fixes #27.
    1              0.000004 function! multiple_cursors#quit()
                              call s:exit()
                            endfunction
                            
                            " Delete the current cursor. If there's no more cursors, stop the loop
    1              0.000005 function! multiple_cursors#prev()
                              call s:cm.delete_current()
                              if !s:cm.is_empty()
                                call s:update_visual_markers(s:cm.get_current().visual)
                                call cursor(s:cm.get_current().position)
                                call s:wait_for_user_input('v')
                              endif
                            endfunction
                            
                            " Skip the current cursor and move to the next cursor
    1              0.000004 function! multiple_cursors#skip()
                              call s:cm.delete_current()
                              let content = s:get_text(s:region("'<", "'>"))
                              let next = s:find_next(content)
                              call s:cm.add(next[1], next)
                              call s:update_visual_markers(next)
                              call s:wait_for_user_input('v')
                            endfunction
                            
                            " Search for pattern between the start and end line number. For each match, add
                            " a virtual cursor at the end and start multicursor mode
                            " This function is called from a command. User commands in Vim do not support
                            " passing in column ranges. If the user selects a block of text in visual mode,
                            " but not visual line mode, we only want to match patterns within the actual
                            " visual selection. We get around this by checking the last visual selection and
                            " see if its start and end lines match the input. If so, we assume that the user
                            " did a normal visual selection and we use the '< and '> marks to define the
                            " region instead of start and end from the method parameter.
    1              0.000007 function! multiple_cursors#find(start, end, pattern)
                              let s:cm.saved_winview = winsaveview()
                              let s:cm.start_from_find = 1
                              if visualmode() ==# 'v' && a:start == line("'<") && a:end == line("'>")
                                let pos1 = s:pos("'<")
                                let pos2 = s:pos("'>")
                              else
                                let pos1 = [a:start, 1]
                                let pos2 = [a:end, col([a:end, '$'])]
                              endif
                              call cursor(pos1)
                              let first = 1
                              while 1
                                if first
                                  " Set `virtualedit` to 'onemore' for the first search to consistently
                                  " match patterns like '$'
                                  let saved_virtualedit = &virtualedit
                                  let &virtualedit = "onemore"
                                  " First search starts from the current position
                                  let match = search(a:pattern, 'cW')
                                else
                                  let match = search(a:pattern, 'W')
                                endif
                                if !match
                                  break
                                endif
                                let left = s:pos('.')
                                " Perform an intermediate backward search to correctly match patterns like
                                " '^' and '$'
                                let match = search(a:pattern, 'bceW')
                                let right = s:pos('.')
                                " Reset the cursor and perform a normal search if the intermediate search
                                " wasn't successful
                                if !match || s:compare_pos(right, left) != 0
                                  call cursor(left)
                                  call search(a:pattern, 'ceW')
                                  let right = s:pos('.')
                                endif
                                if first
                                  let &virtualedit = saved_virtualedit
                                  let first = 0
                                endif
                                if s:compare_pos(right, pos2) > 0
                                  " Position the cursor at the end of the previous match so it'll be on a
                                  " virtual cursor when multicursor mode is started. The `winrestview()`
                                  " call below 'undoes' unnecessary repositionings
                                  call search(a:pattern, 'be')
                                  break
                                endif
                                call s:cm.add(right, [left, right])
                                " Redraw here forces the cursor movement to be updated. This prevents the
                                " jerky behavior when doing any action once the cursors are added. But it
                                " also slows down adding the cursors dramatically. We need to a better
                                " solution here
                                " redraw
                              endwhile
                              if s:cm.is_empty()
                                call winrestview(s:cm.saved_winview)
                                echohl ErrorMsg | echo 'No match found' | echohl None
                                return
                              else
                                echohl Normal | echo 'Added '.s:cm.size().' cursor'.(s:cm.size()>1?'s':'') | echohl None
                            
                                " If we've created any cursors, we need to call the before function, end
                                " function will be called via normal routes
                                call s:fire_pre_triggers()
                            
                                call s:wait_for_user_input('v')
                              endif
                            endfunction
                            
                            " apply multiple_cursors#find() on the whole buffer
    1              0.000006 function! multiple_cursors#select_all(mode, word_boundary)
                              if a:mode == 'v'
                                let a_save = @a
                                normal! gv"ay
                                let pattern = @a
                                let @a = a_save
                              elseif a:mode == 'n'
                                let pattern = expand('<cword>')
                              endif
                              if a:word_boundary == 1
                                let pattern = '\<'.pattern.'\>'
                              endif
                              call multiple_cursors#find(1, line('$'), pattern)
                            endfunction
                            
                            "===============================================================================
                            " Cursor class
                            "===============================================================================
    1              0.000008 let s:Cursor = {}
                            
                            " Create a new cursor. Highlight it and save the current line length
    1              0.000007 function! s:Cursor.new(position)
                              let obj = copy(self)
                              let obj.position = copy(a:position)
                              let obj.visual = []
                              let obj.saved_visual = []
                              " Stores text that was yanked after any commands in Normal or Visual mode
                              let obj.paste_buffer_text = getreg('"')
                              let obj.paste_buffer_type = getregtype('"')
                              let obj.cursor_hi_id = s:highlight_cursor(a:position)
                              let obj.visual_hi_id = 0
                              let obj.line_length = col([a:position[0], '$'])
                              if has('folding')
                                silent! execute a:position[0] . "foldopen!"
                              endif
                              return obj
                            endfunction
                            
                            " Return the line the cursor is on
    1              0.000004 function! s:Cursor.line() dict
                              return self.position[0]
                            endfunction
                            
                            " Return the column the cursor is on
    1              0.000003 function! s:Cursor.column() dict
                              return self.position[1]
                            endfunction
                            
                            " Move the cursor location by the number of lines and columns specified in the
                            " input. The input can be negative.
    1              0.000004 function! s:Cursor.move(line, column) dict
                              let self.position[0] += a:line
                              let self.position[1] += a:column
                              if !empty(self.visual)
                                let self.visual[0][0] += a:line
                                let self.visual[0][1] += a:column
                                let self.visual[1][0] += a:line
                                let self.visual[1][1] += a:column
                              endif
                              call self.update_highlight()
                            endfunction
                            
                            " Update the current position of the cursor
    1              0.000004 function! s:Cursor.update_position(pos) dict
                              let self.position[0] = a:pos[0]
                              let self.position[1] = a:pos[1]
                              call self.update_highlight()
                            endfunction
                            
                            " Reapply the highlight on the cursor
    1              0.000003 function! s:Cursor.update_highlight() dict
                              call s:cm.remove_highlight(self.cursor_hi_id)
                              let self.cursor_hi_id = s:highlight_cursor(self.position)
                            endfunction
                            
                            " Refresh the length of the line the cursor is on. This could change from
                            " underneath
    1              0.000003 function! s:Cursor.update_line_length() dict
                              let self.line_length = col([self.line(), '$'])
                            endfunction
                            
                            " Update the visual selection and its highlight
    1              0.000004 function! s:Cursor.update_visual_selection(region) dict
                              let self.visual = deepcopy(a:region)
                              call s:cm.remove_highlight(self.visual_hi_id)
                              let self.visual_hi_id = s:highlight_region(a:region)
                            endfunction
                            
                            " Remove the visual selection and its highlight
    1              0.000003 function! s:Cursor.remove_visual_selection() dict
                              let self.saved_visual = deepcopy(self.visual)
                              let self.visual = []
                              " TODO(terryma): Move functionality into separate class
                              call s:cm.remove_highlight(self.visual_hi_id)
                              let self.visual_hi_id = 0
                            endfunction
                            
                            " Restore unnamed register from paste buffer
    1              0.000004 function! s:Cursor.restore_unnamed_register() dict
                              call setreg('"', self.paste_buffer_text, self.paste_buffer_type)
                            endfunction
                            
                            " Save contents of the unnamed register into paste buffer
    1              0.000003 function! s:Cursor.save_unnamed_register() dict
                              let self.paste_buffer_text = getreg('"')
                              let self.paste_buffer_type = getregtype('"')
                            endfunction
                            
                            "===============================================================================
                            " CursorManager class
                            "===============================================================================
    1              0.000006 let s:CursorManager = {}
                            
                            " Constructor
    1              0.000003 function! s:CursorManager.new()
                              let obj = copy(self)
                              " List of Cursors we're managing
                              let obj.cursors = []
                              " Current index into the s:cursors array
                              let obj.current_index = -1
                              " This marks the starting cursor index into the s:cursors array
                              let obj.starting_index = -1
                              " We save some user settings when the plugin loads initially
                              let obj.saved_settings = {
                                    \ 'virtualedit': &virtualedit,
                                    \ 'cursorline': &cursorline,
                                    \ 'lazyredraw': &lazyredraw,
                                    \ 'paste': &paste,
                                    \ 'clipboard': &clipboard,
                                    \ }
                              " We save the window view when multicursor mode is entered
                              let obj.saved_winview = []
                              " Track whether we started multicursor mode from calling multiple_cursors#find
                              let obj.start_from_find = 0
                              return obj
                            endfunction
                            
                            " Clear all cursors and their highlights
    1              0.000005 function! s:CursorManager.reset(restore_view, restore_setting, ...) dict
                              if a:restore_view
                                " Return the view back to the beginning
                                if !empty(self.saved_winview)
                                  call winrestview(self.saved_winview)
                                endif
                            
                                " If the cursor moved, just restoring the view could get confusing, let's
                                " put the cursor at where the user left it. Only do this if we didn't start
                                " from find mode
                                if !self.is_empty() && !self.start_from_find
                                  call cursor(self.get(0).position)
                                endif
                              endif
                            
                              " Delete all cursors and clear their highlights. Don't do clearmatches() as
                              " that will potentially interfere with other plugins
                              if !self.is_empty()
                                for i in range(self.size())
                                  call self.remove_highlight(self.get(i).cursor_hi_id)
                                  call self.remove_highlight(self.get(i).visual_hi_id)
                                endfor
                              endif
                            
                              let self.cursors = []
                              let self.current_index = -1
                              let self.starting_index = -1
                              let self.saved_winview = []
                              let self.start_from_find = 0
                              let s:char = ''
                              let s:saved_char = ''
                              if a:restore_setting
                                call self.restore_user_settings()
                              endif
                              " Call after function if exists and only if action is canceled (<Esc>)
                              if a:0 && s:before_function_called
                                if exists('*Multiple_cursors_after')
                                  exe "call Multiple_cursors_after()"
                                endif
                                silent doautocmd User MultipleCursorsPost
                                let s:before_function_called = 0
                              endif
                            endfunction
                            
                            " Returns 0 if it's not managing any cursors at the moment
    1              0.000004 function! s:CursorManager.is_empty() dict
                              return self.size() == 0
                            endfunction
                            
                            " Returns the number of cursors it's managing
    1              0.000003 function! s:CursorManager.size() dict
                              return len(self.cursors)
                            endfunction
                            
                            " Returns the current cursor
    1              0.000004 function! s:CursorManager.get_current() dict
                              return self.cursors[self.current_index]
                            endfunction
                            
                            " Returns the cursor at index i
    1              0.000004 function! s:CursorManager.get(i) dict
                              return self.cursors[a:i]
                            endfunction
                            
                            " Removes the current cursor and all its associated highlighting. Also update
                            " the current index
    1              0.000003 function! s:CursorManager.delete_current() dict
                              call self.remove_highlight(self.get_current().cursor_hi_id)
                              call self.remove_highlight(self.get_current().visual_hi_id)
                              call remove(self.cursors, self.current_index)
                              let self.current_index -= 1
                            endfunction
                            
                            " Remove the highlighting if its matchid exists
    1              0.000004 function! s:CursorManager.remove_highlight(hi_id) dict
                              if a:hi_id
                                " If the user did a matchdelete or a clearmatches, we don't want to barf if
                                " the matchid is no longer valid
                                silent! call matchdelete(a:hi_id)
                              endif
                            endfunction
                            
    1              0.000003 function! s:CursorManager.debug() dict
                              let i = 0
                              for c in self.cursors
                                echom 'cursor #'.i.': pos='.string(c.position).' visual='.string(c.visual)
                                let i+=1
                              endfor
                              echom 'input = '.s:char
                              echom 'index = '.self.current_index
                              echom 'pos = '.string(s:pos('.'))
                              echom '''< = '.string(s:pos("'<"))
                              echom '''> = '.string(s:pos("'>"))
                              echom 'to mode = '.s:to_mode
                              echom 'from mode = '.s:from_mode
                              " echom 'special keys = '.string(s:special_keys)
                              echom ' '
                            endfunction
                            
                            " Sync the current cursor to the current Vim cursor. This includes updating its
                            " location, its highlight, and potentially its visual region. Return true if the
                            " position changed, false otherwise
    1              0.000003 function! s:CursorManager.update_current() dict
                              let cur = self.get_current()
                              if s:to_mode ==# 'v' || s:to_mode ==# 'V'
                                " If we're in visual line mode, we need to go to visual mode before we can
                                " update the visual region
                                if s:to_mode ==# 'V'
                                  exec "normal! gvv\<Esc>"
                                endif
                                " Sets the cursor at the right place
                                exec "normal! gv\<Esc>"
                                call cur.update_visual_selection(s:get_visual_region(s:pos('.')))
                              elseif s:from_mode ==# 'v' || s:from_mode ==# 'V'
                                " Save contents of unnamed register after each operation in Visual mode.
                                " This should be executed after user input is processed, when unnamed
                                " register already contains the text.
                                call cur.save_unnamed_register()
                                call cur.remove_visual_selection()
                              elseif s:from_mode ==# 'i' && s:to_mode ==# 'n' && self.current_index != 0
                                normal! h
                              elseif s:from_mode ==# 'n'
                                " Save contents of unnamed register after each operation in Normal mode.
                                call cur.save_unnamed_register()
                              endif
                              let pos = s:pos('.')
                            
                              " If the total number of lines changed in the buffer, we need to potentially
                              " adjust other cursor locations
                              let vdelta = line('$') - s:saved_linecount
                              if vdelta != 0
                                if self.current_index != self.size() - 1
                                  let cur_column_offset = (cur.column() - col('.')) * -1
                                  let new_line_length = len(getline('.'))
                                  for i in range(self.current_index+1, self.size()-1)
                                    let hdelta = 0
                                    " Note: some versions of Vim don't like chaining function calls like
                                    " a.b().c(). For compatibility reasons, don't do it
                                    let c = self.get(i)
                                    " If there're other cursors on the same line, we need to adjust their
                                    " columns. This needs to happen before we adjust their line!
                                    if cur.line() == c.line() || cur.position == pos
                                      if vdelta > 0
                                        " Added a line
                                        let hdelta = cur_column_offset
                                      else
                                        " Removed a line
                                        let hdelta = new_line_length
                                      endif
                                    endif
                                    call c.move(vdelta, hdelta)
                                  endfor
                                endif
                              else
                                " If the line length changes, for all the other cursors on the same line as
                                " the current one, update their cursor location as well
                                let hdelta = col('$') - cur.line_length
                                " Only do this if we're still on the same line as before
                                if hdelta != 0 && cur.line() == line('.')
                                  " Update all the cursor's positions that occur after the current cursor on
                                  " the same line
                                  if self.current_index != self.size() - 1
                                    for i in range(self.current_index+1, self.size()-1)
                                      let c = self.get(i)
                                      " Only do it for cursors on the same line
                                      if cur.line() == c.line()
                                        call c.move(0, hdelta)
                                      else
                                        " Early exit, if we're not on the same line, neither will any cursor
                                        " that come after this
                                        break
                                      endif
                                    endfor
                                  endif
                                endif
                              endif
                            
                              if cur.position == pos
                                return 0
                              endif
                              call cur.update_position(pos)
                              return 1
                            endfunction
                            
                            " Advance to the next cursor
    1              0.000004 function! s:CursorManager.next() dict
                              let self.current_index = (self.current_index + 1) % self.size()
                            endfunction
                            
                            " Start tracking cursor updates
    1              0.000003 function! s:CursorManager.start_loop() dict
                              let self.current_index  = 0
                              let self.starting_index = 0
                            endfunction
                            
                            " Returns true if we're cycled through all the cursors
    1              0.000003 function! s:CursorManager.loop_done() dict
                              return self.current_index == self.starting_index
                            endfunction
                            
                            " Tweak some user settings, and save our current window view. This is called
                            " every time multicursor mode is entered.
                            " virtualedit needs to be set to onemore for updates to work correctly
                            " cursorline needs to be turned off for the cursor highlight to work on the line
                            " where the real vim cursor is
                            " lazyredraw needs to be turned on to prevent jerky screen behavior with many
                            " cursors on screen
                            " paste mode needs to be switched off since it turns off a bunch of features
                            " that's critical for the plugin to function
                            " clipboard should not have unnamed and unnamedplus otherwise plugin cannot
                            " reliably use unnamed register ('"')
    1              0.000004 function! s:CursorManager.initialize() dict
                              let self.saved_settings['virtualedit'] = &virtualedit
                              let self.saved_settings['cursorline'] = &cursorline
                              let self.saved_settings['lazyredraw'] = &lazyredraw
                              let self.saved_settings['paste'] = &paste
                              let self.saved_settings['clipboard'] = &clipboard
                              let &virtualedit = "onemore"
                              let &cursorline = 0
                              let &lazyredraw = 1
                              let &paste = 0
                              set clipboard-=unnamed clipboard-=unnamedplus
                              " We could have already saved the view from multiple_cursors#find
                              if !self.start_from_find
                                let self.saved_winview = winsaveview()
                              endif
                            
                              " Save contents and type of unnamed register upon entering multicursor mode
                              " to restore it later when leaving mode
                              let s:paste_buffer_temporary_text = getreg('"')
                              let s:paste_buffer_temporary_type = getregtype('"')
                            endfunction
                            
                            " Restore user settings.
    1              0.000004 function! s:CursorManager.restore_user_settings() dict
                              if !empty(self.saved_settings)
                                let &virtualedit = self.saved_settings['virtualedit']
                                let &cursorline = self.saved_settings['cursorline']
                                let &lazyredraw = self.saved_settings['lazyredraw']
                                let &paste = self.saved_settings['paste']
                                let &clipboard = self.saved_settings['clipboard']
                              endif
                            
                              " Restore original contents and type of unnamed register. This method is
                              " called from reset, which calls us only when restore_setting argument is
                              " true, which happens only when we leave multicursor mode. This should be
                              " symmetrical to saving of unnamed register upon the start of multicursor
                              " mode.
                              call setreg('"', s:paste_buffer_temporary_text, s:paste_buffer_temporary_type)
                            endfunction
                            
                            " Reposition all cursors to the start or end of their region
    1              0.000005 function! s:CursorManager.reposition_all_within_region(start) dict
                              for c in self.cursors
                                call c.update_position(c.saved_visual[a:start ? 0 : 1])
                              endfor
                            endfunction
                            
                            " Reselect the current cursor's region in visual mode
    1              0.000004 function! s:CursorManager.reapply_visual_selection() dict
                              call s:select_in_visual_mode(self.get_current().visual)
                            endfunction
                            
                            " Creates a new virtual cursor as 'pos'
                            " Optionally a 'region' object can be passed in as second argument. If set, the
                            " visual region of the cursor will be set to it
                            " Return true if the cursor has been successfully added, false otherwise
                            " Mode change: Normal -> Normal
                            " Cursor change: None (TODO Should we set Vim's cursor to pos?)
    1              0.000004 function! s:CursorManager.add(pos, ...) dict
                              " Lazy init
                              if self.is_empty()
                                call self.initialize()
                              endif
                            
                              " Don't add duplicates
                              let i = 0
                              for c in self.cursors
                                if c.position == a:pos
                                  return 0
                                endif
                                let i+=1
                              endfor
                            
                              let cursor = s:Cursor.new(a:pos)
                            
                              " Save the visual selection
                              if a:0 > 0
                                call cursor.update_visual_selection(a:1)
                              endif
                            
                              call add(self.cursors, cursor)
                              let self.current_index += 1
                              return 1
                            endfunction
                            
                            "===============================================================================
                            " Variables
                            "===============================================================================
                            
                            " This is the last user input that we're going to replicate, in its string form
    1              0.000005 let s:char = ''
                            " This is either `I` or `A`, as input in Visual mode, that we're going to use
                            " to make the appropriate transition into Insert mode
    1              0.000005 let s:saved_char = ''
                            " This is the mode the user is in before s:char
    1              0.000004 let s:from_mode = ''
                            " This is the mode the user is in after s:char
    1              0.000004 let s:to_mode = ''
                            " This is the total number of lines in the buffer before processing s:char
    1              0.000007 let s:saved_linecount = -1
                            " This is used to apply the highlight fix. See s:apply_highight_fix()
    1              0.000004 let s:saved_line = 0
                            " This is the number of cursor locations where we detected an input that we
                            " cannot play back
    1              0.000004 let s:bad_input = 0
                            " Singleton cursor manager instance
    1   0.000128   0.000034 let s:cm = s:CursorManager.new()
                            
                            "===============================================================================
                            " Utility functions
                            "===============================================================================
                            
                            " Return the position of the input marker as a two element array. First element
                            " is the line number, second element is the column number
    1              0.000006 function! s:pos(mark)
                              let pos = getpos(a:mark)
                              return [pos[1], pos[2]]
                            endfunction
                            
                            " Return the region covered by the input markers as a two element array. First
                            " element is the position of the start marker, second element is the position of
                            " the end marker
    1              0.000005 function! s:region(start_mark, end_mark)
                              return [s:pos(a:start_mark), s:pos(a:end_mark)]
                            endfunction
                            
                            " Exit visual mode and go back to normal mode
                            " The reason for the additional gv\<Esc> is that it allows the cursor to stay
                            " on where it was before exiting
                            " Mode change: Normal -> Normal or Visual -> Normal
                            " Cursor change: If in visual mode, changed to exactly where it was on screen in
                            " visual mode. If in normal mode, changed to where the cursor was when the last
                            " visual selection ended
    1              0.000004 function! s:exit_visual_mode()
                              exec "normal! \<Esc>gv\<Esc>"
                            
                              " Call before function if exists only once until it is canceled (<Esc>)
                              if exists('*Multiple_cursors_before') && !s:before_function_called
                                exe "call Multiple_cursors_before()"
                                let s:before_function_called = 1
                              endif
                            endfunction
                            
                            " Visually select input region, where region is an array containing the start
                            " and end position. If start is after end, the selection simply goes backwards.
                            " Typically m<, m>, and gv would be a simple way of accomplishing this, but on
                            " some systems, the m< and m> marks are not supported. Note that v`` has random
                            " behavior if `` is the same location as the cursor location.
                            " Mode change: Normal -> Visual
                            " Cursor change: Set to end of region
                            " TODO: Refactor this and s:update_visual_markers
                            " FIXME: By using m` we're destroying the user's jumplist. We should use a
                            " different mark and use :keepjump
    1              0.000011 function! s:select_in_visual_mode(region)
                              if a:region[0] == a:region[1]
                                normal! v
                              else
                                call cursor(a:region[1])
                                normal! m`
                                call cursor(a:region[0])
                                normal! v``
                              endif
                            
                              " Unselect and reselect it again to properly set the '< and '> markers
                              exec "normal! \<Esc>gv"
                            endfunction
                            
                            " Update '< and '> to the input region
                            " Mode change: Normal -> Normal
                            " Cursor change: Set to the end of the region
    1              0.000005 function! s:update_visual_markers(region)
                              if a:region[0] == a:region[1]
                                normal! v
                              else
                                call cursor(a:region[1])
                                normal! m`
                                call cursor(a:region[0])
                                normal! v``
                              endif
                              call s:exit_visual_mode()
                            endfunction
                            
                            " Finds the next occurrence of the input text in the current buffer.
                            " Search is case sensitive
                            " Mode change: Normal -> Normal
                            " Cursor change: Set to the end of the match
    1              0.000004 function! s:find_next(text)
                              let pattern = substitute(escape(a:text, '\'), '\n', '\\n', 'g')
                              if s:use_word_boundary == 1
                                  let pattern = '\<'.pattern.'\>'
                              endif
                              let pattern = '\V\C'.pattern
                              call search(pattern)
                              let start = s:pos('.')
                              call search(pattern, 'ce')
                              let end = s:pos('.')
                              return [start, end]
                            endfunction
                            
                            " Highlight the position using the cursor highlight group
    1              0.000005 function! s:highlight_cursor(pos)
                              " Give cursor highlight high priority, to overrule visual selection
                              return matchadd(s:hi_group_cursor, '\%'.a:pos[0].'l\%'.a:pos[1].'c', 99999)
                            endfunction
                            
                            " Compare two position arrays. Return a negative value if lhs occurs before rhs,
                            " positive value if after, and 0 if they are the same.
    1              0.000005 function! s:compare_pos(l, r)
                              " If number lines are the same, compare columns
                              return a:l[0] ==# a:r[0] ? a:l[1] - a:r[1] : a:l[0] - a:r[0]
                            endfunction
                            
                            " Highlight the area bounded by the input region. The logic here really stinks,
                            " it's frustrating that Vim doesn't have a built in easier way to do this. None
                            " of the \%V or \%'m solutions work because we need the highlighting to stay for
                            " multiple places.
    1              0.000004 function! s:highlight_region(region)
                              let s = sort(copy(a:region), "s:compare_pos")
                              if s:to_mode ==# 'V'
                                let pattern = '\%>'.(s[0][0]-1).'l\%<'.(s[1][0]+1).'l.*\ze.\_$'
                              else
                                if (s[0][0] == s[1][0])
                                  " Same line
                                  let pattern = '\%'.s[0][0].'l\%>'.(s[0][1]-1).'c.*\%<'.(s[1][1]+1).'c.'
                                else
                                  " Two lines
                                  let s1 = '\%'.s[0][0].'l.\%>'.s[0][1].'c.*'
                                  let s2 = '\%'.s[1][0].'l.*\%<'.s[1][1].'c..'
                                  let pattern = s1.'\|'.s2
                                  " More than two lines
                                  if (s[1][0] - s[0][0] > 1)
                                    let pattern = pattern.'\|\%>'.s[0][0].'l\%<'.s[1][0].'l.*\ze.\_$'
                                  endif
                                endif
                              endif
                              return matchadd(s:hi_group_visual, pattern)
                            endfunction
                            
                            " Perform the operation that's necessary to revert us from one mode to another
    1              0.000004 function! s:revert_mode(from, to)
                              if a:to ==# 'v'
                                call s:cm.reapply_visual_selection()
                              elseif a:to ==# 'V'
                                call s:cm.reapply_visual_selection()
                                normal! V
                              elseif a:to ==# 'n' && a:from ==# 'i'
                                stopinsert
                              endif
                            endfunction
                            
                            " Consume all the additional character the user typed between the last
                            " getchar() and here, to avoid potential race condition.
    1              0.000005 let s:saved_keys = ""
    1              0.000004 function! s:feedkeys(keys)
                              while 1
                                let c = getchar(0)
                                let char_type = type(c)
                                " Checking type is important, when strings are compared with integers,
                                " strings are always converted to ints, and all strings are equal to 0
                                if char_type == 0
                                  if c == 0
                                    break
                                  else
                                    let s:saved_keys .= nr2char(c)
                                  endif
                                elseif char_type == 1 " char with more than 8 bits (as string)
                                  let s:saved_keys .= c
                                endif
                              endwhile
                              call feedkeys(a:keys)
                            endfunction
                            
                            " Take the user input and apply it at every cursor
    1              0.000004 function! s:process_user_input()
                              " Grr this is frustrating. In Insert mode, between the feedkey call and here,
                              " the current position could actually CHANGE for some odd reason. Forcing a
                              " position reset here
                              let cursor_position = s:cm.get_current()
                              call cursor(cursor_position.position)
                            
                              " Before applying the user input, we need to revert back to the mode the user
                              " was in when the input was entered
                              call s:revert_mode(s:to_mode, s:from_mode)
                            
                              " Update the line length BEFORE applying any actions. TODO(terryma): Is there
                              " a better place to do this?
                              " let cursor_position = s:cm.get_current()
                              call cursor_position.update_line_length()
                              let s:saved_linecount = line('$')
                            
                              " Restore unnamed register only in Normal mode. This should happen before user
                              " input is processed.
                              if s:from_mode ==# 'n' || s:from_mode ==# 'v' || s:from_mode ==# 'V'
                                call cursor_position.restore_unnamed_register()
                              endif
                            
                              " Apply the user input. Note that the above could potentially change mode, we
                              " use the mapping below to help us determine what the new mode is
                              " Note that it's possible that \<Plug>(multiple-cursors-apply) never gets called, we have a
                              " detection mechanism using \<Plug>(multiple-cursors-detect). See its documentation for more details
                            
                              " Assume that input is not valid
                              let s:valid_input = 0
                            
                              " If we're coming from insert mode or going into insert mode, always chain the
                              " undos together.
                              " FIXME(terryma): Undo always places the cursor at the beginning of the line.
                              " Figure out why.
                              if s:from_mode ==# 'i' || s:to_mode ==# 'i'
                                silent! undojoin | call s:feedkeys(s:char."\<Plug>(multiple-cursors-apply)")
                              else
                                call s:feedkeys(s:char."\<Plug>(multiple-cursors-apply)")
                              endif
                            
                              " Even when s:char produces invalid input, this method is always called. The
                              " 't' here is important
                              call feedkeys("\<Plug>(multiple-cursors-detect)", 't')
                            endfunction
                            
                            " This method is always called during fanout, even when a bad user input causes
                            " s:apply_user_input_next to not be called. We detect that and force the method
                            " to be called to continue the fanout process
    1              0.000004 function! s:detect_bad_input()
                              if !s:valid_input
                                " To invoke the appropriate `<Plug>(multiple-cursors-apply)` mapping, we
                                " need to revert back to the mode the user was in when the input was entered
                                call s:revert_mode(s:to_mode, s:from_mode)
                                " We ignore the bad input and force invoke s:apply_user_input_next
                                call feedkeys("\<Plug>(multiple-cursors-apply)")
                                let s:bad_input += 1
                              endif
                            endfunction
                            
                            " Complete transition into Insert mode when `I` or `A` is input in Visual mode
    1              0.000005 function! s:handle_visual_IA_to_insert()
                              if !empty(s:saved_char) && s:char =~# 'v\|V' && s:to_mode ==# 'n'
                                if s:saved_char ==# 'I'
                                  call s:cm.reposition_all_within_region(1)
                                endif
                                call feedkeys(tolower(s:saved_char))
                                let s:saved_char = ''
                              endif
                            endfunction
                            
                            " Begin transition into Insert mode when `I` or `A` is input in Visual mode
    1              0.000004 function! s:handle_visual_IA_to_normal()
                              if s:char =~# 'I\|A' && s:from_mode =~# 'v\|V'
                                let s:saved_char = s:char
                                let s:char = s:from_mode " spoof a 'v' or 'V' input to transiton from Visual into Normal mode
                              endif
                            endfunction
                            
                            " Apply the user input at the next cursor location
    1              0.000004 function! s:apply_user_input_next(mode)
                              let s:valid_input = 1
                            
                              " Save the current mode, only if we haven't already
                              if empty(s:to_mode)
                                let s:to_mode = a:mode
                                if s:to_mode ==# 'v'
                                  if visualmode() ==# 'V'
                                    let s:to_mode = 'V'
                                  endif
                                endif
                              endif
                            
                              " Update the current cursor's information
                              let changed = s:cm.update_current()
                            
                              " Advance the cursor index
                              call s:cm.next()
                            
                              " We're done if we're made the full round
                              if s:cm.loop_done()
                                if s:to_mode ==# 'v' || s:to_mode ==# 'V'
                                  " This is necessary to set the "'<" and "'>" markers properly
                                  call s:update_visual_markers(s:cm.get_current().visual)
                                endif
                                call feedkeys("\<Plug>(multiple-cursors-wait)")
                                call s:handle_visual_IA_to_insert()
                              else
                                " Continue to next
                                call feedkeys("\<Plug>(multiple-cursors-input)")
                              endif
                            endfunction
                            
                            " If pos is equal to the left side of the visual selection, the region start
                            " from end to start
    1              0.000004 function! s:get_visual_region(pos)
                              let left = s:pos("'<")
                              let right = s:pos("'>")
                              if a:pos == left
                                let region = [right, left]
                              else
                                let region = [left, right]
                              endif
                              return region
                            endfunction
                            
    1              0.000005 function! s:strpart(s, i, l)
                              if a:l == 0
                                return ''
                              endif
                              let [s, l] = ['', 0]
                              for c in split(a:s[a:i :], '\zs')
                                let s .= c
                                let l += len(c)
                                if l >= a:l
                                  break
                                endif
                              endfor
                              return s
                            endfunction
                            
                            " Return the content of the buffer between the input region. This is used to
                            " find the next match in the buffer
                            " Mode change: Normal -> Normal
                            " Cursor change: None
    1              0.000004 function! s:get_text(region)
                              let lines = getline(a:region[0][0], a:region[1][0])
                              let lines[-1] = s:strpart(lines[-1], 0, a:region[1][1])
                              let lines[0] = lines[0][a:region[0][1] - 1:]
                              return join(lines, "\n")
                            endfunction
                            
                            " Wrapper around getchar() that returns the string representation of the user
                            " input
    1              0.000003 function! s:get_char(...)
                              let c = (a:0 == 0) ? getchar() : getchar(a:1)
                              " If the character is a number, then it's not a special key
                              if type(c) == 0
                                let c = nr2char(c)
                              endif
                              return c
                            endfunction
                            
                            " Quits multicursor mode and clears all cursors. Return true if exited
                            " successfully.
    1              0.000003 function! s:exit()
                              if s:char !=# g:multi_cursor_quit_key
                                return 0
                              endif
                              let exit = 0
                              if s:from_mode ==# 'n'
                                let exit = 1
                              elseif (s:from_mode ==# 'v' || s:from_mode ==# 'V') &&
                                    \ g:multi_cursor_exit_from_visual_mode
                                let exit = 1
                              elseif s:from_mode ==# 'i' && g:multi_cursor_exit_from_insert_mode
                                stopinsert
                                let exit = 1
                              endif
                              if exit
                                call s:cm.reset(1, 1, 1)
                                return 1
                              endif
                              return 0
                            endfunction
                            
                            " These keys don't get faned out to all cursor locations. Instead, they're used
                            " to add new / remove existing cursors
                            " Precondition: The function is only called when the keys and mode respect the
                            " setting in s:special_keys
    1              0.000005 function! s:handle_special_key(key, mode)
                              " Use feedkeys here instead of calling the function directly to prevent
                              " increasing the call stack, since feedkeys execute after the current call
                              " finishes
                              if a:key == g:multi_cursor_next_key
                                if s:use_word_boundary == 1
                                  call s:feedkeys("\<Plug>(multiple-cursors-new-word)")
                                else
                                  call s:feedkeys("\<Plug>(multiple-cursors-new)")
                                endif
                              elseif a:key == g:multi_cursor_prev_key
                                call s:feedkeys("\<Plug>(multiple-cursors-prev)")
                              elseif a:key == g:multi_cursor_skip_key
                                call s:feedkeys("\<Plug>(multiple-cursors-skip)")
                              endif
                            endfunction
                            
                            " The last line where the normal Vim cursor is always seems to highlighting
                            " issues if the cursor is on the last column. Vim's cursor seems to override the
                            " highlight of the virtual cursor. This won't happen if the virtual cursor isn't
                            " the last character on the line. This is a hack to add an empty space on the
                            " Vim cursor line right before we do the redraw, we'll revert the change
                            " immedidately after the redraw so the change should not be intrusive to the
                            " user's buffer content
    1              0.000004 function! s:apply_highlight_fix()
                              " Only do this if we're on the last character of the line
                              if col('.') == col('$')
                                let s:saved_line = getline('.')
                                if s:from_mode ==# 'i'
                                  silent! undojoin | call setline('.', s:saved_line.' ')
                                else
                                  call setline('.', s:saved_line.' ')
                                endif
                              endif
                            endfunction
                            
                            " Revert the fix if it was applied earlier
    1              0.000004 function! s:revert_highlight_fix()
                              if type(s:saved_line) == 1
                                if s:from_mode ==# 'i'
                                  silent! undojoin | call setline('.', s:saved_line)
                                else
                                  call setline('.', s:saved_line)
                                endif
                              endif
                              let s:saved_line = 0
                            endfunction
                            
    1              0.000005 let s:retry_keys = ""
    1              0.000004 function! s:display_error()
                              if s:bad_input == s:cm.size()
                                    \ && ((s:from_mode ==# 'n'    && has_key(g:multi_cursor_normal_maps, s:char[0]))
                                    \ ||  (s:from_mode =~# 'v\|V' && has_key(g:multi_cursor_visual_maps, s:char[0])))
                                " we couldn't replay it anywhere but we're told it's the beginning of a
                                " multi-character map like the `d` in `dw`
                                let s:retry_keys = s:char
                              else
                                let s:retry_keys = ""
                                if s:bad_input > 0
                                  echohl ErrorMsg |
                                        \ echo "Key '".s:char."' cannot be replayed at ".
                                        \ s:bad_input." cursor location".(s:bad_input == 1 ? '' : 's') |
                                        \ echohl Normal
                                endif
                              endif
                              let s:bad_input = 0
                            endfunction
                            
    1              0.000005 let s:latency_debug_file = ''
    1              0.000009 function! s:start_latency_measure()
                              if g:multi_cursor_debug_latency
                                let s:start_time = reltime()
                              endif
                            endfunction
                            
    1              0.000004 function! s:skip_latency_measure()
                              if g:multi_cursor_debug_latency
                                let s:skip_latency_measure = 1
                              endif
                            endfunction
                            
    1              0.000004 function! s:end_latency_measure()
                              if g:multi_cursor_debug_latency && !empty(s:char)
                                if empty(s:latency_debug_file)
                                  let s:latency_debug_file = tempname()
                                  exec 'redir >> '.s:latency_debug_file
                                    silent! echom "Starting latency debug at ".reltimestr(reltime())
                                  redir END
                                endif
                            
                                if !s:skip_latency_measure
                                  exec 'redir >> '.s:latency_debug_file
                                    silent! echom "Processing '".s:char."' took ".string(str2float(reltimestr(reltime(s:start_time)))*1000).' ms in '.s:cm.size().' cursors. mode = '.s:from_mode
                                  redir END
                                endif
                              endif
                              let s:skip_latency_measure = 0
                            endfunction
                            
    1              0.000004 function! s:get_time_in_ms()
                              return str2nr(substitute(reltimestr(reltime()), '\.\(...\).*', '\1', ''))
                            endfunction
                            
    1              0.000004 function! s:last_char()
                              return s:char[len(s:char)-1]
                            endfunction
                            
    1              0.000005 function! s:wait_for_user_input(mode)
                              call s:display_error()
                            
                              let s:from_mode = a:mode
                              if empty(a:mode)
                                let s:from_mode = s:to_mode
                              endif
                              let s:to_mode = ''
                            
                              " Right before redraw, apply the highlighting bug fix
                              call s:apply_highlight_fix()
                            
                              redraw
                            
                              " Immediately revert the change to leave the user's buffer unchanged
                              call s:revert_highlight_fix()
                            
                              call s:end_latency_measure()
                            
                              let s:char = s:retry_keys . s:saved_keys
                              if len(s:saved_keys) == 0
                                let s:char .= s:get_char()
                                call s:handle_visual_IA_to_normal()
                              else
                                let s:saved_keys = ""
                              endif
                            
                              " ambiguous mappings are not supported; e.g.:
                              "   imap jj JJ
                              "   imap jjj JJJ
                              " will always trigger the 'jj' mapping
                              if s:from_mode ==# 'i' && mapcheck(s:char, "i") != ""
                                let map_dict = {}
                                let s_time = s:get_time_in_ms()
                                while 1
                                  let map_dict = maparg(s:char, "i", 0, 1)
                                  " break if chars exactly match mapping
                                  if map_dict != {}
                                    if get(map_dict, 'expr', 0)
                                      " handle case where {rhs} is a function
                                      exec 'let char_mapping = ' . map_dict['rhs']
                                    else
                                      let char_mapping = maparg(s:char, "i")
                                    endif
                                    " handle case where mapping is <esc>
                                    exec 'let s:char = "'.substitute(char_mapping, '<', '\\<', 'g').'"'
                                    break
                                  endif
                                  " break if chars don't match beginning of mapping anymore
                                  if mapcheck(s:char, "i") == ""
                                    break
                                  endif
                                  if s:get_time_in_ms() > (s_time + &timeoutlen)
                                    break
                                  endif
                                  let new_char = s:get_char(0)
                                  let s:char .= new_char
                                  if new_char == ''
                                    sleep 50m
                                  endif
                                endwhile
                              elseif s:from_mode !=# 'i' && s:char[0] ==# ":"
                                call feedkeys(s:char)
                                call s:cm.reset(1, 1, 1)
                                return
                              elseif s:from_mode ==# 'n' || s:from_mode =~# 'v\|V'
                                while match(s:last_char(), "\\d") == 0
                                  if match(s:char, '\(^\|\a\)0') == 0
                                    " fixes an edge case concerning the `0` key.
                                    " The 0 key behaves differently from [1-9].
                                    " It's consumed immediately when it is the
                                    " first key typed while we're waiting for input.
                                    " References: issue #152, pull #241
                                    break
                                  endif
                                  let s:char .= s:get_char()
                                endwhile
                              endif
                            
                              call s:start_latency_measure()
                            
                              " Clears any echoes we might've added
                              normal! :<Esc>
                            
                              " add chars to s:char if it start like a special/quit key
                              let is_special_key = 0
                              let sk_list = get(s:special_keys, s:from_mode, [])
                              let is_special_key = (index(sk_list, s:char) != -1)
                              let is_quit_key = 0
                              let s_time = s:get_time_in_ms()
                              while 1
                                let start_special_key = (index(map(sk_list[:], 'v:val[0:len(s:char)-1] == s:char'), 1) > -1)
                                let start_quit_key = (g:multi_cursor_quit_key[0:len(s:char)-1] == s:char)
                                if start_special_key == 0 && start_quit_key == 0
                                  break
                                else
                                  let is_special_key = (index(sk_list, s:char) != -1)
                                  let is_quit_key = (g:multi_cursor_quit_key == s:char)
                                  if is_special_key == 1 || is_quit_key == 1
                                    break
                                  else
                                    if s:get_time_in_ms() > (s_time + &timeoutlen)
                                      break
                                    endif
                                    let new_char = s:get_char(0)
                                    let s:char .= new_char
                                    if new_char == ''
                                      sleep 50m
                                    endif
                                  endif
                                end
                              endwhile
                            
                              if s:exit()
                                return
                              endif
                            
                              " If the key is a special key and we're in the right mode, handle it
                              if is_special_key == 1
                                call s:handle_special_key(s:char, s:from_mode)
                                call s:skip_latency_measure()
                              else
                                call s:cm.start_loop()
                                call s:feedkeys("\<Plug>(multiple-cursors-input)")
                              endif
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim
Sourced 1 time
Total time:   0.001663
 Self time:   0.001386

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: echodoc.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
                            " Variables
    1   0.000510   0.000233 let s:echodoc_dicts = [ echodoc#default#get() ]
    1              0.000006 let s:is_enabled = 0
    1              0.000005 let s:echodoc_id = 1050
    1              0.000010 if exists('*nvim_create_namespace')
    1              0.000014   let s:echodoc_id = nvim_create_namespace('echodoc.vim')
                            elseif exists('*nvim_buf_add_highlight')
                              let s:echodoc_id = nvim_buf_add_highlight(0, 0, '', 0, 0, 0)
    1              0.000002 endif
    1              0.000007 if exists('*nvim_create_buf')
    1              0.000007   let s:floating_buf = v:null
    1              0.000005   let s:win = v:null
    1              0.000305   let s:floating_buf = nvim_create_buf(v:false, v:true)
    1              0.000005 endif
                            
    1              0.000014 let g:echodoc#type = get(g:,
                                  \ 'echodoc#type', 'echo')
    1              0.000054 let g:echodoc#highlight_identifier = get(g:,
                                  \ 'echodoc#highlight_identifier', 'Identifier')
    1              0.000131 let g:echodoc#highlight_arguments = get(g:,
                                  \ 'echodoc#highlight_arguments', 'Special')
    1              0.000067 let g:echodoc#highlight_trailing = get(g:,
                                  \ 'echodoc#highlight_trailing', 'Type')
    1              0.000061 let g:echodoc#events = get(g:,
                                  \ 'echodoc#events', ['CompleteDone'])
                            
    1              0.000006 function! echodoc#enable() abort
                              if &showmode && &cmdheight < 2 && echodoc#is_echo()
                                " Increase the cmdheight so user can clearly see the error
                                set cmdheight=2
                                call s:print_error('Your cmdheight is too small. '
                                      \ .'You must increase ''cmdheight'' value or set noshowmode.')
                              endif
                            
                              augroup echodoc
                                autocmd!
                                autocmd InsertEnter * call s:on_timer('InsertEnter')
                                autocmd CursorMovedI * call s:on_timer('CursorMovedI')
                                autocmd InsertLeave * call s:on_insert_leave()
                              augroup END
                              for event in g:echodoc#events
                                if exists('##' . event)
                                  execute printf('autocmd echodoc %s * call s:on_event("%s")',
                                        \ event, event)
                                endif
                              endfor
                              let s:is_enabled = 1
                            endfunction
    1              0.000005 function! echodoc#disable() abort
                              augroup echodoc
                                autocmd!
                              augroup END
                              let s:is_enabled = 0
                            endfunction
    1              0.000004 function! echodoc#is_enabled() abort
                              return s:is_enabled
                            endfunction
    1              0.000004 function! echodoc#is_echo() abort
                              return !echodoc#is_signature() && !echodoc#is_virtual() && !echodoc#is_floating()
                            endfunction
    1              0.000004 function! echodoc#is_signature() abort
                              return g:echodoc#type ==# 'signature'
                                    \ && has('nvim') && get(g:, 'gonvim_running', 0)
                            endfunction
    1              0.000004 function! echodoc#is_virtual() abort
                              return g:echodoc#type ==# 'virtual' && exists('*nvim_buf_set_virtual_text')
                            endfunction
    1              0.000004 function! echodoc#is_floating() abort
                              return g:echodoc#type ==# 'floating' && exists('*nvim_open_win')
                            endfunction
    1              0.000004 function! echodoc#get(name) abort
                              return get(filter(s:echodoc_dicts,
                                    \ 'v:val.name ==#' . string(a:name)), 0, {})
                            endfunction
    1              0.000005 function! echodoc#register(name, dict) abort
                              " Unregister previous dict.
                              call echodoc#unregister(a:name)
                            
                              call add(s:echodoc_dicts, a:dict)
                            
                              " Sort.
                              call sort(s:echodoc_dicts, 's:compare')
                            endfunction
    1              0.000004 function! echodoc#unregister(name) abort
                              call filter(s:echodoc_dicts, 'v:val.name !=#' . string(a:name))
                            endfunction
                            
                            " Misc.
    1              0.000007 function! s:compare(a1, a2) abort
                              return a:a1.rank - a:a2.rank
                            endfunction
    1              0.000005 function! s:context_filetype_enabled() abort
                              if !exists('s:exists_context_filetype')
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
                              return s:exists_context_filetype
                            endfunction
    1              0.000005 function! s:print_error(msg) abort
                              echohl Error | echomsg '[echodoc] '  . a:msg | echohl None
                            endfunction
                            
                            " Autocmd events.
    1              0.000004 function! s:on_timer(event) abort
                              if !has('timers')
                                return s:on_event()
                              endif
                            
                              if exists('s:_timer')
                                call timer_stop(s:_timer)
                              endif
                            
                              let s:_timer = timer_start(100, {-> s:on_event(a:event)})
                            endfunction
    1              0.000004 function! s:on_event(event) abort
                              unlet! s:_timer
                            
                              let filetype = s:context_filetype_enabled() ?
                                    \ context_filetype#get_filetype(&filetype) : &l:filetype
                              if filetype ==# ''
                                let filetype = 'nothing'
                              endif
                            
                              let completed_item = get(v:, 'completed_item', {})
                              if empty(completed_item) && exists('v:event')
                                let completed_item = get(v:event, 'completed_item', {})
                              endif
                              if filetype !=# '' && !empty(completed_item)
                                call echodoc#default#make_cache(filetype, completed_item)
                              endif
                            
                              let dicts = filter(copy(s:echodoc_dicts),
                                    \ "empty(get(v:val, 'filetypes', {}))
                                    \  || get(v:val.filetypes, filetype, 0)")
                            
                              let defaut_only = len(dicts) == 1
                            
                              if defaut_only && empty(echodoc#default#get_cache(filetype))
                                return
                              endif
                            
                              let cur_text = echodoc#util#get_func_text()
                            
                              " No function text was found
                              if cur_text ==# '' && defaut_only
                                return
                              endif
                            
                              let echodoc = {}
                              for doc_dict in dicts
                                if doc_dict.name ==# 'default'
                                  let ret = doc_dict.search(cur_text, filetype)
                                else
                                  let ret = doc_dict.search(cur_text)
                                endif
                            
                                if !empty(ret)
                                  " Overwrite cached result
                                  let echodoc = ret
                                  break
                                endif
                              endfor
                            
                              if !empty(echodoc)
                                let b:echodoc = echodoc
                                call s:display(echodoc, filetype)
                              elseif exists('b:echodoc')
                                unlet b:echodoc
                              endif
                            endfunction
                            " @vimlint(EVL103, 0, a:timer)
    1              0.000004 function! s:on_insert_leave() abort
                              if echodoc#is_signature()
                                call rpcnotify(0, 'Gui', 'signature_hide')
                              endif
                              if echodoc#is_floating()
                                if s:win != v:null
                                  call nvim_win_close(s:win, v:false)
                                  let s:win = v:null
                                endif
                                call nvim_buf_clear_namespace(s:floating_buf, s:echodoc_id, 0, -1)
                              endif
                              if echodoc#is_virtual()
                                call nvim_buf_clear_namespace(bufnr('%'), s:echodoc_id, 0, -1)
                              endif
                            endfunction
                            
    1              0.000005 function! s:display(echodoc, filetype) abort
                              " Text check
                              let text = ''
                              for doc in a:echodoc
                                let text .= doc.text
                              endfor
                              if matchstr(text, '^\s*$')
                                return
                              endif
                            
                              " Display
                              if echodoc#is_signature()
                                let parse = echodoc#util#parse_funcs(getline('.'), a:filetype)
                                if empty(parse)
                                  return
                                endif
                                let col = -(col('.') - parse[-1].start + 1)
                                let idx = 0
                                let text = ''
                                let line = (winline() <= 2) ? 3 : -1
                                for doc in a:echodoc
                                  let text .= doc.text
                                  if has_key(doc, 'i')
                                    let idx = doc.i
                                  endif
                                endfor
                                call rpcnotify(0, 'Gui', 'signature_show', text, [line, col], idx)
                                redraw!
                              elseif echodoc#is_virtual()
                                call nvim_buf_clear_namespace(bufnr('%'), s:echodoc_id, 0, -1)
                                let chunks = map(copy(a:echodoc),
                                      \ "[v:val.text, get(v:val, 'highlight', 'Normal')]")
                                call nvim_buf_set_virtual_text(
                                      \ bufnr('%'), s:echodoc_id, line('.') - 1, chunks, {})
                              elseif echodoc#is_floating()
                                let hunk = join(map(copy(a:echodoc), "v:val.text"), "")
                                let window_width = strlen(hunk)
                            
                                let identifier_pos = match(getline('.'), a:echodoc[0].text)
                                if identifier_pos != -1 " Identifier found in current line
                                  let cursor_pos = getpos('.')[2]
                                  " align the function signature text and the line text
                                  let identifier_pos =  cursor_pos - identifier_pos
                                endif
                                call nvim_buf_set_lines(s:floating_buf, 0, -1, v:true, [hunk])
                                let opts = {'relative': 'cursor', 'width': window_width,
                                    \ 'height': 1, 'col': -identifier_pos + 1,
                                    \ 'row': 0, 'anchor': 'SW'}
                                if s:win == v:null
                                  let s:win = nvim_open_win(s:floating_buf, 0, opts)
                            
                                  call nvim_win_set_option(s:win, 'number', v:false)
                                  call nvim_win_set_option(s:win, 'relativenumber', v:false)
                                  call nvim_win_set_option(s:win, 'cursorline', v:false)
                                  call nvim_win_set_option(s:win, 'cursorcolumn', v:false)
                                  call nvim_win_set_option(s:win, 'colorcolumn', '')
                                  call nvim_win_set_option(s:win, 'conceallevel', 2)
                                  call nvim_win_set_option(s:win, 'signcolumn', "no")
                                  call nvim_win_set_option(s:win, 'winhl', 'Normal:EchoDocFloat')
                            
                                  call nvim_buf_set_option(s:floating_buf, "buftype", "nofile")
                                  call nvim_buf_set_option(s:floating_buf, "bufhidden", "delete")
                            
                                else
                                  call nvim_win_set_config(s:win, opts)
                                endif
                            
                                call nvim_buf_clear_namespace(s:floating_buf, s:echodoc_id, 0, -1)
                            
                                let last_chunk_index = 0
                                for doc in a:echodoc
                                  let len_current_chunk = strlen(doc.text)
                                  if has_key(doc, 'highlight')
                                    call nvim_buf_add_highlight(s:floating_buf, s:echodoc_id, doc.highlight, 0,
                                          \ last_chunk_index, len_current_chunk+last_chunk_index)
                                  endif
                                  let last_chunk_index += len_current_chunk
                                endfor
                              else
                                echo ''
                                for doc in a:echodoc
                                  if has_key(doc, 'highlight')
                                    execute 'echohl' doc.highlight
                                    echon doc.text
                                    echohl None
                                  else
                                    echon doc.text
                                  endif
                                endfor
                              endif
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/echodoc/default.vim
Sourced 1 time
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: autoload/echodoc/default.vim
                            " AUTHOR:  Shougo Matsushita <Shougo.Matsu at gmail.com>
                            "          Tommy Allen <tommy@esdf.io>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000009 let s:complete_cache = {}
    1              0.000013 let s:default = {
                                  \ 'name' : 'default',
                                  \ 'rank' : 10,
                                  \ }
                            
                            " @vimlint(EVL102, 1, v:completed_item)
    1              0.000011 function! s:default.search(cur_text, filetype) abort
                              if a:filetype ==# ''
                                return []
                              endif
                            
                              if !has_key(s:complete_cache, a:filetype)
                                let s:complete_cache[a:filetype] = {}
                              endif
                            
                              let cache = s:complete_cache[a:filetype]
                              let comp = {}
                            
                              for comp in reverse(echodoc#util#parse_funcs(a:cur_text, a:filetype))
                                if comp.end == -1
                                  break
                                endif
                              endfor
                            
                              if empty(comp) || !has_key(cache, comp.name)
                                return []
                              endif
                            
                              let v_comp = cache[comp.name]
                              let ret = [
                                    \ {
                                    \  'text': v_comp.name,
                                    \  'highlight': g:echodoc#highlight_identifier
                                    \ },
                                    \ {'text': '('}]
                              let l = max([comp.pos, len(v_comp.args)])
                            
                              for i in range(l)
                                let item = {'text': '#'.i}
                            
                                if i < len(v_comp.args)
                                  let arg = v_comp.args[i]
                                  let item.text = matchstr(arg, '^\_s*\zs.\{-}\ze\_s*$')
                                endif
                            
                                if i == comp.pos - 1 || (i == 0 && comp.pos == 0)
                                  let item.highlight = g:echodoc#highlight_arguments
                                  let item.i = i
                                endif
                            
                                call add(ret, item)
                            
                                if i != l - 1
                                  call add(ret, {'text': ', '})
                                endif
                              endfor
                            
                              call add(ret, {'text': ')'})
                            
                              if has_key(v_comp, 'trailing') && !empty(v_comp.trailing)
                                call add(ret, {
                                      \ 'text': ' ' . v_comp.trailing,
                                      \ 'highlight': g:echodoc#highlight_trailing
                                      \ })
                              endif
                            
                              return ret
                            endfunction
                            " @vimlint(EVL102, 0, v:completed_item)
                            
    1              0.000005 function! echodoc#default#get() abort
                              return s:default
                            endfunction
                            
    1              0.000005 function! echodoc#default#get_cache(filetype) abort
                              if !has_key(s:complete_cache, a:filetype)
                                let s:complete_cache[a:filetype] = {}
                              endif
                            
                              return s:complete_cache[a:filetype]
                            endfunction
                            
    1              0.000006 function! echodoc#default#make_cache(filetype, completed_item) abort
                              let cache = echodoc#default#get_cache(a:filetype)
                            
                              let candidates = [a:completed_item]
                              if exists('g:deoplete#_prev_completion')
                                let candidates += g:deoplete#_prev_completion.candidates
                              endif
                              for candidate in candidates
                                let v_comp = echodoc#util#completion_signature(
                                      \ candidate, &columns * &cmdheight - 1, a:filetype)
                                if empty(v_comp)
                                  continue
                                endif
                            
                                if a:filetype ==# 'vim'
                                  let args = []
                                  for i in range(len(v_comp.args))
                                    for a in split(substitute(v_comp.args[i], '\[, ', ',[', 'g'), ',')
                                      call add(args, matchstr(a, '\s*\zs.\{-}\ze\s*$'))
                                    endfor
                                  endfor
                            
                                  let v_comp.args = args
                                endif
                            
                                let cache[v_comp.name] = v_comp
                              endfor
                            endfunction
                            
                            " vim: foldmethod=marker

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/deoplete/mapping.vim
Sourced 1 time
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: mapping.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000013 function! s:check_completion_info(candidates) abort
                              if !exists('*complete_info')
                                return 0
                              endif
                            
                              let info = complete_info()
                              if info.mode !=# '' && info.mode !=# 'eval'
                                return 1
                              endif
                            
                              let old_candidates = sort(map(copy(info.items), 'v:val.word'))
                              return sort(map(copy(a:candidates), 'v:val.word')) ==# old_candidates
                            endfunction
    1              0.000006 function! deoplete#mapping#_complete() abort
                              if s:check_completion_info(g:deoplete#_context.candidates)
                                return ''
                              endif
                            
                              call complete(g:deoplete#_context.complete_position + 1,
                                    \ g:deoplete#_context.candidates)
                            
                              return ''
                            endfunction
    1              0.000005 function! deoplete#mapping#_prev_complete() abort
                              if s:check_completion_info(g:deoplete#_filtered_prev.candidates)
                                return ''
                              endif
                            
                              call complete(g:deoplete#_filtered_prev.complete_position + 1,
                                    \ g:deoplete#_filtered_prev.candidates)
                            
                              return ''
                            endfunction
    1              0.000005 function! deoplete#mapping#_set_completeopt() abort
                              if exists('g:deoplete#_saved_completeopt')
                                return
                              endif
                              let g:deoplete#_saved_completeopt = &completeopt
                              set completeopt-=longest
                              set completeopt+=menuone
                              set completeopt-=menu
                              if &completeopt !~# 'noinsert\|noselect'
                                set completeopt+=noselect
                              endif
                            endfunction
    1              0.000005 function! deoplete#mapping#_restore_completeopt() abort
                              if exists('g:deoplete#_saved_completeopt')
                                let &completeopt = g:deoplete#_saved_completeopt
                                unlet g:deoplete#_saved_completeopt
                              endif
                            endfunction
    1              0.000006 function! deoplete#mapping#_rpcrequest_wrapper(sources) abort
                              return deoplete#util#rpcnotify(
                                    \ 'deoplete_manual_completion_begin',
                                    \ {
                                    \  'event': 'Manual',
                                    \  'sources': deoplete#util#convert2list(a:sources)
                                    \ })
                            endfunction
    1              0.000005 function! deoplete#mapping#_undo_completion() abort
                              if empty(v:completed_item)
                                return ''
                              endif
                            
                              let input = deoplete#util#get_input('')
                              if strridx(input, v:completed_item.word) !=
                                    \ len(input) - len(v:completed_item.word)
                                return ''
                              endif
                            
                              return deoplete#smart_close_popup() .
                                    \  repeat("\<C-h>", strchars(v:completed_item.word))
                            endfunction
    1              0.000005 function! deoplete#mapping#_complete_common_string() abort
                              if !deoplete#is_enabled()
                                return ''
                              endif
                            
                              " Get cursor word.
                              let prev = g:deoplete#_prev_completion
                              if empty(prev)
                                return ''
                              endif
                            
                              let complete_str = prev.input[prev.complete_position :]
                              let candidates = filter(copy(prev.candidates),
                                    \ 'stridx(tolower(v:val.word), tolower(complete_str)) == 0')
                            
                              if empty(candidates) || complete_str ==# ''
                                return ''
                              endif
                            
                              let common_str = candidates[0].word
                              for candidate in candidates[1:]
                                while stridx(tolower(candidate.word), tolower(common_str)) != 0
                                  let common_str = common_str[: -2]
                                endwhile
                              endfor
                            
                              if common_str ==# '' || complete_str ==? common_str
                                return ''
                              endif
                            
                              return (pumvisible() ? "\<C-e>" : '')
                                    \ . repeat("\<BS>", strchars(complete_str)) . common_str
                            endfunction
    1              0.000006 function! deoplete#mapping#_insert_candidate(number) abort
                              let prev = g:deoplete#_prev_completion
                              let candidates = get(prev, 'candidates', [])
                              let word = get(candidates, a:number, {'word': ''}).word
                              if word ==# ''
                                return ''
                              endif
                            
                              " Get cursor word.
                              let complete_str = prev.input[prev.complete_position :]
                              return (pumvisible() ? "\<C-e>" : '')
                                    \ . repeat("\<BS>", strchars(complete_str)) . word
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/ale/completion.vim
Sourced 1 time
Total time:   0.001547
 Self time:   0.001547

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Completion support for LSP linters
    1              0.000008 scriptencoding utf-8
                            
                            " The omnicompletion menu is shown through a special Plug mapping which is
                            " only valid in Insert mode. This way, feedkeys() won't send these keys if you
                            " quit Insert mode quickly enough.
    1              0.000072 inoremap <silent> <Plug>(ale_show_completion_menu) <C-x><C-o>
                            " If we hit the key sequence in normal mode, then we won't show the menu, so
                            " we should restore the old settings right away.
    1              0.000057 nnoremap <silent> <Plug>(ale_show_completion_menu) :call ale#completion#RestoreCompletionOptions()<CR>
    1              0.000026 cnoremap <silent> <Plug>(ale_show_completion_menu) <Nop>
    1              0.000028 vnoremap <silent> <Plug>(ale_show_completion_menu) <Nop>
    1              0.000025 onoremap <silent> <Plug>(ale_show_completion_menu) <Nop>
                            
    1              0.000080 let g:ale_completion_delay = get(g:, 'ale_completion_delay', 100)
    1              0.000086 let g:ale_completion_excluded_words = get(g:, 'ale_completion_excluded_words', [])
    1              0.000043 let g:ale_completion_max_suggestions = get(g:, 'ale_completion_max_suggestions', 50)
    1              0.000041 let g:ale_completion_tsserver_autoimport = get(g:, 'ale_completion_tsserver_autoimport', 0)
                            
    1              0.000005 let s:timer_id = -1
    1              0.000004 let s:last_done_pos = []
                            
                            " CompletionItemKind values from the LSP protocol.
    1              0.000082 let g:ale_lsp_types = {
                            \ 1: 'text',
                            \ 2: 'method',
                            \ 3: 'function',
                            \ 4: 'constructor',
                            \ 5: 'field',
                            \ 6: 'variable',
                            \ 7: 'class',
                            \ 8: 'interface',
                            \ 9: 'module',
                            \ 10: 'property',
                            \ 11: 'unit',
                            \ 12: 'value',
                            \ 13: 'enum',
                            \ 14: 'keyword',
                            \ 15: 'snippet',
                            \ 16: 'color',
                            \ 17: 'file',
                            \ 18: 'reference',
                            \ 19: 'folder',
                            \ 20: 'enum_member',
                            \ 21: 'constant',
                            \ 22: 'struct',
                            \ 23: 'event',
                            \ 24: 'operator',
                            \ 25: 'type_parameter',
                            \ }
                            
                            " from https://github.com/microsoft/TypeScript/blob/29becf05012bfa7ba20d50b0d16813971e46b8a6/lib/protocol.d.ts#L2472
    1              0.000109 let g:ale_tsserver_types = {
                            \ 'warning': 'text',
                            \ 'keyword': 'keyword',
                            \ 'script': 'file',
                            \ 'module': 'module',
                            \ 'class': 'class',
                            \ 'local class': 'class',
                            \ 'interface': 'interface',
                            \ 'type': 'class',
                            \ 'enum': 'enum',
                            \ 'enum member': 'enum_member',
                            \ 'var': 'variable',
                            \ 'local var': 'variable',
                            \ 'function': 'function',
                            \ 'local function': 'function',
                            \ 'method': 'method',
                            \ 'getter': 'property',
                            \ 'setter': 'method',
                            \ 'property': 'property',
                            \ 'constructor': 'constructor',
                            \ 'call': 'method',
                            \ 'index': 'index',
                            \ 'construct': 'constructor',
                            \ 'parameter': 'parameter',
                            \ 'type parameter': 'type_parameter',
                            \ 'primitive type': 'unit',
                            \ 'label': 'text',
                            \ 'alias': 'class',
                            \ 'const': 'constant',
                            \ 'let': 'variable',
                            \ 'directory': 'folder',
                            \ 'external module name': 'text',
                            \ 'JSX attribute': 'parameter',
                            \ 'string': 'text'
                            \ }
                            
                            " For compatibility reasons, we only use built in VIM completion kinds
                            " See :help complete-items for Vim completion kinds
    1              0.000093 let g:ale_completion_symbols = get(g:, 'ale_completion_symbols', {
                            \ 'text': 'v',
                            \ 'method': 'f',
                            \ 'function': 'f',
                            \ 'constructor': 'f',
                            \ 'field': 'm',
                            \ 'variable': 'v',
                            \ 'class': 't',
                            \ 'interface': 't',
                            \ 'module': 'd',
                            \ 'property': 'm',
                            \ 'unit': 'v',
                            \ 'value': 'v',
                            \ 'enum': 't',
                            \ 'keyword': 'v',
                            \ 'snippet': 'v',
                            \ 'color': 'v',
                            \ 'file': 'v',
                            \ 'reference': 'v',
                            \ 'folder': 'v',
                            \ 'enum_member': 'm',
                            \ 'constant': 'm',
                            \ 'struct': 't',
                            \ 'event': 'v',
                            \ 'operator': 'f',
                            \ 'type_parameter': 'p',
                            \ '<default>': 'v'
                            \ })
                            
    1              0.000006 let s:LSP_INSERT_TEXT_FORMAT_PLAIN = 1
    1              0.000005 let s:LSP_INSERT_TEXT_FORMAT_SNIPPET = 2
                            
    1              0.000005 let s:lisp_regex = '\v[a-zA-Z_\-][a-zA-Z_\-0-9]*$'
                            
                            " Regular expressions for checking the characters in the line before where
                            " the insert cursor is. If one of these matches, we'll check for completions.
    1              0.000026 let s:should_complete_map = {
                            \   '<default>': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$',
                            \   'clojure': s:lisp_regex,
                            \   'lisp': s:lisp_regex,
                            \   'typescript': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$|''$|"$',
                            \   'rust': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$|::$',
                            \   'cpp': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$|\.$|::$|-\>$',
                            \}
                            
                            " Regular expressions for finding the start column to replace with completion.
    1              0.000009 let s:omni_start_map = {
                            \   '<default>': '\v[a-zA-Z$_][a-zA-Z$_0-9]*$',
                            \}
                            
                            " A map of exact characters for triggering LSP completions. Do not forget to
                            " update self.input_patterns in ale.py in updating entries in this map.
    1              0.000019 let s:trigger_character_map = {
                            \   '<default>': ['.'],
                            \   'typescript': ['.', '''', '"'],
                            \   'rust': ['.', '::'],
                            \   'cpp': ['.', '::', '->'],
                            \}
                            
    1              0.000009 function! s:GetFiletypeValue(map, filetype) abort
                                for l:part in reverse(split(a:filetype, '\.'))
                                    let l:regex = get(a:map, l:part, [])
                            
                                    if !empty(l:regex)
                                        return l:regex
                                    endif
                                endfor
                            
                                " Use the default regex for other files.
                                return a:map['<default>']
                            endfunction
                            
                            " Check if we should look for completions for a language.
    1              0.000006 function! ale#completion#GetPrefix(filetype, line, column) abort
                                let l:regex = s:GetFiletypeValue(s:should_complete_map, a:filetype)
                            
                                " The column we're using completions for is where we are inserting text,
                                " like so:
                                "   abc
                                "      ^
                                " So we need check the text in the column before that position.
                                return matchstr(getline(a:line)[: a:column - 2], l:regex)
                            endfunction
                            
    1              0.000005 function! ale#completion#GetTriggerCharacter(filetype, prefix) abort
                                if empty(a:prefix)
                                    return ''
                                endif
                            
                                let l:char_list = s:GetFiletypeValue(s:trigger_character_map, a:filetype)
                            
                                if index(l:char_list, a:prefix) >= 0
                                    return a:prefix
                                endif
                            
                                return ''
                            endfunction
                            
    1              0.000007 function! ale#completion#Filter(buffer, filetype, suggestions, prefix) abort
                                let l:excluded_words = ale#Var(a:buffer, 'completion_excluded_words')
                            
                                if empty(a:prefix)
                                    let l:filtered_suggestions = a:suggestions
                                else
                                    let l:triggers = s:GetFiletypeValue(s:trigger_character_map, a:filetype)
                            
                                    " For completing...
                                    "   foo.
                                    "       ^
                                    " We need to include all of the given suggestions.
                                    if index(l:triggers, a:prefix) >= 0 || empty(a:prefix)
                                        let l:filtered_suggestions = a:suggestions
                                    else
                                        let l:filtered_suggestions = []
                            
                                        " Filter suggestions down to those starting with the prefix we
                                        " used for finding suggestions in the first place.
                                        "
                                        " Some completion tools will include suggestions which don't even
                                        " start with the characters we have already typed.
                                        for l:item in a:suggestions
                                            " A List of String values or a List of completion item
                                            " Dictionaries is accepted here.
                                            let l:word = type(l:item) is v:t_string ? l:item : l:item.word
                            
                                            " Add suggestions if the suggestion starts with a
                                            " case-insensitive match for the prefix.
                                            if l:word[: len(a:prefix) - 1] is? a:prefix
                                                call add(l:filtered_suggestions, l:item)
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if !empty(l:excluded_words)
                                    " Copy the List if needed. We don't want to modify the argument.
                                    " We shouldn't make a copy if we don't need to.
                                    if l:filtered_suggestions is a:suggestions
                                        let l:filtered_suggestions = copy(a:suggestions)
                                    endif
                            
                                    " Remove suggestions with words in the exclusion List.
                                    call filter(
                                    \   l:filtered_suggestions,
                                    \   'index(l:excluded_words, type(v:val) is v:t_string ? v:val : v:val.word) < 0',
                                    \)
                                endif
                            
                                return l:filtered_suggestions
                            endfunction
                            
    1              0.000005 function! s:ReplaceCompletionOptions() abort
                                let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
                            
                                if l:source is# 'ale-automatic' || l:source is# 'ale-manual'
                                    " Remember the old omnifunc value, if there is one.
                                    " If we don't store an old one, we'll just never reset the option.
                                    " This will stop some random exceptions from appearing.
                                    if !exists('b:ale_old_omnifunc') && !empty(&l:omnifunc)
                                        let b:ale_old_omnifunc = &l:omnifunc
                                    endif
                            
                                    let &l:omnifunc = 'ale#completion#AutomaticOmniFunc'
                                endif
                            
                                if l:source is# 'ale-automatic'
                                    if !exists('b:ale_old_completeopt')
                                        let b:ale_old_completeopt = &l:completeopt
                                    endif
                            
                                    if &l:completeopt =~# 'preview'
                                        let &l:completeopt = 'menu,menuone,preview,noselect,noinsert'
                                    elseif &l:completeopt =~# 'popup'
                                        let &l:completeopt = 'menu,menuone,popup,noselect,noinsert'
                                    else
                                        let &l:completeopt = 'menu,menuone,noselect,noinsert'
                                    endif
                                endif
                            endfunction
                            
    1              0.000004 function! ale#completion#RestoreCompletionOptions() abort
                                " Reset settings when completion is done.
                                if exists('b:ale_old_omnifunc')
                                    if b:ale_old_omnifunc isnot# 'pythoncomplete#Complete'
                                        let &l:omnifunc = b:ale_old_omnifunc
                                    endif
                            
                                    unlet b:ale_old_omnifunc
                                endif
                            
                                if exists('b:ale_old_completeopt')
                                    let &l:completeopt = b:ale_old_completeopt
                                    unlet b:ale_old_completeopt
                                endif
                            endfunction
                            
    1              0.000002 function! ale#completion#GetCompletionPosition() abort
                                if !exists('b:ale_completion_info')
                                    return 0
                                endif
                            
                                let l:line = b:ale_completion_info.line
                                let l:column = b:ale_completion_info.column
                                let l:regex = s:GetFiletypeValue(s:omni_start_map, &filetype)
                                let l:up_to_column = getline(l:line)[: l:column - 2]
                                let l:match = matchstr(l:up_to_column, l:regex)
                            
                                return l:column - len(l:match) - 1
                            endfunction
                            
    1              0.000003 function! ale#completion#GetCompletionPositionForDeoplete(input) abort
                                return match(a:input, '\k*$')
                            endfunction
                            
    1              0.000002 function! ale#completion#GetCompletionResult() abort
                                if exists('b:ale_completion_result')
                                    return b:ale_completion_result
                                endif
                            
                                return v:null
                            endfunction
                            
    1              0.000003 function! ale#completion#AutomaticOmniFunc(findstart, base) abort
                                if a:findstart
                                    return ale#completion#GetCompletionPosition()
                                else
                                    let l:result = ale#completion#GetCompletionResult()
                            
                                    call s:ReplaceCompletionOptions()
                            
                                    return l:result isnot v:null ? l:result : []
                                endif
                            endfunction
                            
    1              0.000002 function! ale#completion#Show(result) abort
                                if ale#util#Mode() isnot# 'i'
                                    return
                                endif
                            
                                " Set the list in the buffer, temporarily replace omnifunc with our
                                " function, and then start omni-completion.
                                let b:ale_completion_result = a:result
                            
                                " Don't try to open the completion menu if there's nothing to show.
                                if empty(b:ale_completion_result)
                                    return
                                endif
                            
                                " Replace completion options shortly before opening the menu.
                                call s:ReplaceCompletionOptions()
                            
                                let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
                            
                                if l:source is# 'ale-automatic' || l:source is# 'ale-manual'
                                    call timer_start(
                                    \   0,
                                    \   {-> ale#util#FeedKeys("\<Plug>(ale_show_completion_menu)")}
                                    \)
                                endif
                            
                                if l:source is# 'ale-callback'
                                    call b:CompleteCallback(b:ale_completion_result)
                                endif
                            endfunction
                            
    1              0.000002 function! ale#completion#GetAllTriggers() abort
                                return deepcopy(s:trigger_character_map)
                            endfunction
                            
    1              0.000002 function! ale#completion#GetCompletionKind(kind) abort
                                let l:lsp_symbol = get(g:ale_lsp_types, a:kind, '')
                            
                                if !empty(l:lsp_symbol)
                                    return l:lsp_symbol
                                endif
                            
                                return get(g:ale_tsserver_types, a:kind, '')
                            endfunction
                            
    1              0.000002 function! ale#completion#GetCompletionSymbols(kind) abort
                                let l:kind = ale#completion#GetCompletionKind(a:kind)
                                let l:symbol = get(g:ale_completion_symbols, l:kind, '')
                            
                                if !empty(l:symbol)
                                    return l:symbol
                                endif
                            
                                return get(g:ale_completion_symbols, '<default>', 'v')
                            endfunction
                            
    1              0.000003 function! s:CompletionStillValid(request_id) abort
                                let [l:line, l:column] = getpos('.')[1:2]
                            
                                return ale#util#Mode() is# 'i'
                                \&& has_key(b:, 'ale_completion_info')
                                \&& b:ale_completion_info.request_id == a:request_id
                                \&& b:ale_completion_info.line == l:line
                                \&& (
                                \   b:ale_completion_info.column == l:column
                                \   || b:ale_completion_info.source is# 'ale-omnifunc'
                                \   || b:ale_completion_info.source is# 'ale-callback'
                                \)
                            endfunction
                            
    1              0.000003 function! ale#completion#ParseTSServerCompletions(response) abort
                                let l:names = []
                            
                                for l:suggestion in a:response.body
                                    call add(l:names, {
                                    \ 'word': l:suggestion.name,
                                    \ 'source': get(l:suggestion, 'source', ''),
                                    \})
                                endfor
                            
                                return l:names
                            endfunction
                            
    1              0.000003 function! ale#completion#ParseTSServerCompletionEntryDetails(response) abort
                                let l:buffer = bufnr('')
                                let l:results = []
                                let l:names_with_details = []
                            
                                for l:suggestion in a:response.body
                                    let l:displayParts = []
                            
                                    for l:action in get(l:suggestion, 'codeActions', [])
                                        call add(l:displayParts, l:action.description . ' ')
                                    endfor
                            
                                    for l:part in l:suggestion.displayParts
                                        call add(l:displayParts, l:part.text)
                                    endfor
                            
                                    " Each one of these parts has 'kind' properties
                                    let l:documentationParts = []
                            
                                    for l:part in get(l:suggestion, 'documentation', [])
                                        call add(l:documentationParts, l:part.text)
                                    endfor
                            
                                    " See :help complete-items
                                    let l:result = {
                                    \   'word': l:suggestion.name,
                                    \   'kind': ale#completion#GetCompletionSymbols(l:suggestion.kind),
                                    \   'icase': 1,
                                    \   'menu': join(l:displayParts, ''),
                                    \   'dup': g:ale_completion_tsserver_autoimport,
                                    \   'info': join(l:documentationParts, ''),
                                    \}
                            
                                    if has_key(l:suggestion, 'codeActions')
                                        let l:result.user_data = json_encode({
                                        \   'codeActions': l:suggestion.codeActions,
                                        \ })
                                    endif
                            
                                    call add(l:results, l:result)
                                endfor
                            
                                let l:names = getbufvar(l:buffer, 'ale_tsserver_completion_names', [])
                            
                                if !empty(l:names) && len(l:names) != len(l:results)
                                    let l:names_with_details = map(copy(l:results), 'v:val.word')
                                    let l:missing_names = filter(
                                    \   copy(l:names),
                                    \   'index(l:names_with_details, v:val.word) < 0',
                                    \)
                            
                                    for l:name in l:missing_names
                                        call add(l:results, {
                                        \   'word': l:name.word,
                                        \   'kind': 'v',
                                        \   'icase': 1,
                                        \   'menu': '',
                                        \   'info': '',
                                        \})
                                    endfor
                                endif
                            
                                return l:results
                            endfunction
                            
    1              0.000003 function! ale#completion#NullFilter(buffer, item) abort
                                return 1
                            endfunction
                            
    1              0.000002 function! ale#completion#ParseLSPCompletions(response) abort
                                let l:buffer = bufnr('')
                                let l:info = get(b:, 'ale_completion_info', {})
                                let l:Filter = get(l:info, 'completion_filter', v:null)
                            
                                if l:Filter is v:null
                                    let l:Filter = function('ale#completion#NullFilter')
                                else
                                    let l:Filter = ale#util#GetFunction(l:Filter)
                                endif
                            
                                let l:item_list = []
                            
                                if type(get(a:response, 'result')) is v:t_list
                                    let l:item_list = a:response.result
                                elseif type(get(a:response, 'result')) is v:t_dict
                                \&& type(get(a:response.result, 'items')) is v:t_list
                                    let l:item_list = a:response.result.items
                                endif
                            
                                let l:results = []
                            
                                for l:item in l:item_list
                                    if !call(l:Filter, [l:buffer, l:item])
                                        continue
                                    endif
                            
                                    if get(l:item, 'insertTextFormat') is s:LSP_INSERT_TEXT_FORMAT_PLAIN
                                    \&& type(get(l:item, 'textEdit')) is v:t_dict
                                        let l:text = l:item.textEdit.newText
                                    elseif type(get(l:item, 'insertText')) is v:t_string
                                        let l:text = l:item.insertText
                                    else
                                        let l:text = l:item.label
                                    endif
                            
                                    let l:word = matchstr(l:text, '\v^[^(]+')
                            
                                    if empty(l:word)
                                        continue
                                    endif
                            
                                    let l:doc = get(l:item, 'documentation', '')
                            
                                    if type(l:doc) is v:t_dict && has_key(l:doc, 'value')
                                        let l:doc = l:doc.value
                                    endif
                            
                                    call add(l:results, {
                                    \   'word': l:word,
                                    \   'kind': ale#completion#GetCompletionSymbols(get(l:item, 'kind', '')),
                                    \   'icase': 1,
                                    \   'menu': get(l:item, 'detail', ''),
                                    \   'info': (type(l:doc) is v:t_string ? l:doc : ''),
                                    \})
                                endfor
                            
                                if has_key(l:info, 'prefix')
                                    let l:results = ale#completion#Filter(l:buffer, &filetype, l:results, l:info.prefix)
                                endif
                            
                                return l:results[: g:ale_completion_max_suggestions - 1]
                            endfunction
                            
    1              0.000003 function! ale#completion#HandleTSServerResponse(conn_id, response) abort
                                if !s:CompletionStillValid(get(a:response, 'request_seq'))
                                    return
                                endif
                            
                                if !has_key(a:response, 'body')
                                    return
                                endif
                            
                                let l:buffer = bufnr('')
                                let l:command = get(a:response, 'command', '')
                            
                                if l:command is# 'completions'
                                    let l:names = ale#completion#Filter(
                                    \   l:buffer,
                                    \   &filetype,
                                    \   ale#completion#ParseTSServerCompletions(a:response),
                                    \   b:ale_completion_info.prefix,
                                    \)[: g:ale_completion_max_suggestions - 1]
                            
                                    " We need to remember some names for tsserver, as it doesn't send
                                    " details back for everything we send.
                                    call setbufvar(l:buffer, 'ale_tsserver_completion_names', l:names)
                            
                                    if !empty(l:names)
                                        let l:identifiers = []
                            
                                        for l:name in l:names
                                            let l:identifier = {
                                            \   'name': l:name.word,
                                            \}
                                            let l:source = get(l:name, 'source', '')
                            
                                            " Empty source results in no details for the completed item
                                            if !empty(l:source)
                                                call extend(l:identifier, { 'source': l:source })
                                            endif
                            
                                            call add(l:identifiers, l:identifier)
                                        endfor
                            
                                        let b:ale_completion_info.request_id = ale#lsp#Send(
                                        \   b:ale_completion_info.conn_id,
                                        \   ale#lsp#tsserver_message#CompletionEntryDetails(
                                        \       l:buffer,
                                        \       b:ale_completion_info.line,
                                        \       b:ale_completion_info.column,
                                        \       l:identifiers,
                                        \   ),
                                        \)
                                    endif
                                elseif l:command is# 'completionEntryDetails'
                                    call ale#completion#Show(
                                    \   ale#completion#ParseTSServerCompletionEntryDetails(a:response),
                                    \)
                                endif
                            endfunction
                            
                            
    1              0.000003 function! ale#completion#HandleLSPResponse(conn_id, response) abort
                                if !s:CompletionStillValid(get(a:response, 'id'))
                                    return
                                endif
                            
                                call ale#completion#Show(
                                \   ale#completion#ParseLSPCompletions(a:response),
                                \)
                            endfunction
                            
    1              0.000003 function! s:OnReady(linter, lsp_details) abort
                                let l:id = a:lsp_details.connection_id
                            
                                if !ale#lsp#HasCapability(l:id, 'completion')
                                    return
                                endif
                            
                                let l:buffer = a:lsp_details.buffer
                            
                                " If we have sent a completion request already, don't send another.
                                if b:ale_completion_info.request_id
                                    return
                                endif
                            
                                let l:Callback = a:linter.lsp is# 'tsserver'
                                \   ? function('ale#completion#HandleTSServerResponse')
                                \   : function('ale#completion#HandleLSPResponse')
                                call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                if a:linter.lsp is# 'tsserver'
                                    let l:message = ale#lsp#tsserver_message#Completions(
                                    \   l:buffer,
                                    \   b:ale_completion_info.line,
                                    \   b:ale_completion_info.column,
                                    \   b:ale_completion_info.prefix,
                                    \   g:ale_completion_tsserver_autoimport,
                                    \)
                                else
                                    " Send a message saying the buffer has changed first, otherwise
                                    " completions won't know what text is nearby.
                                    call ale#lsp#NotifyForChanges(l:id, l:buffer)
                            
                                    " For LSP completions, we need to clamp the column to the length of
                                    " the line. python-language-server and perhaps others do not implement
                                    " this correctly.
                                    let l:message = ale#lsp#message#Completion(
                                    \   l:buffer,
                                    \   b:ale_completion_info.line,
                                    \   b:ale_completion_info.column,
                                    \   ale#completion#GetTriggerCharacter(&filetype, b:ale_completion_info.prefix),
                                    \)
                                endif
                            
                                let l:request_id = ale#lsp#Send(l:id, l:message)
                            
                                if l:request_id
                                    let b:ale_completion_info.conn_id = l:id
                                    let b:ale_completion_info.request_id = l:request_id
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let b:ale_completion_info.completion_filter = a:linter.completion_filter
                                    endif
                                endif
                            endfunction
                            
                            " This function can be called to check if ALE can provide completion data for
                            " the current buffer. 1 will be returned if there's a potential source of
                            " completion data ALE can use, and 0 will be returned otherwise.
    1              0.000002 function! ale#completion#CanProvideCompletions() abort
                                for l:linter in ale#linter#Get(&filetype)
                                    if !empty(l:linter.lsp)
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction
                            
                            " This function can be used to manually trigger autocomplete, even when
                            " g:ale_completion_enabled is set to false
    1              0.000002 function! ale#completion#GetCompletions(...) abort
                                let l:source = get(a:000, 0, '')
                                let l:options = get(a:000, 1, {})
                            
                                if len(a:000) > 2
                                    throw 'Too many arguments!'
                                endif
                            
                                let l:CompleteCallback = get(l:options, 'callback', v:null)
                            
                                if l:CompleteCallback isnot v:null
                                    let b:CompleteCallback = l:CompleteCallback
                                endif
                            
                                let [l:line, l:column] = getpos('.')[1:2]
                            
                                let l:prefix = ale#completion#GetPrefix(&filetype, l:line, l:column)
                            
                                if l:source is# 'ale-automatic' && empty(l:prefix)
                                    return 0
                                endif
                            
                                let l:line_length = len(getline('.'))
                            
                                let b:ale_completion_info = {
                                \   'line': l:line,
                                \   'line_length': l:line_length,
                                \   'column': l:column,
                                \   'prefix': l:prefix,
                                \   'conn_id': 0,
                                \   'request_id': 0,
                                \   'source': l:source,
                                \}
                                unlet! b:ale_completion_result
                            
                                let l:buffer = bufnr('')
                                let l:Callback = function('s:OnReady')
                            
                                let l:started = 0
                            
                                for l:linter in ale#linter#Get(&filetype)
                                    if !empty(l:linter.lsp)
                                        if ale#lsp_linter#StartLSP(l:buffer, l:linter, l:Callback)
                                            let l:started = 1
                                        endif
                                    endif
                                endfor
                            
                                return l:started
                            endfunction
                            
    1              0.000003 function! ale#completion#OmniFunc(findstart, base) abort
                                if a:findstart
                                    let l:started = ale#completion#GetCompletions('ale-omnifunc')
                            
                                    if !l:started
                                        " This is the special value for cancelling completions silently.
                                        " See :help complete-functions
                                        return -3
                                    endif
                            
                                    return ale#completion#GetCompletionPosition()
                                else
                                    let l:result = ale#completion#GetCompletionResult()
                            
                                    while l:result is v:null && !complete_check()
                                        sleep 2ms
                                        let l:result = ale#completion#GetCompletionResult()
                                    endwhile
                            
                                    return l:result isnot v:null ? l:result : []
                                endif
                            endfunction
                            
    1              0.000002 function! s:TimerHandler(...) abort
                                if !get(b:, 'ale_completion_enabled', g:ale_completion_enabled)
                                    return
                                endif
                            
                                let s:timer_id = -1
                            
                                let [l:line, l:column] = getpos('.')[1:2]
                            
                                " When running the timer callback, we have to be sure that the cursor
                                " hasn't moved from where it was when we requested completions by typing.
                                if s:timer_pos == [l:line, l:column] && ale#util#Mode() is# 'i'
                                    call ale#completion#GetCompletions('ale-automatic')
                                endif
                            endfunction
                            
                            " Stop any completion timer that is queued. This is useful for tests.
    1              0.000002 function! ale#completion#StopTimer() abort
                                if s:timer_id != -1
                                    call timer_stop(s:timer_id)
                                endif
                            
                                let s:timer_id = -1
                            endfunction
                            
    1              0.000002 function! ale#completion#Queue() abort
                                if !get(b:, 'ale_completion_enabled', g:ale_completion_enabled)
                                    return
                                endif
                            
                                let s:timer_pos = getpos('.')[1:2]
                            
                                if s:timer_pos == s:last_done_pos
                                    " Do not ask for completions if the cursor rests on the position we
                                    " last completed on.
                                    return
                                endif
                            
                                " If we changed the text again while we're still waiting for a response,
                                " then invalidate the requests before the timer ticks again.
                                if exists('b:ale_completion_info')
                                    let b:ale_completion_info.request_id = 0
                                endif
                            
                                call ale#completion#StopTimer()
                            
                                let s:timer_id = timer_start(g:ale_completion_delay, function('s:TimerHandler'))
                            endfunction
                            
    1              0.000002 function! ale#completion#HandleUserData(completed_item) abort
                                let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
                            
                                if l:source isnot# 'ale-automatic'
                                \&& l:source isnot# 'ale-manual'
                                \&& l:source isnot# 'ale-callback'
                                    return
                                endif
                            
                                let l:user_data_json = get(a:completed_item, 'user_data', '')
                            
                                if empty(l:user_data_json)
                                    return
                                endif
                            
                                let l:user_data = json_decode(l:user_data_json)
                            
                                if type(l:user_data) isnot v:t_dict
                                    return
                                endif
                            
                                for l:code_action in get(l:user_data, 'codeActions', [])
                                    call ale#code_action#HandleCodeAction(l:code_action)
                                endfor
                            endfunction
                            
    1              0.000002 function! ale#completion#Done() abort
                                silent! pclose
                            
                                call ale#completion#RestoreCompletionOptions()
                            
                                let s:last_done_pos = getpos('.')[1:2]
                            endfunction
                            
    1              0.000009 augroup ALECompletionActions
    1              0.000016     autocmd CompleteDone * call ale#completion#HandleUserData(v:completed_item)
    1              0.000001 augroup END
                            
    1              0.000003 function! s:Setup(enabled) abort
                                augroup ALECompletionGroup
                                    autocmd!
                            
                                    if a:enabled
                                        autocmd TextChangedI * call ale#completion#Queue()
                                        autocmd CompleteDone * call ale#completion#Done()
                                    endif
                                augroup END
                            
                                if !a:enabled
                                    augroup! ALECompletionGroup
                                endif
                            endfunction
                            
    1              0.000002 function! ale#completion#Enable() abort
                                let g:ale_completion_enabled = 1
                                call s:Setup(1)
                            endfunction
                            
    1              0.000002 function! ale#completion#Disable() abort
                                let g:ale_completion_enabled = 0
                                call s:Setup(0)
                            endfunction

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.170837
 Self time:   0.000272

count  total (s)   self (s)
    1              0.000011 if exists("b:did_autoload_ultisnips") || !exists("g:_uspy")
                                finish
    1              0.000001 endif
    1              0.000004 let b:did_autoload_ultisnips = 1
                            
                            " Also import vim as we expect it to be imported in many places.
    1   0.139343   0.000032 exec g:_uspy "import vim"
    1   0.031304   0.000050 exec g:_uspy "from UltiSnips import UltiSnips_Manager"
                            
    1              0.000008 function! s:compensate_for_pum() abort
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    exec g:_uspy "UltiSnips_Manager._cursor_moved()"
                                endif
                            endfunction
                            
    1              0.000003 function! UltiSnips#Edit(bang, ...) abort
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                exec g:_uspy "vim.command(\"let file = '%s'\" % UltiSnips_Manager._file_to_edit(vim.eval(\"type\"), vim.eval('a:bang')))"
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'tabdo'
                                        let mode = 'tabedit'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000003 function! UltiSnips#AddFiletypes(filetypes) abort
                                exec g:_uspy "UltiSnips_Manager.add_buffer_filetypes('" . a:filetypes . "')"
                                return ""
                            endfunction
                            
    1              0.000003 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos) abort
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000002 function! UltiSnips#ExpandSnippet() abort
                                exec g:_uspy "UltiSnips_Manager.expand()"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#ExpandSnippetOrJump() abort
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.expand_or_jump()"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#ListSnippets() abort
                                exec g:_uspy "UltiSnips_Manager.list_snippets()"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#SnippetsInCurrentScope(...) abort
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000002 function! UltiSnips#SaveLastVisualSelection() range abort
                                exec g:_uspy "UltiSnips_Manager._save_last_visual_selection()"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#JumpBackwards() abort
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.jump_backwards()"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#JumpForwards() abort
                                call s:compensate_for_pum()
                                exec g:_uspy "UltiSnips_Manager.jump_forwards()"
                                return ""
                            endfunction
                            
    1              0.000003 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority) abort
                                exec g:_uspy "trigger = vim.eval(\"a:trigger\")"
                                exec g:_uspy "value = vim.eval(\"a:value\")"
                                exec g:_uspy "description = vim.eval(\"a:description\")"
                                exec g:_uspy "options = vim.eval(\"a:options\")"
                                exec g:_uspy "filetype = vim.eval(\"a:filetype\")"
                                exec g:_uspy "priority = vim.eval(\"a:priority\")"
                                exec g:_uspy "UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#Anon(value, ...) abort
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                exec g:_uspy "args = vim.eval(\"a:000\")"
                                exec g:_uspy "value = vim.eval(\"a:value\")"
                                exec g:_uspy "UltiSnips_Manager.expand_anon(value, *args)"
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#CursorMoved() abort
                                exec g:_uspy "UltiSnips_Manager._cursor_moved()"
                            endf
                            
    1              0.000002 function! UltiSnips#LeavingBuffer() abort
                                exec g:_uspy "UltiSnips_Manager._leaving_buffer()"
                            endf
                            
    1              0.000002 function! UltiSnips#LeavingInsertMode() abort
                                exec g:_uspy "UltiSnips_Manager._leaving_insert_mode()"
                            endfunction
                            
    1              0.000002 function! UltiSnips#TrackChange() abort
                                exec g:_uspy "UltiSnips_Manager._track_change()"
                            endfunction
                            
    1              0.000002 function! UltiSnips#RefreshSnippets() abort
                                exec g:_uspy "UltiSnips_Manager._refresh_snippets()"
                            endfunction
                            " }}}

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax_checkers/json/jsonlint.vim
Sourced 1 time
Total time:   0.000854
 Self time:   0.000385

count  total (s)   self (s)
                            "============================================================================
                            "File:        jsonlint.vim
                            "Description: JSON syntax checker - using jsonlint
                            "Maintainer:  Miller Medeiros <contact at millermedeiros dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000016 if exists('g:loaded_syntastic_json_jsonlint_checker')
                                finish
    1              0.000002 endif
    1              0.000151 let g:loaded_syntastic_json_jsonlint_checker = 1
                            
    1              0.000023 let s:save_cpo = &cpo
    1              0.000032 set cpo&vim
                            
    1              0.000009 function! SyntaxCheckers_json_jsonlint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'post_args_after': '--compact' })
                            
                                let errorformat =
                                    \ '%ELine %l:%c,'.
                                    \ '%Z\\s%#Reason: %m,'.
                                    \ '%C%.%#,'.
                                    \ '%f: line %l\, col %c\, %m,'.
                                    \ '%-G%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')} })
                            endfunction
                            
    1   0.000501   0.000031 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'json',
                                \ 'name': 'jsonlint'})
                            
    1              0.000018 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax_checkers/json/jsonval.vim
Sourced 1 time
Total time:   0.000721
 Self time:   0.000318

count  total (s)   self (s)
                            "============================================================================
                            "File:        jsonval.vim
                            "Description: JSON syntax checker - using jsonval
                            "Maintainer:  Miller Medeiros <contact at millermedeiros dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000013 if exists('g:loaded_syntastic_json_jsonval_checker')
                                finish
    1              0.000002 endif
    1              0.000133 let g:loaded_syntastic_json_jsonval_checker = 1
                            
    1              0.000014 let s:save_cpo = &cpo
    1              0.000021 set cpo&vim
                            
    1              0.000008 function! SyntaxCheckers_json_jsonval_GetLocList() dict
                                " based on https://gist.github.com/1196345
                                let makeprg = self.makeprgBuild({})
                            
                                let errorformat =
                                    \ '%E%f: %m at line %l,' .
                                    \ '%-G%.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')} })
                            endfunction
                            
    1   0.000429   0.000026 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'json',
                                \ 'name': 'jsonval'})
                            
    1              0.000021 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/ajs/config/nvim/.cache/init.vim/.dein/syntax/leaderGuide.vim
Sourced 1 time
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000007 if exists("b:current_syntax")
                                finish
    1              0.000001 endif
    1              0.000002 let b:current_syntax = "leaderguide"
                            
    1              0.000033 syn region LeaderGuideKeys start="\["hs=e+1 end="\]\s"he=s-1
                                        \ contained
    1              0.000017 syn region LeaderGuideBrackets start="\(^\|\s\+\)\[" end="\]\s\+"
                                        \ contains=LeaderGuideKeys keepend
    1              0.000012 syn region LeaderGuideDesc start="^" end="$"
                                        \ contains=LeaderGuideBrackets
                            
    1              0.000007 hi def link LeaderGuideDesc Identifier
    1              0.000005 hi def link LeaderGuideKeys Type
    1              0.000008 hi def link LeaderGuideBrackets Delimiter

FUNCTION  <SNR>186_render()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 36
Called 46 times
Total time:   0.026173
 Self time:   0.014872

count  total (s)   self (s)
   46              0.000269   if type(a:var) == type('')
    1              0.000002     return a:var
   45              0.000051   endif
                            
   45              0.000191   if type(a:var) == type({})
   21              0.000072     let text = a:var.label
   21              0.000080     if !empty(a:var.highlight)
    3              0.000023       let text = '%#'.a:var.highlight.'#'.text.'%##'
   21              0.000024     endif
   21              0.000213     if has('tablineat') && g:wintabs_display == 'tabline'
                                  if a:var.type == 'buffer'
                                    let text = '%'.a:var.number.'@wintabs#element#buffer_click@'.text.'%X'
                                  elseif a:var.type == 'tab'
                                    let text = '%'.a:var.number.'@wintabs#element#tab_click@'.text.'%X'
                                  elseif a:var.type == 'left_arrow'
                                    let text = '%@wintabs#element#left_arrow_click@'.text.'%X'
                                  elseif a:var.type == 'right_arrow'
                                    let text = '%@wintabs#element#right_arrow_click@'.text.'%X'
                                  endif
   21              0.000025     else
   21              0.000060       if a:var.type == 'tab'
                                    let text = '%'.a:var.number.'T'.text.'%T'
   21              0.000022       endif
   21              0.000022     endif
   21              0.000046     return text
   24              0.000022   endif
                            
   24              0.000107   if type(a:var) == type([])
   24              0.000060     let text = ''
   69   0.004619   0.002489     for element in s:merge_higroup(a:var)
   45   0.002110   0.001606       let text = text.wintabs#element#render(element)
   69              0.000107     endfor
   24              0.000050     return text
                              endif
                            
                              return ''

FUNCTION  <SNR>25_winclose()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 422
Called 2 times
Total time:   0.000983
 Self time:   0.000681

count  total (s)   self (s)
    2              0.000064     noautocmd execute s:gwin.'wincmd w'
    2              0.000012     if s:gwin == winnr()
    2   0.000101   0.000040         close
    2              0.000077         exe s:winres
    2              0.000012         let s:gwin = -1
    2              0.000078         noautocmd execute s:winnr.'wincmd w'
    2              0.000022         call winrestview(s:winv)
    2              0.000004     endif

FUNCTION  <SNR>140_Lint()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 99
Called 52 times
Total time:   0.341906
 Self time:   0.013433

count  total (s)   self (s)
                                " Use the filetype from the buffer
   52              0.000387     let l:filetype = getbufvar(a:buffer, '&filetype')
   52   0.038844   0.001019     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
   52   0.001761   0.000761     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
   52   0.001225   0.000471     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
   52              0.000518     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
   52              0.003139     let g:ale_want_results_buffer = a:buffer
   52   0.001295   0.001142     silent doautocmd <nomodeline> User ALEWantResults
   52              0.002915     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   52              0.000402     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
   52              0.000050     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
   52              0.000492     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
   52   0.289972   0.001229     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  wintabs#ui#set_statusline()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 16
Called 29 times
Total time:   0.001985
 Self time:   0.001985

count  total (s)   self (s)
   83              0.000535   for window in range(1, winnr('$'))
   54              0.000975     call setwinvar(window, '&statusline', '%!wintabs#ui#get_statusline('.window.')')
   83              0.000215   endfor

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 143
Called 5 times
Total time:   0.012481
 Self time:   0.000399

count  total (s)   self (s)
    5              0.000028     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    5              0.000010     if empty(l:info)
                                    return
    5              0.000003     endif
                            
    5              0.000008     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    5              0.000021         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    5              0.000003     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    5   0.001293   0.000078     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    5              0.000028     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    5              0.000011     if !empty(l:linter_loclist)
                                    " Add the new items.
    2              0.000006         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    2              0.000007         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    5              0.000003     endif
                            
    5   0.000926   0.000047     if ale#ShouldDoNothing(a:buffer)
                                    return
    5              0.000002     endif
                            
    5   0.010053   0.000065     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  gitgutter#utility#file()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 87
Called 1 time
Total time:   0.000386
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000385   0.000019   return s:abs_path(a:bufnr, 1)

FUNCTION  <SNR>181_on_insert_leave()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 287
Called 47 times
Total time:   0.006073
 Self time:   0.002464

count  total (s)   self (s)
   47   0.003484   0.001094   call deoplete#mapping#_restore_completeopt()
   47              0.000469   let g:deoplete#_context = {}
   47   0.001982   0.000762   call deoplete#init#_prev_completion()

FUNCTION  syntastic#log#debug()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/log.vim line 63
Called 78 times
Total time:   0.001933
 Self time:   0.001441

count  total (s)   self (s)
   78   0.001718   0.001226     if !s:_isDebugEnabled(a:level)
   78              0.000122         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  <lambda>81()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000056
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000055   0.000042 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>263_highlight_cursor()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 836
Called 20 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
                              " Give cursor highlight high priority, to overrule visual selection
   20              0.000395   return matchadd(s:hi_group_cursor, '\%'.a:pos[0].'l\%'.a:pos[1].'c', 99999)

FUNCTION  remote#host#Require()
    Defined: /usr/share/nvim/runtime/autoload/remote/host.vim line 33
Called 4 times
Total time:   1.989303
 Self time:   0.000375

count  total (s)   self (s)
    4              0.000036   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    4              0.000004   endif
    4              0.000023   let host = s:hosts[a:name]
    4              0.000011   if !host.channel && !host.initialized
    2              0.000012     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
    2   1.989130   0.000202     let host.channel = call(host.factory, [host_info])
    2              0.000007     let host.initialized = 1
    4              0.000003   endif
    4              0.000012   return host.channel

FUNCTION  <lambda>89()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000028
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>262_HandleESLintOutput()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 223
Called 5 times
Total time:   0.002825
 Self time:   0.000546

count  total (s)   self (s)
    5   0.001664   0.000068     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
    5              0.000003     endif
                            
    5              0.000016     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
    5              0.000003     endif
                            
    5              0.000009     if a:type is# 'json'
    5   0.000564   0.000077         let l:output = s:parseJSON(a:buffer, a:lines)
                                else
                                    let l:output = s:parseLines(a:buffer, a:lines)
    5              0.000003     endif
                            
    5   0.000239   0.000127     call filter(l:output, {idx, obj -> s:FilterResult(a:buffer, obj)})
                            
    5              0.000068     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
    5   0.000156   0.000071         call s:AddHintsForTypeScriptParsingErrors(l:output)
    5              0.000003     endif
                            
    5              0.000007     return l:output

FUNCTION  <SNR>151_ExtendLineList()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 608
Called 99 times
Total time:   0.007684
 Self time:   0.007684

count  total (s)   self (s)
   99              0.000541     let nchanged = a:insert_end - a:insert_start + 1
   99              0.000517     let delta_lines = line('$') - len(a:list)
                            
   99              0.000322     let b1 = a:insert_start-2
   99              0.000320     let b2 = a:insert_end-delta_lines
                            
   99              0.000319     let push_front = b1 >= 0
   99              0.000418     let push_back = b2 <= len(a:list) - 1
                            
   99              0.000263     if push_front && push_back
   66              0.002826         return a:list[ : b1] + repeat([0], nchanged) + a:list[b2 : ]
   33              0.000070     elseif push_front
                                    return a:list[ : b1] + repeat([0], nchanged)
   33              0.000056     elseif push_back
    5              0.000517         return repeat([0], nchanged) + a:list[b2 : ]
   28              0.000034     else
   28              0.000498         return repeat([0], nchanged)
                                endif
                            

FUNCTION  gitgutter#all()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter.vim line 5
Called 2 times
Total time:   0.046067
 Self time:   0.006259

count  total (s)   self (s)
    2              0.000024   let visible = tabpagebuflist()
                            
   66              0.000401   for bufnr in range(1, bufnr('$') + 1)
   64              0.000293     if buflisted(bufnr)
   58              0.002539       let file = expand('#'.bufnr.':p')
   58              0.000296       if !empty(file)
   58              0.000343         if index(visible, bufnr) != -1
    2   0.008176   0.000079           call gitgutter#init_buffer(bufnr)
    2   0.029589   0.000113           call gitgutter#process_buffer(bufnr, a:force)
   56              0.000147         elseif a:force
   28   0.002773   0.000537           call s:reset_tick(bufnr)
   58              0.000086         endif
   58              0.000064       endif
   64              0.000069     endif
   66              0.000185   endfor

FUNCTION  dein#util#_get_lazy_plugins()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/util.vim line 601
Called 20 times
Total time:   0.003286
 Self time:   0.003286

count  total (s)   self (s)
   20              0.003242   return filter(values(g:dein#_plugins), "!v:val.sourced && v:val.rtp !=# ''")

FUNCTION  <SNR>47_refreshRoot()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree/ui_glue.vim line 536
Called 1 time
Total time:   2.391179
 Self time:   0.007985

count  total (s)   self (s)
    1   0.000385   0.000023     if !g:NERDTree.IsOpen()
                                    return
    1              0.000002     endif
    1   0.000157   0.000027     call nerdtree#echo("Refreshing the root node. This could take a while...")
                            
    1              0.000013     let l:curWin = winnr()
    1   0.000663   0.000051     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")
    1   2.250339   0.000050     call b:NERDTree.root.refresh()
    1   0.130249   0.000014     call b:NERDTree.render()
    1              0.007771     redraw
    1   0.000096   0.000008     call nerdtree#exec(l:curWin . "wincmd w")
    1   0.001486   0.000008     call nerdtree#echo("")

FUNCTION  <SNR>158_StopCurrentJobs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 547
Called 52 times
Total time:   0.008968
 Self time:   0.002421

count  total (s)   self (s)
   52              0.000320     let l:info = get(g:ale_buffer_info, a:buffer, {})
   52   0.007278   0.000773     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
   52              0.000139     if a:clear_lint_file_jobs
    1   0.000059   0.000016         call ale#command#StopJobs(a:buffer, 'file_linter')
    1              0.000005         let l:info.active_linter_list = []
   51              0.000054     else
                                    " Keep jobs for linting files when we're only linting buffers.
   51              0.000554         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
   52              0.000054     endif

FUNCTION  gitgutter#process_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter.vim line 36
Called 12 times
Total time:   0.061023
 Self time:   0.001605

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   12   0.005218   0.000251   if gitgutter#utility#is_active(a:bufnr)
    7   0.000430   0.000151     if a:force || s:has_fresh_changes(a:bufnr)
                            
    4              0.000018       let diff = ''
    4              0.000011       try
    4   0.052208   0.000302         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
    1              0.000051       catch /gitgutter not tracked/
    1   0.000520   0.000041         call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    4              0.000010       endtry
                            
    4              0.000027       if diff != 'async'
    1   0.001815   0.000030         call gitgutter#diff#handler(a:bufnr, diff)
    4              0.000005       endif
                            
    7              0.000009     endif
   12              0.000015   endif

FUNCTION  echodoc#default#get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc/default.vim line 79
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006   return s:default

FUNCTION  <SNR>263_last_char()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1202
Called 5 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    5              0.000057   return s:char[len(s:char)-1]

FUNCTION  <SNR>99__isAvailableDefault()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 276
Called 2 times
Total time:   0.000250
 Self time:   0.000242

count  total (s)   self (s)
    2   0.000248   0.000240     return executable(self.getExec())

FUNCTION  <SNR>151_ReloadFolds()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 455
Called 75 times
Total time:   0.890506
 Self time:   0.618454

count  total (s)   self (s)
                            
                                " many of the precautions taken are necessary because the marks of
                                " previously changed text '[ & '] are not always reliable, for instance if
                                " text is inserted by a script. There may be vim bugs such as
                                " vim/vim#1281.
                                "
                            
                                " for some reason, need to redraw, otherwise vim will display
                                " beginning of file before jumping to last position
   75              0.596052     redraw
                            
   75              0.001925     let changed_start = min([getpos("'[")[1], line('$')])
   75              0.000588     let changed_end = min([getpos("']")[1], line('$')])
                            
                                " fix that getpos(...) may evaluate to 0 in some versions of Vim
   75              0.000383     let changed_start = max([changed_start, 1])
   75              0.000279     let changed_end = max([changed_end, 1])
                            
   75              0.000262     let changed_tmp = [changed_start, changed_end]
   75              0.000389     let changed = [min(changed_tmp), max(changed_tmp)]
                            
   75              0.000359     let changed_lines = changed[1] - changed[0] + 1
   75              0.000467     let delta_lines = line('$') - len(b:anyfold_ind_actual)
                            
                                " if number of changed lines smaller than number of added / removed lines,
                                " something went wrong and we mark all lines as changed.
   75              0.000272     if changed_lines < delta_lines
    7              0.000031         let changed[0] = 1
    7              0.000028         let changed[1] = line('$')
    7              0.000035         let changed_lines = changed[1] - changed[0] + 1
   75              0.000125     endif
                            
                                " partially update comments
   75              0.000228     if g:anyfold_identify_comments
   75              0.000788         unlockvar! b:anyfold_commentlines
   75   0.008398   0.002604         let b:anyfold_commentlines = s:ExtendLineList(b:anyfold_commentlines, changed[0], changed[1])
   75              0.000186         if changed_lines > 0
   75   0.055181   0.002366             let b:anyfold_commentlines[changed[0]-1 : changed[1]-1] = s:MarkCommentLines(changed[0], changed[1])
   75              0.000078         endif
   75              0.000309         lockvar! b:anyfold_commentlines
   75              0.000055     endif
                            
                                " if number of lines has not changed and indents are the same, skip update
   75              0.000153     if delta_lines == 0
   67              0.000153         let indents_same = 1
   67              0.000167         let curr_line = changed[0]
  155              0.000415         while curr_line <= changed[1]
   88   0.024246   0.001540             if s:LineIndent(curr_line) != b:anyfold_ind_actual[curr_line - 1]
                                            let indents_same = 0
                                            break
   88              0.000076             endif
   88              0.000228             let curr_line += 1
  155              0.000190         endwhile
   67              0.000113         if indents_same
   67              0.000084             return
                                    endif
    8              0.000008     endif
                            
                                " get first and last line of previously changed block
    8   0.000399   0.000213     let changed[0] = s:PrevNonBlankLine(changed[0])
    8   0.000359   0.000123     let changed[1] = s:NextNonBlankLine(changed[1])
    8              0.000023     if changed[0] == 0
    8              0.000021         let changed[0] = 1
    8              0.000008     endif
    8              0.000019     if changed[1] == -1
    7              0.000028         let changed[1] = line('$')
    8              0.000007     endif
    8              0.000039     let changed_lines = changed[1] - changed[0] + 1
                            
    8              0.000094     unlockvar! b:anyfold_ind_actual
    8              0.000086     unlockvar! b:anyfold_ind_contextual
    8              0.000069     unlockvar! b:anyfold_ind_buffer
                            
    8   0.000914   0.000216     let b:anyfold_ind_actual = s:ExtendLineList(b:anyfold_ind_actual, changed[0], changed[1])
    8   0.000799   0.000224     let b:anyfold_ind_contextual = s:ExtendLineList(b:anyfold_ind_contextual, changed[0], changed[1])
    8   0.000840   0.000223     let b:anyfold_ind_buffer = s:ExtendLineList(b:anyfold_ind_buffer, changed[0], changed[1])
                            
    8              0.000024     if changed_lines > 0
                            
                                    " partially update actual indent
    8   0.104246   0.000379         let b:anyfold_ind_actual[changed[0]-1 : changed[1]-1] = s:ActualIndents(changed[0], changed[1])
                            
                                    " find end of current code block for updating contextual indents
                                    " 1) find minimal indent present in changed block
                                    " 2) move down until line is found with indent <= minimal indent of
                                    " changed block
    8              0.000168         let min_indent = min(b:anyfold_ind_actual[changed[0]-1 : changed[1]-1])
                            
                                    " subtract one to make sure that new indent is applied to all lines of the
                                    " current block
    8              0.000048         let min_indent = max([min_indent-1, 0])
                            
                                    " find end of current block for updating contextual indents
    8              0.000027         let curr_line = changed[1]
    8              0.000025         let block_start_found = 0
   16              0.000039         while !block_start_found
    8              0.000027             if curr_line < line('$')
    1              0.000001                 let curr_line += 1
    8              0.000009             endif
    8              0.000036             if b:anyfold_ind_actual[curr_line-1] <= min_indent
    1              0.000001                 let block_start_found = 1
    8              0.000006             endif
                            
    8              0.000034             if curr_line == line('$') && !block_start_found
    7              0.000020                 let block_start_found = 1
    8              0.000018             endif
   16              0.000023         endwhile
    8              0.000029         let changed_block_end = curr_line
                            
                                    " find beginning of current block, now minimal indent is indent of
                                    " last line of block
    8              0.000057         let min_indent = min([b:anyfold_ind_actual[curr_line-1], min_indent])
                            
    8              0.000025         let curr_line = changed[0]
    8              0.000020         let block_start_found = 0
   16              0.000034         while !block_start_found
    8              0.000017             if curr_line > 1
                                            let curr_line += -1
    8              0.000007             endif
    8              0.000032             if b:anyfold_ind_actual[curr_line-1] <= min_indent
    8              0.000020                 let block_start_found = 1
    8              0.000007             endif
                            
    8              0.000024             if curr_line == 1 && !block_start_found
                                            let block_start_found = 1
    8              0.000010             endif
   16              0.000021         endwhile
    8              0.000030         let changed_block_start = curr_line
                            
    8              0.000046         let changed_block = [changed_block_start, changed_block_end]
                            
    8              0.000048         let init_ind = b:anyfold_ind_contextual[changed_block[0]-1]
    8   0.019846   0.000486         let b:anyfold_ind_contextual[changed_block[0]-1 : changed_block[1]-1] = s:ContextualIndents(init_ind, changed_block[0], changed_block[1], b:anyfold_ind_actual[changed_block[0]-1:changed_block[1]-1])
                            
    8   0.065559   0.000360         let b:anyfold_ind_buffer[changed_block[0]-1 : changed_block[1]-1] = s:BufferIndents(changed_block[0], changed_block[1])
    8              0.000010     endif
                            
    8              0.000050     lockvar! b:anyfold_ind_actual
    8              0.000034     lockvar! b:anyfold_ind_contextual
    8              0.000027     lockvar! b:anyfold_ind_buffer
                            
    8              0.000161     set foldexpr=b:anyfold_ind_buffer[v:lnum-1]
                            

FUNCTION  <SNR>254_is_minimum_version()
    Defined: /usr/share/nvim/runtime/autoload/provider/node.vim line 6
Called 1 time
Total time:   0.007578
 Self time:   0.000132

count  total (s)   self (s)
    1              0.000002   if empty(a:version)
    1   0.007506   0.000061     let nodejs_version = get(split(system(['node', '-v']), "\n"), 0, '')
    1              0.000007     if v:shell_error || nodejs_version[0] !=# 'v'
                                  return 0
    1              0.000001     endif
                              else
                                let nodejs_version = a:version
    1              0.000001   endif
                              " Remove surrounding junk.  Example: 'v4.12.0' => '4.12.0'
    1              0.000025   let nodejs_version = matchstr(nodejs_version, '\(\d\.\?\)\+')
                              " [major, minor, patch]
    1              0.000006   let v_list = split(nodejs_version, '\.')
    1              0.000016   return len(v_list) == 3 && ((str2nr(v_list[0]) > str2nr(a:min_major))     || (str2nr(v_list[0]) == str2nr(a:min_major)         && str2nr(v_list[1]) >= str2nr(a:min_minor)))

FUNCTION  ale#linter#Get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 476
Called 81 times
Total time:   0.054203
 Self time:   0.026369

count  total (s)   self (s)
   81              0.000354     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
  162              0.001174     for l:original_filetype in split(a:original_filetypes, '\.')
   81   0.008924   0.001276         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   81   0.004272   0.001195         let l:linter_names = s:GetLinterNames(l:original_filetype)
   81   0.018110   0.001002         let l:all_linters = ale#linter#GetAll(l:filetype)
   81              0.000205         let l:filetype_linters = []
                            
   81              0.000383         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
   81              0.000251         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
  567              0.000919             for l:linter in l:all_linters
  486              0.002399                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
  891              0.001390                 for l:name in l:name_list
  486              0.001644                     if index(l:linter_names, l:name) >= 0
   81              0.000338                         call add(l:filetype_linters, l:linter)
   81              0.000124                         break
  405              0.000260                     endif
  891              0.000648                 endfor
  567              0.000382             endfor
   81              0.000115         endif
                            
   81              0.000361         call extend(l:possibly_duplicated_linters, l:filetype_linters)
  162              0.000220     endfor
                            
   81              0.000205     let l:name_list = []
   81              0.000201     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
  162              0.000475     for l:linter in reverse(l:possibly_duplicated_linters)
   81              0.000307         if index(l:name_list, l:linter.name) < 0
   81              0.000289             call add(l:name_list, l:linter.name)
   81              0.000236             call add(l:combined_linters, l:linter)
   81              0.000062         endif
  162              0.000159     endfor
                            
   81              0.000247     return reverse(l:combined_linters)

FUNCTION  <lambda>91()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000029   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>93()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>95()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  remote#define#FunctionOnChannel()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 159
Called 3 times
Total time:   0.000442
 Self time:   0.000276

count  total (s)   self (s)
    3              0.000031   let rpcargs = [a:channel, '"'.a:method.'"', 'a:000']
    3              0.000014   if has_key(a:opts, 'range')
                                call add(rpcargs, '[a:firstline, a:lastline]')
    3              0.000003   endif
    3   0.000122   0.000051   call s:AddEval(rpcargs, a:opts)
                            
    3   0.000215   0.000120   let function_def = s:GetFunctionPrefix(a:name, a:opts) . 'return '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')' . "\nendfunction"
    3              0.000033   exe function_def

FUNCTION  <lambda>99()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000028
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>14_isAnsible()
    Defined: ~/config/nvim/.cache/init.vim/.dein/ftdetect/ftdetect.vim line 203
Called 3 times
Total time:   0.000377
 Self time:   0.000377

count  total (s)   self (s)
    3              0.000070   let filepath = expand("%:p")
    3              0.000015   let filename = expand("%:t")
    3              0.000081   if filepath =~ '\v/(tasks|roles|handlers)/.*\.ya?ml$' | return 1 | en
    3              0.000049   if filepath =~ '\v/(group|host)_vars/' | return 1 | en
    3              0.000057   if filename =~ '\v(playbook|site|main|local)\.ya?ml$' | return 1 | en
                            
    3              0.000014   let shebang = getline(1)
    3              0.000039   if shebang =~# '^#!.*/bin/env\s\+ansible-playbook\>' | return 1 | en
    3              0.000029   if shebang =~# '^#!.*/bin/ansible-playbook\>' | return 1 | en
                            
    3              0.000007   return 0

FUNCTION  250()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 153
Called 8 times
Total time:   0.027648
 Self time:   0.008392

count  total (s)   self (s)
    8              0.000097     let line = getline(a:ln)
                            
    8   0.000557   0.000152     let rootLine = self.getRootLineNum()
                            
    8              0.000038     if a:ln == rootLine
                                    return self.nerdtree.root.path
    8              0.000012     endif
                            
    8   0.000235   0.000162     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
    8              0.000010     endif
                            
    8              0.000031     if a:ln < rootLine
                                    return {}
    8              0.000009     endif
                            
    8   0.000851   0.000142     let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
    8   0.000508   0.000142     let curFile = self._stripMarkup(line)
                            
    8              0.000030     let dir = ""
    8              0.000033     let lnum = a:ln
   59              0.000234     while lnum > 0
   59              0.000263         let lnum = lnum - 1
   59              0.000448         let curLine = getline(lnum)
   59   0.003698   0.001168         let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
   59              0.000289         if lnum == rootLine
    8   0.002640   0.000354             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    8              0.000038             break
   51              0.000082         endif
   51              0.000584         if curLineStripped =~# '/$'
   47   0.004671   0.000911             let lpindent = self._indentLevelFor(curLine)
   47              0.000230             if lpindent < indent
   11              0.000052                 let indent = indent - 1
                            
   11              0.000198                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
   11              0.000051                 continue
   36              0.000061             endif
   40              0.000058         endif
   48              0.000150     endwhile
    8              0.000117     let curFile = self.nerdtree.root.path.drive . dir . curFile
    8   0.009379   0.000251     let toReturn = g:NERDTreePath.New(curFile)
    8              0.000026     return toReturn

FUNCTION  <SNR>263_detect_bad_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 958
Called 15 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   15              0.000052   if !s:valid_input
                                " To invoke the appropriate `<Plug>(multiple-cursors-apply)` mapping, we
                                " need to revert back to the mode the user was in when the input was entered
                                call s:revert_mode(s:to_mode, s:from_mode)
                                " We ignore the bad input and force invoke s:apply_user_input_next
                                call feedkeys("\<Plug>(multiple-cursors-apply)")
                                let s:bad_input += 1
   15              0.000013   endif

FUNCTION  <SNR>109_settabvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 272
Called 82 times
Total time:   0.002106
 Self time:   0.002106

count  total (s)   self (s)
   82              0.000216     if v:version > 702
   82              0.000663         cal settabvar(a:tabnr, a:var, a:value)
                                else
                                    for winnr in s:windows(a:tabnr)
                                        cal settabwinvar(a:tabnr, winnr, a:var, a:value)
                                    endfor
   82              0.000082     endif

FUNCTION  ale#FileTooLarge()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 24
Called 257 times
Total time:   0.005921
 Self time:   0.005921

count  total (s)   self (s)
  257              0.003119     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
  257              0.002062     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  deoplete#custom#_update_cache()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 27
Called 125 times
Total time:   0.016845
 Self time:   0.015375

count  total (s)   self (s)
  125              0.000732   if !exists('s:custom')
                                call deoplete#custom#_init()
  125              0.000147   endif
                            
  125   0.002934   0.001464   let custom_buffer = deoplete#custom#_get_buffer()
                            
  125              0.002978   let s:cached.option = copy(s:custom.option)
  125              0.000624   let s:cached.buffer_option = copy(custom_buffer.option)
  125              0.000974   call extend(s:cached.option, s:cached.buffer_option)
                            
  125              0.000522   let s:cached.source_vars = {}
  250              0.001277   for [name, source] in items(s:custom.source)
  125              0.000764     let s:cached.source_vars[name] = get(source, 'vars', {})
  250              0.000337   endfor
  125              0.000620   for [name, vars] in items(custom_buffer.source_vars)
                                if !has_key(s:cached.source_vars, name)
                                  let s:cached.source_vars[name] = {}
                                endif
                                call extend(s:cached.source_vars[name], vars)
  125              0.000125   endfor
  125              0.000308   let s:cached.filter = {}
  125              0.000390   for [name, vars] in items(s:custom.filter)
                                let s:cached.filter[name] = vars
  125              0.000098   endfor
  125              0.000382   for [name, vars] in items(custom_buffer.filter)
                                if !has_key(s:cached.filter, name)
                                  let s:cached.filter[name] = {}
                                endif
                                call extend(s:cached.filter[name], vars)
  125              0.000100   endfor

FUNCTION  ale#handlers#eslint#GetExecutable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 32
Called 104 times
Total time:   0.058203
 Self time:   0.002226

count  total (s)   self (s)
  104   0.058086   0.002109     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [   'node_modules/.bin/eslint_d',   'node_modules/eslint/bin/eslint.js',   'node_modules/.bin/eslint',])

FUNCTION  syntastic#log#debugShowOptions()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/log.vim line 83
Called 2 times
Total time:   0.000061
 Self time:   0.000051

count  total (s)   self (s)
    2   0.000052   0.000043     if !s:_isDebugEnabled(a:level)
    2              0.000003         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  <SNR>264_context_filetype_enabled()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 98
Called 2 times
Total time:   0.000726
 Self time:   0.000372

count  total (s)   self (s)
    2              0.000016   if !exists('s:exists_context_filetype')
    1              0.000002     try
    1   0.000633   0.000279       call context_filetype#version()
                                  let s:exists_context_filetype = 1
    1              0.000026     catch
    1              0.000006       let s:exists_context_filetype = 0
    1              0.000003     endtry
    2              0.000002   endif
                            
    2              0.000007   return s:exists_context_filetype

FUNCTION  <SNR>69_Unmap()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 183
Called 6 times
Total time:   0.008021
 Self time:   0.006833

count  total (s)   self (s)
    6   0.001835   0.000659   let imaps = s:get('right_delims', []) + s:get('left_delims', []) + s:get('quotes_list', []) + s:get('apostrophes_list', []) + ['<BS>', '<C-h>', '<S-BS>', '<Del>', '<CR>', '<Space>', '<S-Tab>', '<Esc>'] + ['<Up>', '<Down>', '<Left>', '<Right>', '<LeftMouse>', '<RightMouse>'] + ['<C-Left>', '<C-Right>'] + ['<Home>', '<End>', '<PageUp>', '<PageDown>', '<S-Down>', '<S-Up>', '<C-G>g']
                            
  210              0.000312   for map in imaps
  204              0.003558     if maparg(map, "i") =~# '^<Plug>delimitMate'
   90              0.000160       if map == '|'
                                    let map = '<Bar>'
   90              0.000061       endif
   90              0.000865       exec 'silent! iunmap <buffer> ' . map
  204              0.000142     endif
  210              0.000183   endfor
    6   0.000109   0.000097   silent! doautocmd <nomodeline> User delimitMate_unmap
    6              0.000027   let b:delimitMate_enabled = 0

FUNCTION  wintabs#renderers#left_arrow()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 70
Called 10 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
   10              0.000093   return {'type': 'left_arrow','label': g:wintabs_ui_arrow_left,'highlight': '',}

FUNCTION  ale#handlers#eslint#HandleJSON()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 254
Called 5 times
Total time:   0.002890
 Self time:   0.000065

count  total (s)   self (s)
    5   0.002882   0.000056     return s:HandleESLintOutput(a:buffer, a:lines, 'json')

FUNCTION  <SNR>26_StartHL()
    Defined: ~/config/nvim/local_plugins/hlsearch.vim line 13
Called 262 times
Total time:   0.009025
 Self time:   0.008983

count  total (s)   self (s)
  262              0.005223 	silent! if v:hlsearch && !search('\%#\zs'.@/,'cnW')
    1   0.000071   0.000029 		call <SID>StopHL()
  262              0.000776 	endif

FUNCTION  <SNR>107__is_quitting()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 712
Called 4 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    4              0.000012     let quitting = 0
    4              0.000019     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
    4              0.000004     endif
                            
    4              0.000009     return quitting

FUNCTION  <SNR>263_get_text()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1054
Called 4 times
Total time:   0.003126
 Self time:   0.000255

count  total (s)   self (s)
    4              0.000058   let lines = getline(a:region[0][0], a:region[1][0])
    4   0.002985   0.000113   let lines[-1] = s:strpart(lines[-1], 0, a:region[1][1])
    4              0.000042   let lines[0] = lines[0][a:region[0][1] - 1:]
    4              0.000032   return join(lines, "\n")

FUNCTION  <SNR>158_RunIfExecutable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 611
Called 52 times
Total time:   0.227261
 Self time:   0.007118

count  total (s)   self (s)
   52   0.001009   0.000639     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
   52              0.000057     endif
                            
   52   0.002030   0.000744     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
   52              0.000216         let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
   52              0.000403         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
   52              0.000194         if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
   52              0.000047         endif
                            
   52   0.047608   0.000696         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
   52              0.000786         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
   52   0.173682   0.002106         return s:RunJob(l:command, l:options)
                                endif
                            
                                return 0

FUNCTION  <SNR>159_GatherOutput()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 207
Called 5 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    5              0.000039     call add(a:line_list, a:line)

FUNCTION  ale#engine#FixLocList()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 309
Called 5 times
Total time:   0.001215
 Self time:   0.000961

count  total (s)   self (s)
    5              0.000012     let l:bufnr_map = {}
    5              0.000010     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    5   0.000223   0.000046     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
    7              0.000016     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
    2              0.000036         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
    2              0.000003         if a:from_other_source
                                        let l:item.from_other_source = 1
    2              0.000001         endif
                            
    2              0.000005         if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
    2              0.000001         endif
                            
    2              0.000008         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
    2              0.000005         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
    2              0.000001         endif
                            
    2              0.000005         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
    2              0.000001         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
    2              0.000004         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
    2              0.000001         endif
                            
    2              0.000005         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
    2              0.000001         endif
                            
    2              0.000004         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
    2              0.000001         endif
                            
    2              0.000003         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
    2              0.000008         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
    2              0.000004         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
    2              0.000001         endif
                            
    2              0.000007         call add(l:new_loclist, l:item)
    7              0.000020     endfor
                            
    5   0.000142   0.000065     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    5              0.000012     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    5              0.000003     endif
                            
    5              0.000008     return l:new_loclist

FUNCTION  <SNR>151_InitIndentList()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 259
Called 4 times
Total time:   0.052910
 Self time:   0.000500

count  total (s)   self (s)
                            
    4              0.000013     if g:anyfold_identify_comments
    4   0.008458   0.000089         let b:anyfold_commentlines = s:MarkCommentLines(1, line('$'))
    4              0.000019         lockvar! b:anyfold_commentlines
    4              0.000004     endif
                            
    4   0.028426   0.000101     let b:anyfold_ind_actual = s:ActualIndents(1, line('$'))
    4   0.004980   0.000122     let b:anyfold_ind_contextual = s:ContextualIndents(0, 1, line('$'), b:anyfold_ind_actual)
    4   0.010956   0.000098     let b:anyfold_ind_buffer = s:BufferIndents(1, line('$'))
                            
    4              0.000014     lockvar! b:anyfold_ind_buffer
    4              0.000009     lockvar! b:anyfold_ind_actual
    4              0.000009     lockvar! b:anyfold_ind_contextual

FUNCTION  <SNR>25_add_map_to_dict()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 113
Called 30 times
Total time:   0.005861
 Self time:   0.001605

count  total (s)   self (s)
   30              0.000112     if len(a:map.lhs) > a:level+1
   16              0.000062         let curkey = a:map.lhs[a:level]
   16              0.000038         let nlevel = a:level+1
   16              0.000058         if !has_key(a:dict, curkey)
    4              0.000030             let a:dict[curkey] = { 'name' : g:leaderGuide_default_group_name }
                                    " mapping defined already, flatten this map
   12              0.000066         elseif type(a:dict[curkey]) == type([]) && g:leaderGuide_flatten
                                        let cmd = s:escape_mappings(a:map)
                                        let curkey = join(a:map.lhs[a:level+0:], '')
                                        let nlevel = a:level
                                        if !has_key(a:dict, curkey)
                                            let a:dict[curkey] = [cmd, a:map.display]
                                        endif
   12              0.000055         elseif type(a:dict[curkey]) == type([]) && g:leaderGuide_flatten == 0
                                        let cmd = s:escape_mappings(a:map)
                                        let curkey = curkey."m"
                                        if !has_key(a:dict, curkey)
                                            let a:dict[curkey] = { 'name' : g:leaderGuide_default_group_name }
                                        endif
   16              0.000013         endif
                                    " next level
   16              0.000066         if type(a:dict[curkey]) == type({})
   16              0.000124             call s:add_map_to_dict(a:map, nlevel, a:dict[curkey])
   16              0.000014         endif
   14              0.000010     else
   14   0.000608   0.000139         let cmd = s:escape_mappings(a:map)
   14              0.000055         if !has_key(a:dict, a:map.lhs[a:level])
   14              0.000084             let a:dict[a:map.lhs[a:level]] = [cmd, a:map.display]
                                    " spot is taken already, flatten existing submaps
                                    elseif type(a:dict[a:map.lhs[a:level]]) == type({}) && g:leaderGuide_flatten
                                        let childmap = s:flattenmap(a:dict[a:map.lhs[a:level]], a:map.lhs[a:level])
                                        for it in keys(childmap)
                                            let a:dict[it] = childmap[it]
                                        endfor
                                        let a:dict[a:map.lhs[a:level]] = [cmd, a:map.display]
   14              0.000010         endif
   30              0.000023     endif

FUNCTION  delimitMate#Get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/delimitMate.vim line 274
Called 468 times
Total time:   0.018899
 Self time:   0.004976

count  total (s)   self (s)
  468   0.018685   0.004762   return call('s:get', a:000)

FUNCTION  ale#handlers#tslint#InitVariables()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/tslint.vim line 1
Called 1 time
Total time:   0.000202
 Self time:   0.000068

count  total (s)   self (s)
    1   0.000042   0.000017     call ale#Set('typescript_tslint_executable', 'tslint')
    1   0.000031   0.000012     call ale#Set('typescript_tslint_config_path', '')
    1   0.000028   0.000011     call ale#Set('typescript_tslint_rules_dir', '')
    1   0.000030   0.000014     call ale#Set('typescript_tslint_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000067   0.000011     call ale#Set('typescript_tslint_ignore_empty_files', 0)

FUNCTION  <SNR>107__ignore_file()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 702
Called 4 times
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
    4              0.000097     let fname = fnamemodify(a:filename, ':p')
    4              0.000026     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
    4              0.000008     endfor
    4              0.000006     return 0

FUNCTION  <lambda>13()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 127
Called 1 time
Total time:   0.000112
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000111   0.000030 return gitgutter#utility#setbufvar(bufnr, 'path', -2)

FUNCTION  <SNR>109_first_normal_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 231
Called 240 times
Total time:   0.006293
 Self time:   0.006293

count  total (s)   self (s)
  282              0.001087     for buf in a:buffers
  282              0.004021         if buflisted(buf) && getbufvar(buf, "&bt") != 'nofile'
  240              0.000526             return buf
   42              0.000055         end
   42              0.000050     endfor
                                return -1

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/events.vim line 42
Called 6 times
Total time:   0.019640
 Self time:   0.000350

count  total (s)   self (s)
                                " Unmark a file as being changed outside of Vim after we try to check it.
    6              0.000068     call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
    6   0.000307   0.000110     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
    6   0.019217   0.000125         call ale#Queue(0, 'lint_file', a:buffer)
    6              0.000009     endif

FUNCTION  <SNR>107_ClearCache()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 444
Called 2 times
Total time:   0.001670
 Self time:   0.000088

count  total (s)   self (s)
    2   0.000377   0.000042     let loclist = g:SyntasticLoclist.current(a:buf)
    2   0.001071   0.000024     call s:notifiers.reset(loclist)
    2   0.000220   0.000020     call loclist.destroy()

FUNCTION  153()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 146
Called 2098 times
Total time:   0.016526
 Self time:   0.010936

count  total (s)   self (s)
 2098   0.013256   0.007666     if !self.isCascadable()
 2098              0.002587         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/job.vim line 175
Called 52 times
Total time:   0.004502
 Self time:   0.003522

count  total (s)   self (s)
   52   0.001607   0.000627     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   52              0.000438     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
   52              0.000173     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
   52              0.000048     endif
                            
   52              0.000295     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
   52              0.000034     endif
                            
   52              0.000726     if &shell =~? 'fish$\|pwsh$'
   52              0.000195         return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>25_start_parser()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 84
Called 1 time
Total time:   0.008295
 Self time:   0.002459

count  total (s)   self (s)
    1              0.000010     let key = a:key ==? ' ' ? "<Space>" : a:key
    1              0.000006     let readmap = ""
    1              0.000009     redir => readmap
    1              0.000306     silent execute 'map '.key
    1              0.000013     redir END
    1              0.000046     let lines = split(readmap, "\n")
    1              0.000008     let visual = s:vis == "gv" ? 1 : 0
                            
   17              0.000033     for line in lines
   16              0.000480         let mapd = maparg(split(line[3:])[0], line[0], 0, 1)
   16              0.000139         if mapd.lhs =~ '<Plug>.*' || mapd.lhs =~ '<SNR>.*'
                                        continue
   16              0.000012         endif
   16   0.002350   0.000229         let mapd.display = s:format_displaystring(mapd.rhs)
   16              0.000131         let mapd.lhs = substitute(mapd.lhs, key, "", "")
   16              0.000106         let mapd.lhs = substitute(mapd.lhs, "<Space>", " ", "g")
   16              0.000091         let mapd.lhs = substitute(mapd.lhs, "<Tab>", "<C-I>", "g")
   16              0.000130         let mapd.rhs = substitute(mapd.rhs, "<SID>", "<SNR>".mapd['sid']."_", "g")
   16              0.000096         if mapd.lhs != '' && mapd.display !~# 'LeaderGuide.*'
   14              0.000150             if (visual && match(mapd.mode, "[vx ]") >= 0) || (!visual && match(mapd.mode, "[vx]") == -1)
   14   0.000795   0.000174             let mapd.lhs = s:string_to_keys(mapd.lhs)
   14   0.003259   0.000166             call s:add_map_to_dict(mapd, 0, a:dict)
   14              0.000010             endif
   16              0.000009         endif
   17              0.000015     endfor

FUNCTION  <SNR>52_openFile()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/nerdtree-space-keys.vim line 50
Called 1 time
Total time:   2.119592
 Self time:   0.000042

count  total (s)   self (s)
    1   2.119591   0.000041     call a:filenode.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  ale#highlight#nvim_buf_add_highlight()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 36
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
                                " Ignore all errors for adding highlights.
    2              0.000003     try
    2              0.000033         call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
                                catch
    2              0.000002     endtry

FUNCTION  <SNR>164_SetListsImpl()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/list.vim line 78
Called 5 times
Total time:   0.001929
 Self time:   0.000972

count  total (s)   self (s)
    5              0.000122     let l:title = expand('#' . a:buffer . ':p')
                            
    5              0.000010     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    5              0.000008     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    5   0.000096   0.000047         let l:ids = s:WinFindBuf(a:buffer)
                            
   10              0.000021         for l:id in l:ids
    5              0.000023             if has('nvim')
    5   0.000533   0.000092                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
    5              0.000003             endif
   10              0.000009         endfor
    5              0.000003     endif
                            
                                " Save the current view before opening/closing any window
    5              0.000050     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    5   0.000197   0.000054     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    5              0.000003     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    5   0.000108   0.000044     if !ale#engine#IsCheckingBuffer(a:buffer)
    5   0.000312   0.000052         call s:CloseWindowIfNeeded(a:buffer)
    5              0.000003     endif

FUNCTION  <SNR>163_GroupLoclistItems()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 235
Called 5 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    5              0.000018     let l:grouped_items = []
    5              0.000009     let l:last_lnum = -1
                            
    7              0.000012     for l:obj in a:loclist
    2              0.000004         if l:obj.bufnr != a:buffer
                                        continue
    2              0.000001         endif
                            
                                    " Create a new sub-List when we hit a new line.
    2              0.000003         if l:obj.lnum != l:last_lnum
    2              0.000006             call add(l:grouped_items, [])
    2              0.000001         endif
                            
    2              0.000007         call add(l:grouped_items[-1], l:obj)
    2              0.000004         let l:last_lnum = l:obj.lnum
    7              0.000008     endfor
                            
    5              0.000008     return l:grouped_items

FUNCTION  <SNR>164_CloseWindowIfNeeded()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/list.vim line 201
Called 5 times
Total time:   0.000260
 Self time:   0.000078

count  total (s)   self (s)
    5   0.000250   0.000069     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    5              0.000005         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  TSOnBufEnter()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 167
Called 3 times
Total time:   0.000290
 Self time:   0.000112

count  total (s)   self (s)
    3   0.000277   0.000099 return remote#define#notify(17, "/home/ajs/config/nvim/repos/github.com/mhartington/nvim-typescript/rplugin/node/nvim_typescript:function:TSOnBufEnter", a:000)

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 117
Called 2 times
Total time:   0.008177
 Self time:   0.000608

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    2   0.000104   0.000027   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    2   0.001172   0.000087   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    2   0.000047   0.000038   if g:gitgutter_async && gitgutter#async#available()
    2              0.000008     if has('lambda')
    2   0.006634   0.000236       call gitgutter#async#execute(cmd, a:bufnr, {   'out': {bufnr, path -> gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))},   'err': {bufnr       -> gitgutter#utility#setbufvar(bufnr, 'path', -2)}, })
                                else
                                  if has('nvim') && !has('nvim-0.2.0')
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:not_tracked_by_git') })
                                  else
                                    call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('s:set_path'),   'err': function('s:set_path', [-2]) })
                                  endif
    2              0.000003     endif
                              else
                                let path = gitgutter#utility#system(cmd)
                                if v:shell_error
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                                else
                                  call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                                endif
    2              0.000003   endif

FUNCTION  ale#sign#GetSignName()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 117
Called 2 times
Total time:   0.000122
 Self time:   0.000076

count  total (s)   self (s)
    2              0.000006     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
    4              0.000006     for l:item in a:sublist
    2   0.000071   0.000025         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
    2              0.000004         if l:item_priority > l:priority
    2              0.000004             let l:priority = l:item_priority
    2              0.000001         endif
    4              0.000003     endfor
                            
    2              0.000004     if l:priority is# g:ale#util#error_priority
    2              0.000003         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  nvim_typescript#DefaultKeyMap()
    Defined: ~/config/nvim/repos/github.com/mhartington/nvim-typescript/autoload/nvim_typescript.vim line 1
Called 3 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    3              0.000020   if get(g:, 'nvim_typescript#default_mappings', 1)
                                execute 'nnoremap <buffer> <silent> K'  ':TSDoc<CR>'
                                execute 'nnoremap <buffer> <silent> <leader>tdp'  ':TSDefPreview<CR>'
                                execute 'nnoremap <buffer> <silent> <c-]>'  ':TSTypeDef<CR>'
    3              0.000003   endif

FUNCTION  406()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 350
Called 15 times
Total time:   0.001149
 Self time:   0.000269

count  total (s)   self (s)
   15              0.000077   let self.position[0] = a:pos[0]
   15              0.000045   let self.position[1] = a:pos[1]
   15   0.000977   0.000097   call self.update_highlight()

FUNCTION  <SNR>14_DetectMoon()
    Defined: ~/config/nvim/.cache/init.vim/.dein/ftdetect/ftdetect.vim line 880
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000027     if getline(1) =~ '^#!.*\<moon\>'
                                    set filetype=moon
    3              0.000003     endif

FUNCTION  ShouldMatchWhitespace()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/trailing-whitespace.vim line 8
Called 99 times
Total time:   0.001585
 Self time:   0.001585

count  total (s)   self (s)
   99              0.000619     for ft in g:extra_whitespace_ignored_filetypes
                                    if ft ==# &filetype | return 0 | endif
   99              0.000152     endfor
   99              0.000139     return 1

FUNCTION  NERDTreeGetGitStatusPrefix()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/git_status.vim line 150
Called 1420 times
Total time:   2.168320
 Self time:   0.100422

count  total (s)   self (s)
 1420              0.004933     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
    7              0.000040         let s:GitStatusCacheTime = localtime()
    7   1.719538   0.000269         call g:NERDTreeGitStatusRefresh()
 1420              0.000684     endif
 1420   0.163552   0.008702     let l:pathStr = a:path.str()
 1420   0.175491   0.014649     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
 1420   0.016698   0.007818     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
 1420              0.000642     endif
 1420              0.007599     let l:cwd = substitute(l:cwd, '\~', '\\~', 'g')
 1420              0.012034     let l:pathStr = substitute(l:pathStr, l:cwd, '', '')
 1420              0.002130     let l:statusKey = ''
 1420              0.001777     if a:path.isDirectory
 1362              0.008088         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
   58              0.000046     else
   58              0.000424         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
 1420              0.000675     endif
 1420   0.035485   0.011427     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  <lambda>85()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000028
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  syntastic#log#debugShowVariables()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/log.vim line 103
Called 4 times
Total time:   0.000095
 Self time:   0.000073

count  total (s)   self (s)
    4   0.000082   0.000059     if !s:_isDebugEnabled(a:level)
    4              0.000005         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  <SNR>158_AddProblemsFromOtherBuffers()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 577
Called 1 time
Total time:   0.000248
 Self time:   0.000248

count  total (s)   self (s)
    1              0.000045     let l:filename = expand('#' . a:buffer . ':p')
    1              0.000004     let l:loclist = []
    1              0.000004     let l:name_map = {}
                            
                                " Build a map of the active linters.
    2              0.000007     for l:linter in a:linters
    1              0.000007         let l:name_map[l:linter.name] = 1
    2              0.000003     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
    5              0.000026     for l:info in values(g:ale_buffer_info)
    4              0.000018         for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
    4              0.000004         endfor
    5              0.000005     endfor
                            
    1              0.000005     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
    1              0.000001     endif

FUNCTION  anyfold#init()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 4
Called 10 times
Total time:   0.055990
 Self time:   0.002738

count  total (s)   self (s)
                            
   10              0.000064     if exists("g:anyfold_activate")
                                    let b:anyfold_activate = g:anyfold_activate
   10              0.000012     endif
                            
   10              0.000026     if !a:force
    3              0.000017         if !exists("b:anyfold_activate")
    3              0.000008             return
                                    elseif !b:anyfold_activate
                                        return
                                    endif
    7              0.000006     endif
                            
                                " make sure initialisation only happens once
    7              0.000031     if exists("b:anyfold_initialised")
    3              0.000004         return
    4              0.000006     else
    4              0.000019         let b:anyfold_initialised = 1
    4              0.000005     endif
                            
    4              0.000015     if exists("b:anyfold_activate")
                                    echoerr "anyfold: 'let anyfold_activate=1' is deprecated, replace by command ':AnyFoldActivate' (see ':h AnyFoldActivate')"
    4              0.000004     endif
                            
    4              0.000029     if exists("b:AnyFoldActivate") || exists("g:AnyFoldActivate")
                                    echoerr "anyfold: 'let AnyFoldActivate=1' does not work, ':AnyFoldActivate' is a command! (see ':h AnyFoldActivate')"
    4              0.000003     endif
                            
    4   0.000158   0.000069     if s:AnyfoldDisable()
                                    return
    4              0.000004     endif
                            
                                " Options and defaults
    4              0.000029     if !exists('g:_ANYFOLD_DEFAULTS')
                                    let g:_ANYFOLD_DEFAULTS = { 'identify_comments':            1, 'fold_comments':                0, 'comments':      ['comment', 'string', 'preproc', 'include'], 'fold_toplevel':                0, 'fold_display':                 1, 'motion':                       1, 'debug':                        0, 'fold_size_str':           '%s lines', 'fold_level_str':             ' + ', }
                                    lockvar! g:_ANYFOLD_DEFAULTS
    4              0.000004     endif
                            
   40              0.000121     for s:key in keys(g:_ANYFOLD_DEFAULTS)
   36              0.000180         if !exists('g:anyfold_' . s:key)
                                        let g:anyfold_{s:key} = copy(g:_ANYFOLD_DEFAULTS[s:key])
   36              0.000030         endif
   40              0.000041     endfor
                            
                                " Option dependencies
    4              0.000011     if g:anyfold_fold_comments
                                    let g:anyfold_identify_comments = max([1, g:anyfold_identify_comments])
    4              0.000005     endif
                            
    4              0.000017     let s:comments_string = ""
    4              0.000021     if len(g:anyfold_comments) > 0
    4              0.000039         let s:comments_string = join(g:anyfold_comments, "\\|")
    4              0.000005     endif
                            
                                " calculate indents for first time
    4   0.052987   0.000077     call s:InitIndentList()
                            
                                " folds are always updated when buffer has changed
    4              0.000077     autocmd TextChanged,InsertLeave <buffer> call s:ReloadFolds()
                            
                                " set vim options
    4   0.000298   0.000056     call anyfold#set_options()
                            
                                " for some events, options need to be set again:
                                " - foldexpr is local to current window so it needs update when
                                "   user enters another window (WinEnter).
                                " - reset foldmethod that may be overwritten by syntax files (BufNewFile, BufRead)
                                "   (see #15, this replaces pr #16)
    4              0.000057     autocmd WinEnter,BufNewFile,BufRead <buffer> call anyfold#set_options()
                            
    4              0.000011     if g:anyfold_motion
    4              0.000210         noremap <script> <buffer> <silent> ]] :<c-u>call <SID>JumpFoldEnd(0,v:count1)<cr>
                            
    4              0.000119         noremap <script> <buffer> <silent> [[ :<c-u>call <SID>JumpFoldStart(0,v:count1)<cr>
                            
    4              0.000101         noremap <script> <buffer> <silent> ]k :<c-u>call <SID>JumpPrevFoldEnd(0,v:count1)<cr>
                            
    4              0.000102         noremap <script> <buffer> <silent> [j :<c-u>call <SID>JumpNextFoldStart(0,v:count1)<cr>
                            
    4              0.000111         vnoremap <script> <buffer> <silent> ]] :<c-u>call <SID>JumpFoldEnd(1,v:count1)<cr>
                            
    4              0.000100         vnoremap <script> <buffer> <silent> [[ :<c-u>call <SID>JumpFoldStart(1,v:count1)<cr>
                            
    4              0.000092         vnoremap <script> <buffer> <silent> ]k :<c-u>call <SID>JumpPrevFoldEnd(1,v:count1)<cr>
                            
    4              0.000094         vnoremap <script> <buffer> <silent> [j :<c-u>call <SID>JumpNextFoldStart(1,v:count1)<cr>
    4              0.000005     endif
                            
                                " mappings for debugging
    4              0.000010     if g:anyfold_debug
                                    noremap <script> <buffer> <silent> <F7> :call <SID>EchoIndents(1)<cr>
                                    noremap <script> <buffer> <silent> <F8> :call <SID>EchoIndents(2)<cr>
                                    noremap <script> <buffer> <silent> <F9> :call <SID>EchoIndents(3)<cr>
                                    noremap <script> <buffer> <silent> <F10> :call <SID>EchoIndents(4)<cr>
    4              0.000004     endif
                            
    4   0.000077   0.000065     silent doautocmd User anyfoldLoaded
                            

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 136
Called 15 times
Total time:   0.002951
 Self time:   0.001817

count  total (s)   self (s)
   15              0.000204     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   15   0.001097   0.000218     call ale#highlight#RemoveHighlights()
                            
   17              0.000059     for l:item in l:item_list
    2              0.000004         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
    2              0.000003         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
    2              0.000006         elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
    2              0.000002         else
    2              0.000003             let l:group = 'ALEError'
    2              0.000001         endif
                            
    2              0.000019         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
    2   0.000277   0.000022         call s:highlight_range(l:item.bufnr, l:range, l:group)
   17              0.000038     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   15              0.000040     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
   15              0.000015     endif

FUNCTION  <SNR>137_dopopd()
    Defined: /usr/share/vim/vimfiles/plugin/fzf.vim line 491
Called 17 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
   17              0.000115   if !exists('w:fzf_pushd')
   17              0.000037     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet w:fzf_pushd

FUNCTION  <SNR>154_write_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/diff.vim line 374
Called 3 times
Total time:   0.000618
 Self time:   0.000618

count  total (s)   self (s)
    3              0.000145   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    3              0.000024   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    3              0.000004   endif
                            
    3              0.000023   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    3              0.000003   endif
                            
    3              0.000017   let fenc = getbufvar(a:bufnr, '&fileencoding')
    3              0.000011   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    3              0.000003   endif
                            
    3              0.000015   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
    3              0.000003   endif
                            
    3              0.000285   call writefile(bufcontents, a:file)

FUNCTION  <SNR>151_MarkCommentLines()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 147
Called 79 times
Total time:   0.061185
 Self time:   0.016955

count  total (s)   self (s)
   79              0.000268     let commentlines = []
   79              0.000222     let curr_line = a:line_start
 1119              0.002005     while curr_line <= a:line_end
 1040   0.054837   0.010608         let commentlines += [s:CommentLine(curr_line)]
 1040              0.001806         let curr_line += 1
 1119              0.000836     endwhile
   79              0.000162     return commentlines

FUNCTION  <SNR>79_abs_path()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 193
Called 50 times
Total time:   0.004716
 Self time:   0.004572

count  total (s)   self (s)
   50              0.004059   let p = resolve(expand('#'.a:bufnr.':p'))
   50   0.000559   0.000414   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>162_FindHistoryItem()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/history.vim line 36
Called 10 times
Total time:   0.000288
 Self time:   0.000200

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   10   0.000207   0.000119     for l:obj in reverse(ale#history#Get(a:buffer))
   10              0.000023         if l:obj.job_id == a:job_id
   10              0.000017             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  <SNR>263_skip_latency_measure()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1174
Called 4 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    4              0.000029   if g:multi_cursor_debug_latency
                                let s:skip_latency_measure = 1
    4              0.000006   endif

FUNCTION  dein#autoload#_on_default_event()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim line 77
Called 12 times
Total time:   0.004413
 Self time:   0.001952

count  total (s)   self (s)
   12   0.002210   0.000274   let lazy_plugins = dein#util#_get_lazy_plugins()
   12              0.000055   let plugins = []
                            
   12              0.000305   let path = expand('<afile>')
                              " For ":edit ~".
   12              0.000092   if fnamemodify(path, ':t') ==# '~'
                                let path = '~'
   12              0.000020   endif
   12   0.000626   0.000204   let path = dein#util#_expand(path)
                            
   19              0.000178   for filetype in split(&l:filetype, '\.')
    7              0.000076     let plugins += filter(copy(lazy_plugins), "index(get(v:val, 'on_ft', []), filetype) >= 0")
   19              0.000039   endfor
                            
   12              0.000138   let plugins += filter(copy(lazy_plugins), "!empty(filter(copy(get(v:val, 'on_path', [])),                'path =~? v:val'))")
   12              0.000101   let plugins += filter(copy(lazy_plugins), "!has_key(v:val, 'on_event')  && has_key(v:val, 'on_if') && eval(v:val.on_if)")
                            
   12   0.000360   0.000257   call s:source_events(a:event, plugins)

FUNCTION  wintabs#refresh_buflist()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 428
Called 1422 times
Total time:   0.608518
 Self time:   0.156247

count  total (s)   self (s)
 1422              0.012847   let window = a:window == 0 ? winnr() : a:window
                            
                              " load buflist from saved value
 1422   0.055504   0.024190   let buflist = wintabs#getwinvar(window, 'wintabs_buflist', [])
                            
                              " remove stale bufs
 1422   0.104439   0.037745   call filter(buflist, 's:buflisted(v:val)')
                            
                              " add current buf
 1422              0.007260   let current_buffer = winbufnr(window)
 1422   0.019789   0.012608   if index(buflist, current_buffer) == -1 && s:buflisted(current_buffer)
    2              0.000008     if (g:wintabs_reverse_order)
                                  call insert(buflist, current_buffer)
    2              0.000004     else
    2              0.000011       call add(buflist, current_buffer)
    2              0.000002     endif
 1422              0.001231   endif
                            
                              " save buflist
 1422              0.009122   call setwinvar(window, 'wintabs_buflist', buflist)
                            
                              " save this to session
 1422   0.368604   0.021522   call wintabs#session#save(tabpagenr(), window)

FUNCTION  <SNR>156_IsCallback()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 71
Called 5 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    5              0.000048     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  wintabs#ui#get_statusline()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 23
Called 1422 times
Total time:   1.276085
 Self time:   0.135281

count  total (s)   self (s)
 1422   1.038439   0.057004   let bufline = s:truncate_line(a:window,s:get_bufline(a:window),winwidth(a:window))
 1422   0.122091   0.041518   let padding = g:wintabs_renderers.padding(winwidth(a:window) - wintabs#element#len(bufline))
                              " reseter is attached to detect stale status
 1422              0.008538   let reseter = '%{wintabs#ui#reset_statusline('.a:window.')}'
 1422   0.101727   0.022931   return wintabs#element#render([reseter, bufline, padding])

FUNCTION  <SNR>52_descendTree()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/nerdtree-space-keys.vim line 41
Called 6 times
Total time:   2.551839
 Self time:   0.000636

count  total (s)   self (s)
    6   2.035168   0.000177     call a:dirnode.open()
    6   0.443899   0.000117     call b:NERDTree.render()
    6   0.000122   0.000083     if a:dirnode.getChildCount() > 0
    6   0.059961   0.000123         let chld = a:dirnode.getChildByIndex(0, 1)
    6   0.012640   0.000087         call chld.putCursorHere(0, 0)
    6              0.000008     end

FUNCTION  ale#handlers#eslint#GetCommand()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 40
Called 52 times
Total time:   0.045356
 Self time:   0.004840

count  total (s)   self (s)
   52   0.027511   0.000705     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
   52   0.001660   0.000691     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
                                " ESLint 6 loads plugins/configs/parsers from the project root
                                " By default, the project root is simply the CWD of the running process.
                                " https://github.com/eslint/rfcs/blob/master/designs/2018-simplified-package-loading/README.md
                                " https://github.com/dense-analysis/ale/issues/2787
                                " Identify project root from presence of node_modules dir.
                                " Note: If node_modules not present yet, can't load local deps anyway.
   52   0.008707   0.000722     let l:modules_dir = ale#path#FindNearestDirectory(a:buffer, 'node_modules')
   52              0.000424     let l:project_dir = !empty(l:modules_dir) ? fnamemodify(l:modules_dir, ':h:h') : ''
   52   0.003272   0.000706     let l:cd_command = !empty(l:project_dir) ? ale#path#CdString(l:project_dir) : ''
                            
   52   0.003371   0.001180     return l:cd_command   . ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f json --stdin --stdin-filename %s'

FUNCTION  wintabs#getwinvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 9
Called 4288 times
Total time:   0.081327
 Self time:   0.081327

count  total (s)   self (s)
 4288              0.025691   let vars = getwinvar(a:winnr, '')
 4288              0.013385   if empty(vars)
    1              0.000001     return a:def
 4287              0.005014   endif
 4287              0.021895   return get(vars, a:varname, a:def)

FUNCTION  wintabs#element#render()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 7
Called 1499 times
Total time:   0.096671
 Self time:   0.027728

count  total (s)   self (s)
 1499   0.074885   0.032088   return wintabs#memoize#call(function('s:render'), a:var)

FUNCTION  <SNR>126_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim line 39
Called 307 times
Total time:   0.232178
 Self time:   0.232178

count  total (s)   self (s)
                              " Remove any previous match.
  307              0.003495   if exists('w:paren_hl_on') && w:paren_hl_on
   65              0.000493     silent! call matchdelete(3)
   65              0.000328     let w:paren_hl_on = 0
  307              0.000580   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  307              0.003859   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  307              0.000510   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  307              0.002345   let c_lnum = line('.')
  307              0.001758   let c_col = col('.')
  307              0.001091   let before = 0
                            
  307              0.002235   let text = getline(c_lnum)
  307              0.013341   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  307              0.002303   if empty(matches)
                                let [c_before, c] = ['', '']
  307              0.000713   else
  307              0.003989     let [c_before, c] = matches[1:2]
  307              0.000508   endif
  307              0.012703   let plist = split(&matchpairs, '.\zs[:,]')
  307              0.003334   let i = index(plist, c)
  307              0.001143   if i < 0
                                " not found, in Insert mode try character before the cursor
  233              0.002348     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
  233              0.000382     endif
  233              0.000619     if i < 0
                                  " not found, nothing to do
  233              0.000713       return
                                endif
   74              0.000090   endif
                            
                              " Figure out the arguments for searchpairpos().
   74              0.000272   if i % 2 == 0
    7              0.000041     let s_flags = 'nW'
    7              0.000069     let c2 = plist[i + 1]
   67              0.000088   else
   67              0.000273     let s_flags = 'nbW'
   67              0.000261     let c2 = c
   67              0.000373     let c = plist[i - 1]
   74              0.000111   endif
   74              0.000281   if c == '['
                                let c = '\['
                                let c2 = '\]'
   74              0.000089   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   74              0.000256   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   74              0.000096   endif
                            
   74              0.001470   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   74              0.000101   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   74              0.000930     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   74              0.000236     try
   74              0.023427       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   74              0.000191     endtry
   74              0.000093   endif
                            
                              " Limit the search to lines visible in the window.
   74              0.003620   let stoplinebottom = line('w$')
   74              0.000491   let stoplinetop = line('w0')
   74              0.000302   if i % 2 == 0
    7              0.000051     let stopline = stoplinebottom
   67              0.000098   else
   67              0.000380     let stopline = stoplinetop
   74              0.000087   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   74              0.000592   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   74              0.000091   else
   74              0.000865     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   74              0.000093   endif
   74              0.000159   try
   74              0.099680     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   74              0.000162   endtry
                            
   74              0.000250   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   74              0.000088   endif
                            
                              " If a match is found setup match highlighting.
   74              0.000521   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   65              0.000397     if exists('*matchaddpos')
   65              0.003551       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   65              0.000071     endif
   65              0.000318     let w:paren_hl_on = 1
   74              0.000086   endif

FUNCTION  ale#node#Executable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/node.vim line 34
Called 52 times
Total time:   0.002191
 Self time:   0.001244

count  total (s)   self (s)
   52              0.000333     if has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
   52              0.000040     endif
                            
   52   0.001345   0.000398     return ale#Escape(a:executable)

FUNCTION  gitgutter#async#execute()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/async.vim line 14
Called 5 times
Total time:   0.017459
 Self time:   0.017029

count  total (s)   self (s)
    5   0.000493   0.000118   call gitgutter#debug#log('[async] '.a:cmd)
                            
    5              0.000051   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    5   0.000144   0.000089   let command = s:build_command(a:cmd)
                            
    5              0.000029   if has('nvim')
    5              0.016356     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    5              0.000015   endif

FUNCTION  provider#node#Prog()
    Defined: /usr/share/nvim/runtime/autoload/provider/node.vim line 99
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return s:prog

FUNCTION  ale#history#SetExitCode()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/history.vim line 49
Called 5 times
Total time:   0.000287
 Self time:   0.000106

count  total (s)   self (s)
    5   0.000243   0.000062     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    5              0.000016     let l:obj.exit_code = a:exit_code
    5              0.000010     let l:obj.status = 'finished'

FUNCTION  <SNR>151_BufferIndents()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 337
Called 12 times
Total time:   0.076057
 Self time:   0.012197

count  total (s)   self (s)
   12              0.000050     let ind_list = []
   12              0.000045     let curr_line = a:line_start
  966              0.001479     while curr_line <= a:line_end
  954   0.072038   0.008178         let ind_list += [s:GetIndentFold(curr_line)]
  954              0.001438         let curr_line += 1
  966              0.000616     endwhile
   12              0.000030     return ind_list

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/events.vim line 51
Called 11 times
Total time:   0.000733
 Self time:   0.000733

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
   11              0.000137     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
   11              0.000015     endif
                            
                                " When entering a buffer, we are no longer quitting it.
   11              0.000110     call setbufvar(a:buffer, 'ale_quitting', 0)
   11              0.000117     let l:filetype = getbufvar(a:buffer, '&filetype')
   11              0.000093     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
   11              0.000057     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
   11              0.000013     endif

FUNCTION  leaderGuide#start_by_prefix()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 500
Called 1 time
Total time:   0.718748
 Self time:   0.000172

count  total (s)   self (s)
                            
    1   0.000117   0.000041     call s:init_on_call(a:vis)
    1              0.000009     call add(s:last_inp, a:key)
                            
    1              0.000008     let s:toplevel = a:key ==? '  '
    1              0.000011     if !has_key(s:cached_dicts, a:key) || g:leaderGuide_run_map_on_popup
                                    "first run
    1              0.000009         let s:cached_dicts[a:key] = {}
    1   0.008331   0.000036         call s:start_parser(a:key, s:cached_dicts[a:key])
    1              0.000001     endif
                                
    1              0.000005     if has_key(s:desc_lookup, a:key) || has_key(s:desc_lookup , 'top')
    1   0.001022   0.000015         let rundict = s:create_target_dict(a:key)
                                else
                                    let rundict = s:cached_dicts[a:key]
    1              0.000000     endif
    1              0.000002     let s:lmap = rundict
                            
    1   0.709218   0.000021     call s:start_buffer()

FUNCTION  <SNR>109_bufname()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 191
Called 120 times
Total time:   0.012817
 Self time:   0.005377

count  total (s)   self (s)
  120              0.000666     let buffers = tabpagebuflist(a:tabnr)
  120   0.005223   0.001807     let buf = s:first_normal_buffer(buffers)
  120              0.000875     let bname = bufname(buf > -1 ? buf : buffers[0])
  120              0.000398     if !empty(bname)
  120   0.005472   0.001447         return s:basename(bname)
                                endif
                                return g:taboo_unnamed_tab_label

FUNCTION  402()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 308
Called 5 times
Total time:   0.000805
 Self time:   0.000653

count  total (s)   self (s)
    5              0.000096   let obj = copy(self)
    5              0.000046   let obj.position = copy(a:position)
    5              0.000021   let obj.visual = []
    5              0.000022   let obj.saved_visual = []
                              " Stores text that was yanked after any commands in Normal or Visual mode
    5              0.000055   let obj.paste_buffer_text = getreg('"')
    5              0.000036   let obj.paste_buffer_type = getregtype('"')
    5   0.000260   0.000108   let obj.cursor_hi_id = s:highlight_cursor(a:position)
    5              0.000021   let obj.visual_hi_id = 0
    5              0.000059   let obj.line_length = col([a:position[0], '$'])
    5              0.000041   if has('folding')
    5              0.000094     silent! execute a:position[0] . "foldopen!"
    5              0.000008   endif
    5              0.000015   return obj

FUNCTION  deoplete#custom#_init_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 20
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003   let b:custom = {}
    1              0.000003   let b:custom.option = {}
    1              0.000003   let b:custom.source_vars = {}
    1              0.000003   let b:custom.filter = {}

FUNCTION  wintabs#switching_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 455
Called 6 times
Total time:   0.001084
 Self time:   0.000606

count  total (s)   self (s)
    6              0.000043   let buffer = bufnr('%')
    6   0.000362   0.000105   if !s:buflisted(buffer)
    3              0.000006     return
    3              0.000004   endif
                            
                              " it's a new buffer if it isn't in current buflist
    3   0.000293   0.000072   if !s:is_in_buflist(0, 0, buffer)
                                " search range
    3              0.000036     if g:wintabs_switchbuf =~ 'usetab'
                                  let tabrange = [tabpagenr()] + range(1, tabpagenr('$'))
    3              0.000023     elseif g:wintabs_switchbuf =~ 'useopen'
                                  let tabrange = [tabpagenr()]
    3              0.000005     else
    3              0.000010       let tabrange = []
    3              0.000004     endif
                            
    3              0.000014     for tabpage in tabrange
                                  for window in range(1, tabpagewinnr(tabpage, '$'))
                                    " ignore current window
                                    if tabpage == tabpagenr() && window == winnr()
                                      continue
                                    endif
                            
                                    " buffer exists in another window
                                    if s:is_in_buflist(tabpage, window, buffer)
                                      " if window isn't new (wintabs_buflist exists), close buffer
                                      " otherwise close window since it's likely opened for this buffer
                                      if exists('w:wintabs_buflist')
                                        call wintabs#close()
                                      else
                                        confirm close
                                      endif
                            
                                      " if vim supports async, switch to the existing buffer at next tick to 
                                      " avoid racing with autocmds, otherwise switch immediately
                                      if has('timers') && has('lambda')
                                        call timer_start(0, {-> s:open_buffer_in(tabpage, window, buffer)})
                                      else
                                        call s:open_buffer_in(tabpage, window, buffer)
                                      endif
                                      return
                                    endif
                                  endfor
    3              0.000009     endfor
    3              0.000004   endif

FUNCTION  <SNR>69_init()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 45
Called 12 times
Total time:   0.045512
 Self time:   0.009597

count  total (s)   self (s)
                            " Initialize variables:
                              " autoclose
   12   0.001857   0.000203   call s:option_init("autoclose", 1)
                              " matchpairs
   12   0.001650   0.000273   call s:option_init("matchpairs", string(&matchpairs)[1:-2])
   12   0.003367   0.001138   call s:option_init("matchpairs_list", map(split(s:get('matchpairs'), '.:.\zs,\ze.:.'), 'split(v:val, ''^.\zs:\ze.$'')'))
   12   0.000903   0.000167   let pairs = s:get('matchpairs_list')
   12              0.000256   if len(filter(pairs, 'v:val[0] ==# v:val[1]'))
                                echohl ErrorMsg
                                echom 'delimitMate: each member of a pair in delimitMate_matchpairs must be different from each other.'
                                echom 'delimitMate: invalid pairs: ' . join(map(pairs, 'join(v:val, ":")'), ', ')
                                echohl Normal
                                return 0
   12              0.000012   endif
   12   0.002516   0.000478   call s:option_init("left_delims", map(copy(s:get('matchpairs_list')), 'v:val[0]'))
   12   0.002405   0.000446   call s:option_init("right_delims", map(copy(s:get('matchpairs_list')), 'v:val[1]'))
                              " quotes
   12   0.001439   0.000177   call s:option_init("quotes", "\" ' `")
   12   0.002321   0.000415   call s:option_init("quotes_list",split(s:get('quotes'), '\s\+'))
                              " nesting_quotes
   12   0.001367   0.000176   call s:option_init("nesting_quotes", [])
                              " excluded_regions
   12   0.001376   0.000164   call s:option_init("excluded_regions", "Comment")
   12   0.002254   0.000356   call s:option_init("excluded_regions_list", split(s:get('excluded_regions'), ',\s*'))
   12   0.000882   0.000202   let enabled = len(s:get('excluded_regions_list')) > 0
   12   0.001553   0.000188   call s:option_init("excluded_regions_enabled", enabled)
                              " expand_space
   12              0.000106   if exists("b:delimitMate_expand_space") && type(b:delimitMate_expand_space) == type("")
                                echom "b:delimitMate_expand_space is '".b:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet b:delimitMate_expand_space
                                let b:delimitMate_expand_space = 1
   12              0.000010   endif
   12              0.000086   if exists("g:delimitMate_expand_space") && type(g:delimitMate_expand_space) == type("")
                                echom "delimitMate_expand_space is '".g:delimitMate_expand_space."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_space' for more details."
                                unlet g:delimitMate_expand_space
                                let g:delimitMate_expand_space = 1
   12              0.000009   endif
   12   0.001406   0.000174   call s:option_init("expand_space", 0)
                              " expand_cr
   12              0.000091   if exists("b:delimitMate_expand_cr") && type(b:delimitMate_expand_cr) == type("")
                                echom "b:delimitMate_expand_cr is '".b:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet b:delimitMate_expand_cr
                                let b:delimitMate_expand_cr = 1
   12              0.000011   endif
   12              0.000078   if exists("g:delimitMate_expand_cr") && type(g:delimitMate_expand_cr) == type("")
                                echom "delimitMate_expand_cr is '".g:delimitMate_expand_cr."' but it must be either 1 or 0!"
                                echom "Read :help 'delimitMate_expand_cr' for more details."
                                unlet g:delimitMate_expand_cr
                                let g:delimitMate_expand_cr = 1
   12              0.000010   endif
   12              0.000262   if ((&backspace !~ 'eol' || &backspace !~ 'start') && &backspace != 2) && ((exists('b:delimitMate_expand_cr') && b:delimitMate_expand_cr == 1) || (exists('g:delimitMate_expand_cr') && g:delimitMate_expand_cr == 1))
                                echom "delimitMate: There seems to be some incompatibility with your settings that may interfer with the expansion of <CR>. See :help 'delimitMate_expand_cr' for details."
   12              0.000010   endif
   12   0.001422   0.000152   call s:option_init("expand_cr", 0)
                              " expand_in_quotes
   12   0.001512   0.000184   call s:option_init('expand_inside_quotes', 0)
                              " jump_expansion
   12   0.001488   0.000180   call s:option_init("jump_expansion", 0)
                              " smart_matchpairs
   12   0.001508   0.000212   call s:option_init("smart_matchpairs", '^\%(\w\|\!\|[$]\|[^[:punct:][:space:]]\)')
                              " smart_quotes
                              " XXX: backward compatibility. Ugly, should go the way of the dodo soon.
   12   0.000964   0.000265   let quotes = escape(join(s:get('quotes_list'), ''), '\-^[]')
   12              0.000129   let default_smart_quotes = '\%(\w\|[^[:punct:][:space:]' . quotes . ']\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]' . quotes . ']\)'
   12              0.000100   if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) == type(0)
                                if g:delimitMate_smart_quotes
                                  unlet g:delimitMate_smart_quotes
                                else
                                  unlet g:delimitMate_smart_quotes
                                  let g:delimitMate_smart_quotes = ''
                                endif
   12              0.000011   endif
   12              0.000086   if exists('b:delimitMate_smart_quotes') && type(b:delimitMate_smart_quotes) == type(0)
                                if b:delimitMate_smart_quotes
                                  unlet b:delimitMate_smart_quotes
                                  if exists('g:delimitMate_smart_quotes') && type(g:delimitMate_smart_quotes) && g:delimitMate_smart_quotes
                                    let b:delimitMate_smart_quotes = default_smart_quotes
                                  endif
                                else
                                  unlet b:delimitMate_smart_quotes
                                  let b:delimitMate_smart_quotes = ''
                                endif
   12              0.000009   endif
   12   0.001560   0.000201   call s:option_init("smart_quotes", default_smart_quotes)
                              " apostrophes
   12   0.001448   0.000183   call s:option_init("apostrophes", "")
   12   0.002272   0.000367   call s:option_init("apostrophes_list", split(s:get('apostrophes'), ":\s*"))
                              " tab2exit
   12   0.001428   0.000162   call s:option_init("tab2exit", 1)
                              " balance_matchpairs
   12   0.001335   0.000169   call s:option_init("balance_matchpairs", 0)
                              " eol marker
   12   0.001308   0.000159   call s:option_init("insert_eol_marker", 1)
   12   0.001317   0.000153   call s:option_init("eol_marker", "")
                              " Everything is fine.
   12              0.000022   return 1

FUNCTION  301()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 192
Called 2 times
Total time:   0.000717
 Self time:   0.000145

count  total (s)   self (s)
    2   0.000352   0.000029     call self.syncExec()
                            
    2              0.000013     if !has_key(self, '_available')
    2              0.000010         let self._available = {}
    2              0.000003     endif
    2              0.000012     if !has_key(self._available, self._exec)
    2   0.000304   0.000054         let self._available[self._exec] = self._isAvailableFunc()
    2              0.000004     endif
                            
    2              0.000010     return self._available[self._exec]

FUNCTION  provider#python3#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim line 26
Called 28 times
Total time:   0.227102
 Self time:   0.089746

count  total (s)   self (s)
   28              0.000138   if s:err != ''
                                return
   28              0.000038   endif
   28              0.000114   if !exists('s:host')
    1              0.000007     let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
    1              0.000001     try
    1   0.137396   0.000039       let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
    1              0.000001     endtry
   28              0.000019   endif
   28              0.088719   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  309()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/cursor.vim line 15
Called 14 times
Total time:   0.000545
 Self time:   0.000163

count  total (s)   self (s)
   14   0.000537   0.000155     return syntastic#util#var('echo_current_error')

FUNCTION  409()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 369
Called 5 times
Total time:   0.000981
 Self time:   0.000245

count  total (s)   self (s)
    5              0.000060   let self.visual = deepcopy(a:region)
    5   0.000142   0.000069   call s:cm.remove_highlight(self.visual_hi_id)
    5   0.000772   0.000108   let self.visual_hi_id = s:highlight_region(a:region)

FUNCTION  <SNR>26_StopHL()
    Defined: ~/config/nvim/local_plugins/hlsearch.vim line 19
Called 48 times
Total time:   0.000679
 Self time:   0.000679

count  total (s)   self (s)
   48              0.000353 	if ! v:hlsearch || mode() !=? 'n'
   47              0.000068 		return
    1              0.000003 	else
    1              0.000019 		silent call feedkeys("\<Plug>(StopHL)", 'm')
    1              0.000002 	endif

FUNCTION  <SNR>263_revert_highlight_fix()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1136
Called 8 times
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
    8              0.000069   if type(s:saved_line) == 1
                                if s:from_mode ==# 'i'
                                  silent! undojoin | call setline('.', s:saved_line)
                                else
                                  call setline('.', s:saved_line)
                                endif
    8              0.000008   endif
    8              0.000034   let s:saved_line = 0

FUNCTION  <SNR>119_override_plugin_changes()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 685
Called 447 times
Total time:   0.018742
 Self time:   0.018469

count  total (s)   self (s)
  447              0.003552   if g:wintabs_display == 'tabline'&& match(&tabline, '%!wintabs#ui#get_tabline') == -1
                                set tabline=%!wintabs#ui#get_tabline()
  447              0.009959   elseif g:wintabs_display == 'statusline'&& match(&statusline, '%!wintabs#ui#get_statusline') == -1
    6   0.000348   0.000075     call wintabs#ui#set_statusline()
  447              0.000548   endif

FUNCTION  <SNR>263_region()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 758
Called 5 times
Total time:   0.000342
 Self time:   0.000171

count  total (s)   self (s)
    5   0.000337   0.000166   return [s:pos(a:start_mark), s:pos(a:end_mark)]

FUNCTION  13()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 14
Called 1432 times
Total time:   0.131055
 Self time:   0.065673

count  total (s)   self (s)
 1432              0.003204     let l:prependWorkingDir = 0
                            
 1432   0.021181   0.009291     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
 1432              0.001059     else
 1432              0.007284         let l:prependWorkingDir = a:pathStr !~# '^/'
 1432              0.000896     endif
                            
 1432              0.002702     let l:result = a:pathStr
                            
 1432              0.001795     if l:prependWorkingDir
 1419              0.006688         let l:result = getcwd()
                            
 1419   0.037566   0.008895         if l:result[-1:] == s:Path.Slash()
                                        let l:result = l:result . a:pathStr
 1419              0.000933         else
 1419   0.033836   0.009015             let l:result = l:result . s:Path.Slash() . a:pathStr
 1419              0.000818         endif
 1432              0.000700     endif
                            
 1432              0.001632     return l:result

FUNCTION  15()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 47
Called 1420 times
Total time:   0.076851
 Self time:   0.053122

count  total (s)   self (s)
 1420   0.024490   0.008770     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
 1420              0.001344     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
 1420              0.000634     endif
                            
 1420              0.002654     let self._bookmarkNames = []
 1420   0.014925   0.006916     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
 1420              0.001052     endfor
 1420              0.003289     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
 1420              0.000617     endif
                            
 1420              0.001247     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
 1420              0.000570     endif
                            
 1420              0.001192     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
 1420              0.000559     endif

FUNCTION  18()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 107
Called 5724 times
Total time:   0.490242
 Self time:   0.190623

count  total (s)   self (s)
 5724   0.075054   0.022478     let thisPath = self.getLastPathComponent(1)
 5724   0.073087   0.022728     let thatPath = a:path.getLastPathComponent(1)
                            
                                "if the paths are the same then clearly we return 0
 5724              0.007436     if thisPath ==# thatPath
  700              0.000554         return 0
 5024              0.002013     endif
                            
 5024   0.119190   0.018530     let thisSS = self.getSortOrderIndex()
 5024   0.116607   0.020582     let thatSS = a:path.getSortOrderIndex()
                            
                                "compare the sort sequences, if they are different then the return
                                "value is easy
 5024              0.005601     if thisSS < thatSS
   15              0.000013         return -1
 5009              0.005834     elseif thisSS > thatSS
    4              0.000003         return 1
 5005              0.002499     else
 5005              0.006168         if !g:NERDTreeSortHiddenFirst
                                        let thisPath = substitute(thisPath, '^[._]', '', '')
                                        let thatPath = substitute(thatPath, '^[._]', '', '')
 5005              0.002556         endif
                                    "if the sort sequences are the same then compare the paths
                                    "alphabetically
 5005              0.016211         let pathCompare = g:NERDTreeCaseSensitiveSort ? thisPath <# thatPath : thisPath <? thatPath
 5005              0.004635         if pathCompare
 2663              0.002080             return -1
 2342              0.001235         else
 2342              0.001604             return 1
                                    endif
                                endif

FUNCTION  <SNR>168_find_current_signs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/sign.vim line 97
Called 4 times
Total time:   0.001422
 Self time:   0.000884

count  total (s)   self (s)
    4              0.000027   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    4              0.000020   let other_signs = []      " [<line_number (number),...]
    4              0.000022   let dummy_sign_placed = 0
                            
    4              0.000037   redir => signs
    4              0.000097     silent execute "sign place buffer=" . a:bufnr
    4              0.000028   redir END
                            
    4              0.000102   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
                                let components  = split(sign_line)
                                let name        = split(components[2], '=')[1]
                                if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
                                  let line_number = str2nr(split(components[0], '=')[1])
                                  if name =~# 'GitGutter'
                                    let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
                                    if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
                                    let gitgutter_signs[line_number] = {'id': id, 'name': name}
                                  else
                                    call add(other_signs, line_number)
                                  endif
                                end
    4              0.000013   endfor
                            
    4   0.000307   0.000102   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    4   0.000256   0.000086   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    4   0.000238   0.000074   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  syntastic#util#stamp()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 402
Called 9 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
    9              0.000380     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>130_GetRpcFunction()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 175
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000009   if a:sync ==# 'urgent'
                                return 'rpcnotify'
    3              0.000006   elseif a:sync
                                return 'remote#define#request'
    3              0.000002   endif
    3              0.000006   return 'remote#define#notify'

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/diff.vim line 70
Called 4 times
Total time:   0.051907
 Self time:   0.035297

count  total (s)   self (s)
    8   0.000812   0.000283   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
    4   0.036090   0.033506     sleep 5m
    8              0.000052   endwhile
                            
    4   0.000225   0.000069   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
    1              3.899927     throw 'gitgutter not tracked'
    3              0.000004   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    3              0.000009   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    3              0.000024   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    3              0.000019   let s:counter = (s:counter + 1) % 20
    3              0.000018   let buff_file .= '.'.s:counter
                            
    3   0.000327   0.000049   let extension = gitgutter#utility#extension(a:bufnr)
    3              0.000013   if !empty(extension)
    3              0.000016     let buff_file .= '.'.extension
    3              0.000004   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    3   0.000723   0.000105   call s:write_buffer(a:bufnr, buff_file)
                            
    3              0.000014   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    3              0.000025     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    3              0.000016     let from_file .= '.'.s:counter
                            
    3              0.000013     if !empty(extension)
    3              0.000013       let from_file .= '.'.extension
    3              0.000004     endif
                            
                                " Write file from index to temporary file.
    3   0.000364   0.000093     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000044     let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000003   endif
                            
                              " Call git-diff.
    3              0.000024   let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
    3              0.000007   if s:c_flag
    3              0.000014     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000011     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000011     let cmd .= ' -c "core.safecrlf=false"'
    3              0.000003   endif
    3              0.000030   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    3              0.000018   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    3   0.000263   0.000080     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000003   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    3              0.000022   let cmd .= ' || exit 0'
                            
    3              0.000016   let cmd .= ')'
                            
    3   0.000969   0.000054   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    3   0.000078   0.000061   if g:gitgutter_async && gitgutter#async#available()
    3   0.011354   0.000294     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    3              0.000026     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  ale#history#RememberOutput()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/history.vim line 58
Called 5 times
Total time:   0.000183
 Self time:   0.000076

count  total (s)   self (s)
    5   0.000153   0.000046     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    5              0.000013     let l:obj.output = a:output

FUNCTION  106()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/bookmark.vim line 198
Called 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    1              0.000012     let line = getline(".")
    1              0.000037     let name = substitute(line, '^>\(.\{-}\) .\+$', '\1', '')
    1              0.000008     if name != line
                                    try
                                        return s:Bookmark.BookmarkFor(name)
                                    catch /^NERDTree.BookmarkNotFoundError/
                                        return {}
                                    endtry
    1              0.000002     endif
    1              0.000004     return {}

FUNCTION  <SNR>151_ConsiderLine()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 208
Called 2260 times
Total time:   0.069805
 Self time:   0.053245

count  total (s)   self (s)
 2260              0.011237     if getline(a:lnum) !~? '\v\S'
                                    " empty line
   81              0.000142         return 0
 2179              0.010943     elseif getline(a:lnum) =~? '^\W\+$'
                                    " line containing braces or other non-word characters that will not
                                    " define an indent
   73              0.000124         return 0
 2106   0.031617   0.015057     elseif s:IsComment(a:lnum)
                                    " comment line
                                    return 0
 2106              0.001415     else
 2106              0.001967         return 1
                                endif

FUNCTION  <SNR>263_pos()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 750
Called 34 times
Total time:   0.000483
 Self time:   0.000483

count  total (s)   self (s)
   34              0.000273   let pos = getpos(a:mark)
   34              0.000168   return [pos[1], pos[2]]

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 32
Called 317 times
Total time:   0.089421
 Self time:   0.055030

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
  317              0.004293     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
  317              0.000326     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
  317              0.002616     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
  317              0.000290     endif
                            
  317              0.003171     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
  317              0.001041     if l:filetype is# ''
    4              0.000009         return 1
  313              0.000290     endif
                            
                                " Do nothing for diff buffers.
  313              0.001618     if getbufvar(a:buffer, '&diff')
                                    return 1
  313              0.000268     endif
                            
                                " Do nothing for blacklisted files.
  313              0.003853     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
   56              0.000128         return 1
  257              0.000243     endif
                            
                                " Do nothing if running from command mode.
  257              0.001811     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
  257              0.000215     endif
                            
  257              0.002311     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
  257              0.000676     if l:filename is# '.'
                                    return 1
  257              0.000220     endif
                            
                                " Don't start linting and so on when an operator is pending.
  257   0.006466   0.003848     if ale#util#Mode(1) is# 'no'
                                    return 1
  257              0.000238     endif
                            
                                " Do nothing if running in the sandbox.
  257   0.029216   0.003364     if ale#util#InSandbox()
                                    return 1
  257              0.000321     endif
                            
                                " Do nothing if the file is too large.
  257   0.009786   0.003864     if ale#FileTooLarge(a:buffer)
                                    return 1
  257              0.000241     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
  257              0.005786     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
  257              0.000255     endif
                            
  257              0.000396     return 0

FUNCTION  ale#history#Get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/history.vim line 8
Called 10 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   10              0.000074     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  310()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/cursor.vim line 19
Called 7 times
Total time:   0.000560
 Self time:   0.000264

count  total (s)   self (s)
    7   0.000402   0.000107     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    7              0.000009     endif

FUNCTION  <SNR>25_wait_for_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 379
Called 1 time
Total time:   0.700662
 Self time:   0.011054

count  total (s)   self (s)
    1              0.010712     redraw
                                "let inp = input("")
    1              0.000184     let curr_inp = input("")
    1              0.000017     if curr_inp ==? ''
                                    call s:winclose()
    1              0.000043     elseif match(curr_inp, "^<LGCMD>submode") == 0
                                    call s:submode_mappings()
    1              0.000002     else
    1              0.000011         call add(s:last_inp, curr_inp)
    1              0.000012         let fsel = get(s:lmap, curr_inp)
    1   0.689651   0.000043         call s:handle_input(fsel)
    1              0.000001     endif

FUNCTION  314()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/highlighting.vim line 33
Called 7 times
Total time:   0.001678
 Self time:   0.000855

count  total (s)   self (s)
    7   0.000347   0.000064     if self.enabled()
    7   0.000352   0.000185         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    7   0.000394   0.000072         call self._reset()
    7              0.000033         let buf = bufnr('')
    7   0.000165   0.000113         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    7              0.000025         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
    7              0.000015         endfor
    7              0.000009     endif

FUNCTION  315()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/highlighting.vim line 64
Called 2 times
Total time:   0.000214
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000006     if s:has_highlighting
    2   0.000076   0.000026         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    2   0.000126   0.000022         call self._reset()
    2              0.000002     endif

FUNCTION  317()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/highlighting.vim line 94
Called 9 times
Total time:   0.000426
 Self time:   0.000426

count  total (s)   self (s)
   27              0.000152     for match in getmatches()
   18              0.000090         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
   18              0.000016         endif
   27              0.000034     endfor

FUNCTION  318()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 10
Called 6 times
Total time:   0.000550
 Self time:   0.000550

count  total (s)   self (s)
    6              0.000227     let newObj = copy(self)
                            
    6              0.000056     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
    6              0.000026     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
    6              0.000013     endfor
                            
    6              0.000031     let newObj._rawLoclist = llist
    6              0.000020     let newObj._name = ''
    6              0.000029     let newObj._owner = bufnr('')
    6              0.000016     let newObj._sorted = 0
    6              0.000029     let newObj._columns = g:syntastic_cursor_columns
                            
    6              0.000016     return newObj

FUNCTION  319()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 30
Called 9 times
Total time:   0.001084
 Self time:   0.000521

count  total (s)   self (s)
    9              0.000058     let buf = a:0 ? a:1 : bufnr('')
    9   0.000346   0.000210     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
    9              0.000081     if type(loclist) != type({}) || empty(loclist)
    4              0.000015         unlet! loclist
    4   0.000491   0.000063         let loclist = g:SyntasticLoclist.New([])
    9              0.000013     endif
    9              0.000021     return loclist

FUNCTION  <SNR>25_create_target_dict()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 35
Called 1 time
Total time:   0.001008
 Self time:   0.000115

count  total (s)   self (s)
    1              0.000002     if has_key(s:desc_lookup, 'top')
    1              0.000083         let toplevel = deepcopy({s:desc_lookup['top']})
    1              0.000005         let tardict = s:toplevel ? toplevel : get(toplevel, a:key, {})
    1              0.000002         let mapdict = s:cached_dicts[a:key]
    1   0.000903   0.000010         call s:merge(tardict, mapdict)
                                elseif has_key(s:desc_lookup, a:key)
                                    let tardict = deepcopy({s:desc_lookup[a:key]})
                                    let mapdict = s:cached_dicts[a:key]
                                    call s:merge(tardict, mapdict)
                                else
                                    let tardict = s:cached_dicts[a:key]
    1              0.000001     endif
    1              0.000001     return tardict

FUNCTION  25()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 283
Called 2276 times
Total time:   0.053182
 Self time:   0.014521

count  total (s)   self (s)
 2276              0.003658     if self.cachedDisplayString ==# ""
  719   0.041319   0.002659         call self.cacheDisplayString()
 2276              0.001179     endif
                            
 2276              0.002635     return self.cachedDisplayString

FUNCTION  26()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 292
Called 1 time
Total time:   2.101593
 Self time:   0.005776

count  total (s)   self (s)
    1   2.101591   0.005774     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  27()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 299
Called 2133 times
Total time:   0.055070
 Self time:   0.040983

count  total (s)   self (s)
 2133   0.025705   0.011618     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
 2133              0.001109     else
 2133              0.005485         let self.drive = ''
 2133              0.001111     endif
                            

FUNCTION  29()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 322
Called 24 times
Total time:   0.000782
 Self time:   0.000453

count  total (s)   self (s)
   24   0.000587   0.000259     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
   24              0.000025     endif
                            
   24              0.000071     return " \\`\|\"#%&,?()\*^<>[]$"

FUNCTION  <SNR>20_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim line 13
Called 7 times
Total time:   0.003792
 Self time:   0.002121

count  total (s)   self (s)
    7              0.000047     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    7              0.000009     endif
    7              0.000047     let s = expand("<amatch>")
    7              0.000021     if s != ""
    7              0.000026       if exists("b:did_indent")
    2              0.000003 	unlet b:did_indent
    7              0.000008       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   14              0.000091       for name in split(s, '\.')
    7   0.003400   0.001728 	exe 'runtime! indent/' . name . '.vim'
   14              0.000025       endfor
    7              0.000008     endif

FUNCTION  <SNR>109_bufpath()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 201
Called 120 times
Total time:   0.012933
 Self time:   0.005069

count  total (s)   self (s)
  120              0.000641     let buffers = tabpagebuflist(a:tabnr)
  120   0.004555   0.001678     let buf = s:first_normal_buffer(buffers)
  120              0.000743     let bname = bufname(buf > -1 ? buf : buffers[0])
  120              0.000365     if !empty(bname)
  120   0.006462   0.001475         return s:fullpath(bname, 1)
                                endif
                                return g:taboo_unnamed_tab_label

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 170
Called 5 times
Total time:   0.001718
 Self time:   0.000264

count  total (s)   self (s)
    5   0.000854   0.000160   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    5   0.000846   0.000085   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>186_len()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 16
Called 59 times
Total time:   0.005299
 Self time:   0.002477

count  total (s)   self (s)
   59              0.000368   if type(a:var) == type('')
   31              0.000183     return strdisplaywidth(a:var)
   28              0.000033   endif
                            
   28              0.000132   if type(a:var) == type({})
    7   0.000356   0.000223     return wintabs#element#len(a:var.label)
   21              0.000021   endif
                            
   21              0.000090   if type(a:var) == type([])
   21              0.000087     let len = 0
   74              0.000206     for element in a:var
   53   0.002366   0.000776       let len = len + wintabs#element#len(element)
   74              0.000121     endfor
   21              0.000046     return len
                              endif
                            
                              return 0

FUNCTION  119()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 13
Called 1 time
Total time:   2.119550
 Self time:   0.000104

count  total (s)   self (s)
    1   2.119545   0.000098     call self.open(a:0 ? a:1 : {})

FUNCTION  <lambda>27()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>163_PriorityCmd()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 153
Called 10 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   10              0.000023     if s:supports_sign_groups
   10              0.000032         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  321()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 44
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000005     if !self._sorted
    2              0.000008         for e in self._rawLoclist
                                        call s:_set_screen_column(e)
    2              0.000004         endfor
                            
    2              0.000014         call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
    2              0.000006         let self._sorted = 1
    2              0.000002     endif

FUNCTION  322()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 56
Called 33 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   33              0.000154     return empty(self._rawLoclist)

FUNCTION  323()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 60
Called 7 times
Total time:   0.000492
 Self time:   0.000208

count  total (s)   self (s)
    7              0.000041     if !exists('self._stamp')
    2              0.000010         let self._stamp = []
    2              0.000005         return 0
    5              0.000005     endif
    5   0.000366   0.000083     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  324()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 68
Called 7 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    7              0.000031     return copy(self._rawLoclist)

FUNCTION  326()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 76
Called 4 times
Total time:   0.000298
 Self time:   0.000096

count  total (s)   self (s)
    4   0.000296   0.000094     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  provider#node#Detect()
    Defined: /usr/share/nvim/runtime/autoload/provider/node.vim line 50
Called 1 time
Total time:   1.683637
 Self time:   1.676000

count  total (s)   self (s)
    1              0.000003   if exists('g:node_host_prog')
                                return expand(g:node_host_prog)
    1              0.000001   endif
    1   0.007593   0.000016   if !s:is_minimum_version(v:null, 6, 0)
                                return ''
    1              0.000001   endif
                            
    1              0.000004   let npm_opts = {}
    1              0.000027   if executable('npm')
    1              0.000008     let npm_opts = deepcopy(s:NodeHandler)
    1              0.000003     let npm_opts.entry_point = '/neovim/bin/cli.js'
    1              0.001067     let npm_opts.job_id = jobstart('npm --loglevel silent root -g', npm_opts)
    1              0.000003   endif
                            
    1              0.000003   let yarn_opts = {}
    1              0.000028   if executable('yarn')
    1              0.000010     let yarn_opts = deepcopy(s:NodeHandler)
    1              0.000003     let yarn_opts.entry_point = '/node_modules/neovim/bin/cli.js'
                                " `yarn global dir` is slow (> 250ms), try the default path first
                                " XXX: The following code is not portable
                                " https://github.com/yarnpkg/yarn/issues/2049#issuecomment-263183768
    1              0.000003     if has('unix')
    1              0.000006       let yarn_default_path = $HOME . '/.config/yarn/global/' . yarn_opts.entry_point
    1              0.000008       if filereadable(yarn_default_path)
                                    return yarn_default_path
    1              0.000001       endif
    1              0.000001     endif
    1              0.000989     let yarn_opts.job_id = jobstart('yarn global dir', yarn_opts)
    1              0.000003   endif
                            
                              " npm returns the directory faster, so let's check that first
    1              0.000004   if !empty(npm_opts)
    1   1.673825   1.673766     let result = jobwait([npm_opts.job_id])
    1              0.000005     if result[0] == 0 && npm_opts.result != ''
    1              0.000005       return npm_opts.result
                                endif
                              endif
                            
                              if !empty(yarn_opts)
                                let result = jobwait([yarn_opts.job_id])
                                if result[0] == 0 && yarn_opts.result != ''
                                  return yarn_opts.result
                                endif
                              endif
                            
                              return ''

FUNCTION  <lambda>55()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#sign#ParseSigns()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 204
Called 5 times
Total time:   0.000624
 Self time:   0.000544

count  total (s)   self (s)
    5   0.000131   0.000050     let l:pattern =ale#sign#ParsePattern()
    5              0.000009     let l:result = []
    5              0.000010     let l:is_dummy_sign_set = 0
                            
   14              0.000027     for l:line in a:line_list
    9              0.000211         let l:match = matchlist(l:line, l:pattern)
                            
    9              0.000024         if len(l:match) > 0
    2              0.000005             if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
    2              0.000002             else
    2              0.000016                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
    2              0.000001             endif
    9              0.000005         endif
   14              0.000020     endfor
                            
    5              0.000018     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 27
Called 52 times
Total time:   0.001739
 Self time:   0.001739

count  total (s)   self (s)
   52              0.000196     let l:found = 0
                            
   52              0.000433     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
   52              0.000083     endfor
                            
   52              0.000098     if !l:found
   52              0.000224         call add(a:info.active_linter_list, a:linter)
   52              0.000041     endif

FUNCTION  <SNR>51_CursorHoldUpdate()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/git_status.vim line 263
Called 1 time
Total time:   0.000120
 Self time:   0.000072

count  total (s)   self (s)
    1              0.000020     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
    1              0.000004     endif
                            
    1   0.000083   0.000035     if !g:NERDTree.IsOpen()
    1              0.000002         return
                                endif
                            
                                " Do not update when a special buffer is selected
                                if !empty(&l:buftype)
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                call b:NERDTree.root.refreshFlags()
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/path.vim line 29
Called 208 times
Total time:   0.046048
 Self time:   0.046048

count  total (s)   self (s)
  208              0.006201     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
  208              0.001588     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
  208              0.034168     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
  208              0.000881     if !empty(l:relative_path)
  104              0.002002         return fnamemodify(l:relative_path, ':p')
  104              0.000109     endif
                            
  104              0.000138     return ''

FUNCTION  31()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 350
Called 1 time
Total time:   0.000433
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000016   0.000007     if nerdtree#runningWindows()
                                    let path = self.drive . '\' . join(self.pathSegments[0:-2], '\')
    1              0.000001     else
    1              0.000009         let path = '/'. join(self.pathSegments[0:-2], '/')
    1              0.000001     endif
                            
    1   0.000403   0.000007     return s:Path.New(path)

FUNCTION  32()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 367
Called 30412 times
Total time:   0.296636
 Self time:   0.296636

count  total (s)   self (s)
30412              0.050719     if empty(self.pathSegments)
                                    return ''
30412              0.013801     endif
30412              0.053588     let toReturn = self.pathSegments[-1]
30412              0.041479     if a:dirSlash && self.isDirectory
24054              0.038568         let toReturn = toReturn . '/'
30412              0.013644     endif
30412              0.030035     return toReturn

FUNCTION  33()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 380
Called 10863 times
Total time:   0.233313
 Self time:   0.125107

count  total (s)   self (s)
10863              0.011421     let i = 0
11833              0.022927     while i < len(g:NERDTreeSortOrder)
11639   0.176502   0.068297         if  self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
10669              0.008921             return i
  970              0.000591         endif
  970              0.001540         let i = i + 1
 1164              0.001024     endwhile
                            
  194              0.000603     return index(g:NERDTreeSortOrder, '*')

FUNCTION  35()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 409
Called 12608 times
Total time:   0.435583
 Self time:   0.390191

count  total (s)   self (s)
12608              0.033569     let l:ascending = index(g:NERDTreeSortOrder,'[[timestamp]]')
12608              0.029807     let l:descending = index(g:NERDTreeSortOrder,'[[-timestamp]]')
12608              0.046798     if !exists("self._sortKey") || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder || l:ascending >= 0 || l:descending >= 0
  815   0.040908   0.004279         let self._sortKey = [self.getSortOrderIndex()]
                            
  815              0.001183         if l:descending >= 0
                                        call insert(self._sortKey, -getftime(self.str()), l:descending == 0 ? 0 : len(self._sortKey))
  815              0.001110         elseif l:ascending >= 0
                                        call insert(self._sortKey, getftime(self.str()), l:ascending == 0 ? 0 : len(self._sortKey))
  815              0.000468         endif
                            
  815   0.012814   0.004050         let path = self.getLastPathComponent(1)
  815              0.001244         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
  815              0.000422         endif
  815              0.001182         if !g:NERDTreeCaseSensitiveSort
  815              0.002004             let path = tolower(path)
  815              0.000450         endif
                            
  815              0.004003         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
12608              0.005491     endif
12608              0.011493     return self._sortKey

FUNCTION  36()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 435
Called 1 time
Total time:   0.000343
 Self time:   0.000042

count  total (s)   self (s)
                            
    1   0.000308   0.000007     if !self.isUnder(a:path)
                                    return 0
    1              0.000001     endif
                            
    1              0.000004     let l:startIndex = len(a:path.pathSegments)
    1              0.000004     let l:segments = self.pathSegments[l:startIndex : ]
                            
    2              0.000005     for l:segment in l:segments
                            
    1              0.000007         if l:segment =~# '^\.'
                                        return 1
    1              0.000001         endif
    2              0.000002     endfor
                            
    1              0.000001     return 0

FUNCTION  39()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 477
Called 2957 times
Total time:   0.300507
 Self time:   0.145275

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
 2957   0.018494   0.012701     if a:nerdtree.ui.isIgnoreFilterEnabled()
 5914              0.009358         for i in g:NERDTreeIgnore
 2957   0.133382   0.014434             if self._ignorePatternMatches(i)
                                            return 1
 2957              0.001820             endif
 5914              0.004505         endfor
                            
 2957   0.036963   0.016607         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
 2957              0.002267         endfor
 2957              0.001831     endif
                            
                                "dont show hidden files unless instructed to
 2957   0.022334   0.017105     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
                                    return 1
 2957              0.001628     endif
                            
 2957   0.020214   0.015306     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
 2957              0.001633     endif
                            
 2957              0.002608     return 0

FUNCTION  168()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 470
Called 9 times
Total time:   3.150998
 Self time:   0.001503

count  total (s)   self (s)
    9              0.000071     let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
    9              0.000082     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
    9              0.000013     endif
                            
                                " Open any ancestors of this node that render within the same cascade.
    9              0.000043     let l:parent = self.parent
    9   0.004225   0.000153     while !empty(l:parent) && !l:parent.isRoot()
    4   0.000322   0.000183         if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
    4              0.000008         else
    4              0.000013             break
                                    endif
    9              0.000022     endwhile
                            
    9              0.000056     let self.isOpen = 1
                            
    9              0.000044     let l:numChildrenCached = 0
    9              0.000048     if empty(self.children)
    8   3.145647   0.000361         let l:numChildrenCached = self._initChildren(0)
    9              0.000030     endif
                            
    9              0.000027     return l:numChildrenCached

FUNCTION  <SNR>180_vimoption2python()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 54
Called 49 times
Total time:   0.028842
 Self time:   0.019165

count  total (s)   self (s)
   49              0.000155   let has_dash = 0
   49              0.000096   let patterns = []
  717              0.001215   for pattern in split(a:option, ',')
  668              0.001768     if pattern =~# '\d\+'
   51              0.000694       let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
  668              0.000319     endif
                            
  668              0.000672     if pattern ==# ''
                                  " ,
   94              0.000150       call add(patterns, ',')
  574              0.000567     elseif pattern ==# '\'
                                  call add(patterns, '\\')
  574              0.000542     elseif pattern ==# '-'
   47              0.000061       let has_dash = 1
  527              0.000259     else
                                  " Avoid ambiguous Python 3 RE syntax for nested sets
  527              0.001031       if pattern =~# '^--'
                                    let pattern = '\' . pattern
  527              0.001028       elseif pattern =~# '--$'
                                    let pattern = split(pattern, '-')[0] . '-\-'
  527              0.000227       endif
                            
  527              0.001180       call add(patterns, pattern)
  668              0.000318     endif
  717              0.000439   endfor
                            
                              " Dash must be last.
   49              0.000061   if has_dash
   47              0.000085     call add(patterns, '-')
   49              0.000031   endif
                            
   49   0.010531   0.000855   return join(deoplete#util#uniq(patterns), '')

FUNCTION  dein#autoload#_on_func()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim line 142
Called 8 times
Total time:   0.002667
 Self time:   0.000908

count  total (s)   self (s)
    8              0.000273   let function_prefix = substitute(a:name, '[^#]*$', '', '')
    8              0.000200   if function_prefix =~# '^dein#' || function_prefix =~# '^vital#' || has('vim_starting')
                                return
    8              0.000012   endif
                            
    8   0.002114   0.000355   call dein#autoload#_source(filter(dein#util#_get_lazy_plugins(),  "stridx(function_prefix, v:val.normalized_name.'#') == 0   || (index(get(v:val, 'on_func', []), a:name) >= 0)"))

FUNCTION  TSDeoplete()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 167
Called 1 time
Total time:   0.000083
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000081   0.000021 return remote#define#notify(17, "/home/ajs/config/nvim/repos/github.com/mhartington/nvim-typescript/rplugin/node/nvim_typescript:function:TSDeoplete", a:000)

FUNCTION  125()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 88
Called 182 times
Total time:   0.011939
 Self time:   0.002439

count  total (s)   self (s)
  182   0.011848   0.002347     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  127()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 112
Called 10 times
Total time:   0.002970
 Self time:   0.000102

count  total (s)   self (s)
   10   0.002934   0.000066     if a:path.equals(self.path)
    2              0.000005         return self
    8              0.000004     endif
    8              0.000008     return {}

FUNCTION  129()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 157
Called 5120 times
Total time:   0.009146
 Self time:   0.009146

count  total (s)   self (s)
 5120              0.007464     return self._nerdtree

FUNCTION  333()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 166
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000024     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  334()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 170
Called 2 times
Total time:   0.000323
 Self time:   0.000092

count  total (s)   self (s)
    2   0.000114   0.000034     let self._stamp = syntastic#util#stamp()
    4   0.000179   0.000029     for buf in self.getBuffers()
    2              0.000015         call setbufvar(buf, 'syntastic_loclist', self)
    4              0.000005     endfor

FUNCTION  335()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/loclist.vim line 177
Called 2 times
Total time:   0.000199
 Self time:   0.000052

count  total (s)   self (s)
    4   0.000172   0.000024     for buf in self.getBuffers()
    2              0.000014         call setbufvar(buf, 'syntastic_loclist', {})
    4              0.000004     endfor

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree.vim line 15
Called 10 times
Total time:   0.000302
 Self time:   0.000302

count  total (s)   self (s)
   10              0.000254     if !isdirectory(a:dir)
   10              0.000026         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  ale#util#Writefile()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 420
Called 52 times
Total time:   0.003804
 Self time:   0.003804

count  total (s)   self (s)
   52              0.000628     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
   52              0.003095     call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks

FUNCTION  wintabs#memoize#call()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/memoize.vim line 3
Called 6223 times
Total time:   0.296099
 Self time:   0.164758

count  total (s)   self (s)
 6223              0.093704   let hash = string(a:000)
 6223              0.036537   if has_key(s:cache, hash)
 6053              0.024499     return s:cache[hash]
  170              0.000220   else
  170   0.017847   0.014983     let value = call(a:1, a:000[1:])
  170              0.001579     let s:cache[hash] = value
  170              0.000341     return value
                              endif

FUNCTION  wintabs#gettabwinvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 2
Called 1429 times
Total time:   0.028004
 Self time:   0.028004

count  total (s)   self (s)
 1429              0.010527   let vars = gettabwinvar(a:tabnr, a:winnr, '')
 1429              0.004257   if empty(vars)
    1              0.000001     return a:def
 1428              0.001355   endif
 1428              0.006974   return get(vars, a:varname, a:def)

FUNCTION  <SNR>69_setup()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 219
Called 12 times
Total time:   0.096638
 Self time:   0.001484

count  total (s)   self (s)
   12              0.000064   let swap = a:0 && a:1 == 2
   12              0.000041   let enable = a:0 && a:1
   12              0.000037   let disable = a:0 && !a:1
                              " First, remove all magic, if needed:
   12              0.000063   if get(b:, 'delimitMate_enabled', 0)
    6   0.008118   0.000097     call s:Unmap()
                                " Switch
    6              0.000012     if swap
                                  echo "delimitMate is disabled."
                                  return
    6              0.000006     endif
   12              0.000012   endif
   12              0.000023   if disable
                                " Just disable the mappings.
                                return
   12              0.000011   endif
   12              0.000022   if !a:0
                                " Check if this file type is excluded:
   12              0.000133     if exists("g:delimitMate_excluded_ft") && index(split(g:delimitMate_excluded_ft, ','), &filetype, 0, 1) >= 0
                                  " Finish here:
                                  return 1
   12              0.000012     endif
                                " Check if user tried to disable using b:loaded_delimitMate
   12              0.000052     if exists("b:loaded_delimitMate")
                                  return 1
   12              0.000010     endif
   12              0.000012   endif
                              " Initialize settings:
   12   0.045727   0.000215   if ! s:init()
                                " Something went wrong.
                                return
   12              0.000010   endif
   12              0.000096   if enable || swap || !get(g:, 'delimitMate_offByDefault', 0)
                                " Now, add magic:
   12   0.041783   0.000161     call s:Map()
   12              0.000026     if a:0
                                  echo "delimitMate is enabled."
   12              0.000013     endif
   12              0.000011   endif

FUNCTION  40()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 507
Called 2957 times
Total time:   0.118947
 Self time:   0.080994

count  total (s)   self (s)
 2957              0.006279     let pat = a:pattern
 2957              0.010324     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
 2957              0.009292     elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
 2957              0.001660     endif
                            
 2957   0.058132   0.020178     return self.getLastPathComponent(0) =~# pat

FUNCTION  42()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 540
Called 3 times
Total time:   0.001220
 Self time:   0.000110

count  total (s)   self (s)
    3              0.000009     if a:path.isDirectory == 0
                                    return 0
    3              0.000003     endif
                            
    3   0.000569   0.000024     let this = self.str()
    3   0.000503   0.000027     let that = a:path.str()
    3   0.000127   0.000037     return stridx(this, that . s:Path.Slash()) == 0

FUNCTION  44()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 566
Called 78 times
Total time:   0.039248
 Self time:   0.003236

count  total (s)   self (s)
   78   0.002400   0.001038     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
   78              0.000120     else
   78   0.036211   0.001560         return self.str() ==# a:path.str()
                                endif

FUNCTION  45()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 575
Called 1432 times
Total time:   0.542932
 Self time:   0.073165

count  total (s)   self (s)
 1432              0.040430     let l:newPath = copy(self)
                            
 1432   0.473887   0.015859     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
 1432              0.003165     let l:newPath.cachedDisplayString = ''
 1432   0.021239   0.009499     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
 1432              0.001766     return l:newPath

FUNCTION  46()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 590
Called 11005 times
Total time:   0.218461
 Self time:   0.137421

count  total (s)   self (s)
                            
11005   0.147972   0.066932     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
11005              0.005142     endif
                            
11005              0.008782     return '/'

FUNCTION  47()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 608
Called 4269 times
Total time:   0.130716
 Self time:   0.130716

count  total (s)   self (s)
 4269              0.069908     let tmp = resolve(a:path)
 4269              0.059055     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  48()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 617
Called 2133 times
Total time:   0.466478
 Self time:   0.210827

count  total (s)   self (s)
 2133   0.065399   0.010330     call self.extractDriveLetter(a:fullpath)
                            
 2133   0.041958   0.012763     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
 2133              0.015162     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
 2133              0.001188     endif
                            
 2133              0.037030     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
 2133              0.005136     let self.isReadOnly = 0
 2133              0.009832     if isdirectory(a:fullpath)
 2050              0.003448         let self.isDirectory = 1
   83              0.000751     elseif filereadable(a:fullpath)
   83              0.000184         let self.isDirectory = 0
   83              0.000771         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
 2133              0.001029     endif
                            
 2133              0.003136     let self.isExecutable = 0
 2133              0.002507     if !self.isDirectory
   83              0.000717         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
 2133              0.000958     endif
                            
                                "grab the last part of the path (minus the trailing slash)
 2133   0.036217   0.013158     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
 2133   0.104768   0.020824     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
 2133   0.080389   0.016006     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
 2133              0.002610     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
 2133              0.000956     endif

FUNCTION  49()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 668
Called 701 times
Total time:   0.771531
 Self time:   0.015909

count  total (s)   self (s)
  701   0.211992   0.005716     call self.readInfoFromDisk(self.str())
  701   0.517621   0.006466     call g:NERDTreePathNotifier.NotifyListeners('refresh', self, a:nerdtree, {})
  701   0.041559   0.003369     call self.cacheDisplayString()

FUNCTION  <SNR>181_completion_timer_start()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 107
Called 47 times
Total time:   0.031277
 Self time:   0.002150

count  total (s)   self (s)
   47              0.000210   if exists('s:completion_timer')
                                call s:completion_timer_stop()
   47              0.000037   endif
                            
   47   0.000757   0.000554   let delay = deoplete#custom#_get_option('auto_complete_delay')
   47              0.000095   if delay > 0
                                let s:completion_timer = timer_start( delay, {-> deoplete#handler#_completion_begin(a:event)})
   47              0.000048   else
   47   0.029530   0.000606     call deoplete#handler#_completion_begin(a:event)
   47              0.000038   endif

FUNCTION  <SNR>25_trigger_before_open()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 307
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002     let trigger_name = 'before_open'
    1              0.000004     if !exists("s:triggers") || !has_key(s:triggers, trigger_name)
    1              0.000001         return
                                endif
                            
                                let g:leaderGuide#context = { 'type' : 'trigger', 'name' : trigger_name, 'display': s:lmap,  'level': s:current_level,  'register': s:reg, 'visual': s:vis == '', 'count': s:count, 'winv': s:winv, 'winnr': s:winnr, 'winres': s:winres }
                            
                                let Fun = s:triggers[trigger_name]
                                call Fun()

FUNCTION  <SNR>107_UpdateErrors()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 386
Called 2 times
Total time:   0.014510
 Self time:   0.000570

count  total (s)   self (s)
    2   0.000091   0.000038     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    2   0.000106   0.000046     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    2   0.000070   0.000026     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    2   0.000080   0.000045     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    2   0.000124   0.000031     call s:modemap.synch()
                            
    2   0.000421   0.000032     if s:_skip_file(a:buf)
                                    return
    2              0.000002     endif
                            
    2   0.000510   0.000034     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    2              0.000004     if run_checks
    2   0.009479   0.000046         call s:CacheErrors(a:buf, a:checker_names)
    2   0.000053   0.000032         call syntastic#util#setLastTick(a:buf)
                                elseif a:auto_invoked
                                    return
    2              0.000002     endif
                            
    2   0.000118   0.000023     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    2              0.000009     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
    2              0.000002     endif
                            
                                " populate loclist and jump {{{3
    2   0.000078   0.000024     let do_jump = syntastic#util#var('auto_jump') + 0
    2              0.000005     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
    2              0.000004     elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
    2              0.000006     elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
    2              0.000002     endif
                            
    2   0.000072   0.000023     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call loclist.setloclist(1)
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    2              0.000002     endif
                                " }}}3
                            
    2   0.003159   0.000022     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>168_obsolete_gitgutter_signs_to_remove()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/sign.vim line 138
Called 4 times
Total time:   0.000411
 Self time:   0.000316

count  total (s)   self (s)
    4              0.000022   let signs_to_remove = []  " list of [<id (number)>, ...]
    4              0.000017   let remove_all_signs = 1
    4   0.000184   0.000090   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
    4              0.000037   for line_number in keys(old_gitgutter_signs)
                                if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
                                  let remove_all_signs = 0
                                endif
    4              0.000007   endfor
    4              0.000026   let s:remove_all_old_signs = remove_all_signs
    4              0.000017   return signs_to_remove

FUNCTION  131()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 173
Called 8 times
Total time:   0.093165
 Self time:   0.000711

count  total (s)   self (s)
                            
    8              0.000031     try
    8   0.027916   0.000268         let l:path = b:NERDTree.ui.getPath(line('.'))
                            
    8              0.000039         if empty(l:path)
                                        return {}
    8              0.000014         endif
                            
    8   0.064999   0.000192         return b:NERDTree.root.findNode(l:path)
                                catch
                                    return {}
    8              0.000033     endtry

FUNCTION  133()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 196
Called 15 times
Total time:   0.008035
 Self time:   0.000541

count  total (s)   self (s)
   15   0.000297   0.000182     if !g:NERDTree.ExistsForBuf()
                                    throw "NERDTree.NoTreeError: No tree exists for the current buffer"
   15              0.000017     endif
                            
   15   0.007644   0.000263     return self.equals(self.getNerdtree().root)

FUNCTION  134()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 210
Called 719 times
Total time:   0.040439
 Self time:   0.007104

count  total (s)   self (s)
  719              0.001009     if a:path.isDirectory
  684   0.037628   0.004292         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
   35              0.000043     else
   35              0.000730         let newTreeNode = copy(self)
   35              0.000126         let newTreeNode.path = a:path
   35              0.000112         let newTreeNode.parent = {}
   35              0.000119         let newTreeNode._nerdtree = a:nerdtree
   35              0.000075         return newTreeNode
                                endif

FUNCTION  135()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 223
Called 1 time
Total time:   2.119447
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000010     let opts = a:0 ? a:1 : {}
    1   0.000218   0.000037     let opener = g:NERDTreeOpener.New(self.path, opts)
    1   2.119210   0.000020     call opener.open(self)

FUNCTION  139()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 256
Called 9 times
Total time:   0.015237
 Self time:   0.000581

count  total (s)   self (s)
    9   0.014834   0.000178     let ln = self.getNerdtree().ui.getLineNum(self)
    9              0.000023     if ln != -1
    9              0.000020         if a:isJump
    1              0.000002             mark '
    9              0.000010         endif
    9              0.000064         call cursor(ln, col("."))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
    9              0.000009     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/cursor.vim line 103
Called 263 times
Total time:   0.051936
 Self time:   0.036218

count  total (s)   self (s)
  263              0.002915     let l:buffer = bufnr('')
                            
  263              0.001565     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
  263              0.000430     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  263              0.002006     if mode(1) isnot# 'n'
   20              0.000027         return
  243              0.000318     endif
                            
  243   0.011649   0.006148     call s:StopCursorTimer()
                            
  243              0.003803     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  243              0.001569     if l:pos != s:last_pos
  238   0.015439   0.005223         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
  238              0.001581         let s:last_pos = l:pos
  238              0.004253         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  243              0.000456     endif

FUNCTION  wintabs#renderers#buf_label()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 116
Called 12 times
Total time:   0.001228
 Self time:   0.000623

count  total (s)   self (s)
   12              0.000055   let label = g:wintabs_ui_buffer_name_format
   12   0.000921   0.000317   let label = substitute(label, "%t", wintabs#renderers#bufname(a:bufnr), "g")
   12              0.000105   let label = substitute(label, "%n", a:bufnr, "g")
   12              0.000096   let label = substitute(label, "%o", a:config.ordinal, "g")
   12              0.000027   return label

FUNCTION  346()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/modemap.vim line 19
Called 2 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000015     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
    2              0.000003     else
    2              0.000013         let self._mode = 'active'
    2              0.000018         let self._activeFiletypes = []
    2              0.000005         let self._passiveFiletypes = []
    2              0.000002     endif

FUNCTION  348()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/modemap.vim line 42
Called 2 times
Total time:   0.000476
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000017     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    2              0.000010     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
    2              0.000002     endif
                            
    2   0.000437   0.000033     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  349()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/modemap.vim line 51
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000007     return self._mode ==# 'passive'

FUNCTION  <SNR>107_BufEnterHook()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 316
Called 10 times
Total time:   0.035153
 Self time:   0.001865

count  total (s)   self (s)
   10   0.008907   0.000277     let buf = syntastic#util#fname2buf(a:fname)
   10   0.000781   0.000407     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
   10              0.000089     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    7              0.000096         let idx = index(reverse(copy(s:_check_stack)), buf)
    7              0.000016         if idx >= 0
    2              0.000029             if !has('vim_starting')
    2              0.000023                 call remove(s:_check_stack, -idx - 1)
    2   0.014551   0.000041                 call s:UpdateErrors(buf, 1, [])
    2              0.000002             endif
    5              0.000019         elseif &buftype ==# ''
    5   0.009988   0.000214             call s:notifiers.refresh(g:SyntasticLoclist.current())
    7              0.000008         endif
    3              0.000016     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
   10              0.000011     endif

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/diff.vim line 204
Called 4 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    4              0.000020   let hunks = []
    4              0.000056   for line in split(a:diff, '\n')
                                let hunk_info = gitgutter#diff#parse_hunk(line)
                                if len(hunk_info) == 4
                                  call add(hunks, hunk_info)
                                endif
    4              0.000008   endfor
    4              0.000014   return hunks

FUNCTION  52()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 725
Called 6753 times
Total time:   0.697805
 Self time:   0.339308

count  total (s)   self (s)
 6753              0.016952     let options = a:0 ? a:1 : {}
 6753              0.008922     let toReturn = ""
                            
 6753              0.014566     if has_key(options, 'format')
   57              0.000274         let format = options['format']
   57              0.000333         if has_key(self, '_strFor' . format)
   57   0.007039   0.001007             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
   57              0.000068         endif
 6696              0.003619     else
 6696   0.358387   0.032659         let toReturn = self._str()
 6753              0.004358     endif
                            
 6753   0.070859   0.044642     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
 6753              0.003252     endif
                            
 6753              0.012565     if has_key(options, 'truncateTo')
   10              0.000037         let limit = options['truncateTo']
   10              0.000081         if strdisplaywidth(toReturn) > limit-1
   50              0.000425             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
   40              0.000341                 let toReturn = substitute(toReturn, '^.', '', '')
   50              0.000061             endwhile
   10              0.000121             if len(split(toReturn, '/')) > 1
   10              0.000176                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
   10              0.000011             endif
   10              0.000010         endif
 6753              0.003042     endif
                            
 6753              0.007777     return toReturn

FUNCTION  53()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 762
Called 32 times
Total time:   0.000920
 Self time:   0.000920

count  total (s)   self (s)
   32              0.000405     let toReturn = '/' . join(self.pathSegments, '/')
   32              0.000181     if self.isDirectory && toReturn != '/'
   31              0.000142         let toReturn  = toReturn . '/'
   32              0.000044     endif
   32              0.000088     return toReturn

FUNCTION  55()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 780
Called 1 time
Total time:   0.000380
 Self time:   0.000083

count  total (s)   self (s)
                            
                                " Make the path relative to the current working directory, if possible.
    1   0.000307   0.000027     let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
    1   0.000036   0.000020     if nerdtree#runningWindows() && l:result[0] == s:Path.Slash()
                                    let l:result = self.drive . l:result
    1              0.000001     endif
                            
    1              0.000011     let l:result = fnameescape(l:result)
                            
    1              0.000004     if empty(l:result)
                                    let l:result = '.'
    1              0.000001     endif
                            
    1              0.000003     return l:result

FUNCTION  57()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 820
Called 6696 times
Total time:   0.325728
 Self time:   0.144483

count  total (s)   self (s)
 6696   0.172614   0.034662     let l:separator = s:Path.Slash()
 6696              0.012703     let l:leader = l:separator
                            
 6696   0.083621   0.040328     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
 6696              0.003138     endif
                            
 6696              0.033919     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  58()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 833
Called 2133 times
Total time:   0.017959
 Self time:   0.017959

count  total (s)   self (s)
 2133              0.017272     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  59()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 841
Called 1 time
Total time:   0.000536
 Self time:   0.000276

count  total (s)   self (s)
    1   0.000272   0.000012     let str = self.str()
    4              0.000019     for t in range(tabpagenr('$'))
    7              0.000029         for b in tabpagebuflist(t+1)
    4              0.000143             if str ==# expand('#' . b . ':p')
                                            return t+1
    4              0.000005             endif
    7              0.000010         endfor
    4              0.000006     endfor
    1              0.000002     return 0

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 245
Called 2 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    2              0.000005     let l:msg = a:format_string
    2              0.000005     let l:severity = g:ale_echo_msg_warning_str
    2              0.000007     let l:code = get(a:item, 'code', '')
    2              0.000005     let l:type = get(a:item, 'type', 'E')
    2              0.000006     let l:linter_name = get(a:item, 'linter_name', '')
    2              0.000007     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
    2              0.000004     if l:type is# 'E'
    2              0.000005         let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
    2              0.000001     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
    2              0.000021     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
    2              0.000012     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
    2              0.000034     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
    2              0.000015     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
    2              0.000003     return l:msg

FUNCTION  <SNR>109_tabnum()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 140
Called 240 times
Total time:   0.001996
 Self time:   0.001996

count  total (s)   self (s)
  240              0.000561     if a:ubiquitous
  120              0.000228         return a:tabnr
  120              0.000166     endif
  120              0.000580     return a:tabnr == tabpagenr() ? a:tabnr : ''

FUNCTION  <SNR>181_is_skip()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 197
Called 76 times
Total time:   0.016893
 Self time:   0.002979

count  total (s)   self (s)
   76              0.000410   if a:event ==# 'TextChangedP' && !empty(v:completed_item)
                                return 1
   76              0.000059   endif
                            
   76   0.014800   0.001016   if s:is_skip_text(a:event)
   38              0.000041     return 1
   38              0.000026   endif
                            
   38   0.000582   0.000452   let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
   38              0.000409   if &paste || (a:event !=# 'Manual' && a:event !=# 'Async' && !auto_complete) || (&l:completefunc !=# '' && &l:buftype =~# 'nofile') || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
   38              0.000024   endif
                            
   38              0.000044   return 0

FUNCTION  207()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 184
Called 3 times
Total time:   0.232349
 Self time:   0.012437

count  total (s)   self (s)
    3              0.000041     let l:splitLocation = g:NERDTreeWinPos ==# 'left' ? 'topleft ' : 'botright '
    3              0.000019     let l:splitSize = g:NERDTreeWinSize
                            
    3   0.000438   0.000041     if !g:NERDTree.ExistsForTab()
    2   0.000131   0.000026         let t:NERDTreeBufName = self._nextBufferName()
    2   0.069386   0.001041         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' new'
    2   0.059011   0.010045         silent! execute 'edit ' . t:NERDTreeBufName
    1              0.000003     else
    1   0.002771   0.000494         silent! execute l:splitLocation . 'vertical ' . l:splitSize . ' split'
    1   0.015958   0.000471         silent! execute 'buffer ' . t:NERDTreeBufName
    3              0.000005     endif
                            
    3   0.084177   0.000054     call self._setCommonBufOptions()
                            
    3              0.000035     if has('patch-7.4.1925')
    3              0.000027         clearjumps
    3              0.000004     endif
                            
    3   0.000246   0.000033     setlocal winfixwidth

FUNCTION  <SNR>156_IsBoolean()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 75
Called 12 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   12              0.000091     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  140()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 277
Called 23 times
Total time:   0.017830
 Self time:   0.000180

count  total (s)   self (s)
   23   0.017822   0.000172     call self.path.refresh(self.getNerdtree())

FUNCTION  143()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 304
Called 10 times
Total time:   0.583352
 Self time:   0.000146

count  total (s)   self (s)
   10   0.583345   0.000138     return self._renderToString(0, 0)

FUNCTION  144()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 313
Called 2286 times
Total time:   1.401805
 Self time:   1.210704

count  total (s)   self (s)
 2286              0.003011     let output = ""
 2286              0.002730     if a:drawText ==# 1
                            
 2276              0.005761         let treeParts = repeat('  ', a:depth - 1)
                            
 2276              0.003420         if !self.path.isDirectory
  182              0.000530             let treeParts = treeParts . '  '
 2276              0.001267         endif
                            
 2276   0.200165   0.013320         let line = treeParts . self.displayString()
                            
 2276              0.004828         let output = output . line . "\n"
 2286              0.001150     endif
                            
                                " if the node is an open dir, draw its children
 2286              0.004113     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   37   0.293209   0.000356         let childNodesToDraw = self.getVisibleChildren()
                            
   37   0.000507   0.000293         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
   37              0.000135         elseif len(childNodesToDraw) > 0
 2313              0.002031             for i in childNodesToDraw
 2276              0.010450                 let output = output . i._renderToString(a:depth + 1, 1)
 2313              0.001400             endfor
   37              0.000030         endif
 2286              0.001036     endif
                            
 2286              0.002391     return output

FUNCTION  147()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 45
Called 719 times
Total time:   0.007674
 Self time:   0.007674

count  total (s)   self (s)
  719              0.002697     call add(self.children, a:treenode)
  719              0.001666     let a:treenode.parent = self
                            
  719              0.000823     if a:inOrder
                                    call self.sortChildren()
  719              0.000418     endif

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/diff.vim line 230
Called 4 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    4              0.000020   let modified_lines = []
    4              0.000019   for hunk in a:hunks
                                call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
    4              0.000009   endfor
    4              0.000014   return modified_lines

FUNCTION  <SNR>25_winopen()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 393
Called 1 time
Total time:   0.006549
 Self time:   0.000291

count  total (s)   self (s)
    1              0.000002     if !exists('s:bufnr')
    1              0.000002         let s:bufnr = -1
    1              0.000000     endif
    1              0.000003     let pos = g:leaderGuide_position ==? 'topleft' ? 'topleft' : 'botright'
    1              0.000003     if bufexists(s:bufnr)
                                    let qfbuf = &buftype ==# 'quickfix'
                                    let splitcmd = g:leaderGuide_vertical ? ' 1vs' : ' 1sp'
                                    noautocmd execute pos.splitcmd
                                    let bnum = bufnr('%')
                                    noautocmd execute 'buffer '.s:bufnr
                                    cmapclear <buffer>
                                    if qfbuf
                                        noautocmd execute bnum.'bwipeout!'
                                    endif
    1              0.000001     else
    1              0.000002         let splitcmd = g:leaderGuide_vertical ? ' 1vnew' : ' 1new'
    1              0.000183         noautocmd execute pos.splitcmd
    1              0.000005         let s:bufnr = bufnr('%')
    1              0.000009         autocmd WinLeave <buffer> call s:winclose()
    1              0.000001     endif
    1              0.000003     let s:gwin = winnr()
    1   0.005867   0.000007     setlocal filetype=leaderGuide
    1   0.000135   0.000015     setlocal nonumber norelativenumber nolist nomodeline nowrap nopaste
    1   0.000144   0.000011     setlocal nobuflisted buftype=nofile bufhidden=unload noswapfile
    1   0.000068   0.000007     setlocal nocursorline nocursorcolumn colorcolumn=
    1   0.000045   0.000005     setlocal winfixwidth winfixheight
    1   0.000049   0.000004     setlocal statusline=\ Leader\ Guide

FUNCTION  354()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/modemap.vim line 112
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000033     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  356()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/notifiers.vim line 25
Called 7 times
Total time:   0.012256
 Self time:   0.003976

count  total (s)   self (s)
    7   0.000726   0.000251     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
    7              0.000008     endif
                            
    7   0.000268   0.000108     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   42              0.000137     for type in self._enabled_types
   35              0.000635         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   35   0.001789   0.000673         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   28              0.000167             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    7              0.000069                 if !exists('b:syntastic_private_' . type . '_stamp')
    2              0.000021                     let b:syntastic_private_{type}_stamp = []
    7              0.000009                 endif
    7   0.000668   0.000152                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    7   0.002089   0.000087                     call self._notifier[type].refresh(a:loclist)
    7   0.000494   0.000187                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    7              0.000013                 endif
   21              0.000025             else
   21   0.003968   0.000264                 call self._notifier[type].refresh(a:loclist)
   28              0.000030             endif
   35              0.000032         endif
   42              0.000065     endfor

FUNCTION  357()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/notifiers.vim line 51
Called 2 times
Total time:   0.001048
 Self time:   0.000627

count  total (s)   self (s)
    2   0.000075   0.000030     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
   12              0.000029     for type in self._enabled_types
   10              0.000156         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   10              0.000092         if has_key(g:{class}, 'reset')
    6   0.000460   0.000085             call self._notifier[type].reset(a:loclist)
   10              0.000009         endif
                            
                                    " also reset stamps
   10              0.000055         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    4              0.000039             let b:syntastic_private_{type}_stamp = []
   10              0.000008         endif
   12              0.000016     endfor

FUNCTION  359()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 165
Called 4 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    4              0.000039     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
    4              0.000005     endif
                            
    4              0.000015     return s:SyntasticRegistryInstance

FUNCTION  <SNR>84_persist()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/obsession.vim line 69
Called 10 times
Total time:   0.066382
 Self time:   0.066092

count  total (s)   self (s)
   10              0.000094   if exists('g:SessionLoad')
                                return ''
   10              0.000013   endif
   10              0.000075   let sessionoptions = &sessionoptions
   10              0.000059   if exists('g:this_obsession')
   10              0.000022     try
   10              0.000566       set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
   10              0.020682       execute 'mksession! '.fnameescape(g:this_obsession)
   10              0.003451       let body = readfile(g:this_obsession)
   10              0.000144       call insert(body, 'let g:this_session = v:this_session', -3)
   10              0.000060       call insert(body, 'let g:this_obsession = v:this_session', -3)
   10              0.000135       if type(get(g:, 'obsession_append')) == type([])
                                    for line in g:obsession_append
                                      call insert(body, line, -3)
                                    endfor
   10              0.000017       endif
   10              0.039240       call writefile(body, g:this_obsession)
   10              0.000274       let g:this_session = g:this_obsession
   10   0.000729   0.000440       exe s:doautocmd_user('Obsession')
                                catch
                                  unlet g:this_obsession
                                  let &l:readonly = &l:readonly
                                  return 'echoerr '.string(v:exception)
   10              0.000030     finally
   10              0.000183       let &sessionoptions = sessionoptions
   10              0.000028     endtry
   10              0.000016   endif
   10              0.000025   return ''

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 81
Called 52 times
Total time:   0.000866
 Self time:   0.000866

count  total (s)   self (s)
   52              0.000234     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
    1              0.000014         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
    1              0.000002         return 1
   51              0.000042     endif
                            
   51              0.000064     return 0

FUNCTION  ale#command#FormatCommand()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 140
Called 52 times
Total time:   0.026226
 Self time:   0.009552

count  total (s)   self (s)
   52              0.000151     let l:temporary_file = ''
   52              0.000146     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   52              0.000635     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
   52              0.000349     if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
   52              0.000038     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   52              0.000154     if l:command =~# '%s'
   52              0.001353         let l:filename = fnamemodify(bufname(a:buffer), ':p')
   52   0.002299   0.001172         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
   52              0.000051     endif
                            
   52              0.000325     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
   52              0.000038     endif
                            
                                " Finish formatting so %% becomes %.
   52              0.000669     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   52              0.000215     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
   52   0.004543   0.000823         let l:temporary_file = s:TemporaryFilename(a:buffer)
   52   0.001561   0.000595         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
   52              0.000043     endif
                            
   52   0.012179   0.001318     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
   52              0.000268     return [l:temporary_file, l:command, l:file_created]

FUNCTION  60()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 860
Called 2133 times
Total time:   0.029195
 Self time:   0.015728

count  total (s)   self (s)
 2133   0.025318   0.011850     if !nerdtree#runningWindows()
 2133              0.002792         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  riv#show_menu()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/riv.vim line 111
Called 23 times
Total time:   0.003298
 Self time:   0.003298

count  total (s)   self (s)
   23              0.001052     sil! menu disable Riv.*
   23              0.000407     if &ft != 'rst'
   23              0.000221         sil! menu enable Riv.Project
   23              0.000162         sil! menu enable Riv.Project.*
   23              0.000120         sil! menu enable Riv.Scratch
   23              0.000163         sil! menu enable Riv.Scratch.*
   23              0.000166         sil! menu enable Riv.Helper
   23              0.000158         sil! menu enable Riv.Helper.*
   23              0.000277         sil! menu enable Riv.About
   23              0.000312         sil! menu enable Riv.About.*
                                else
                                    sil! menu enable Riv.*
   23              0.000035     endif

FUNCTION  <SNR>78_on_bufenter()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/gitgutter.vim line 188
Called 10 times
Total time:   0.047268
 Self time:   0.000837

count  total (s)   self (s)
   10              0.000096   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
    1              0.000005     let t:gitgutter_didtabenter = 0
    1   0.010747   0.000077     call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    9              0.000015   else
    9   0.005329   0.000214     call gitgutter#init_buffer(bufnr(''))
    9   0.030914   0.000267     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
   10              0.000014   endif

FUNCTION  wintabs#renderers#buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 14
Called 12 times
Total time:   0.001577
 Self time:   0.000350

count  total (s)   self (s)
   12              0.000071   let is_active = a:config.is_active && a:config.is_active_window
   12   0.001492   0.000264   return {'label': wintabs#renderers#buf_label(a:bufnr, a:config),'highlight': is_active ? g:wintabs_ui_active_higroup : '',}

FUNCTION  150()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 86
Called 719 times
Total time:   0.063578
 Self time:   0.014166

count  total (s)   self (s)
  719   0.048791   0.007052     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
  719   0.013426   0.005752     call self.addChild(newTreeNode, a:inOrder)
  719              0.000940     return newTreeNode

FUNCTION  151()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 95
Called 2094 times
Total time:   0.174905
 Self time:   0.082670

count  total (s)   self (s)
 2094              0.002692     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
 2094              0.002311     let l:label = ''
 2094   0.025143   0.008755     let l:cascade = self.getCascade()
 4188              0.005292     for l:dirNode in l:cascade
 2094   0.056706   0.008880         let l:next = l:dirNode.path.displayString()
 2094              0.007337         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
 4188              0.002390     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
 2094              0.003125     if l:cascade[-1].isOpen
   27              0.000088         let l:symbol = g:NERDTreeDirArrowCollapsible
 2067              0.001120     else
 2067              0.003538         let l:symbol = g:NERDTreeDirArrowExpandable
 2094              0.000989     endif
                            
 2094   0.039125   0.011105     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
 2094              0.005750     let l:result = l:symbol . ' ' . l:flags . l:label
 2094              0.002132     return l:result

FUNCTION  152()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 125
Called 67 times
Total time:   0.152711
 Self time:   0.034057

count  total (s)   self (s)
   67   0.036987   0.000883     if a:path.equals(self.path)
    7              0.000023         return self
   60              0.000064     endif
   60   0.028925   0.001530     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   40              0.000098         return {}
   20              0.000024     endif
                            
   20              0.000073     if self.path.isDirectory
   68              0.000340         for i in self.children
   68   0.003652   0.000682             let retVal = i.findNode(a:path)
   68              0.000245             if retVal != {}
   20              0.000059                 return retVal
   48              0.000061             endif
   48              0.000085         endfor
                                endif
                                return {}

FUNCTION  155()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 185
Called 714 times
Total time:   0.001669
 Self time:   0.001669

count  total (s)   self (s)
  714              0.001453     return len(self.children)

FUNCTION  156()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 197
Called 700 times
Total time:   0.855480
 Self time:   0.014923

count  total (s)   self (s)
  700   0.134085   0.006785     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return {}
  700              0.000281     endif
                            
  700   0.717103   0.003846     let index = self.getChildIndex(a:path)
  700              0.000705     if index ==# -1
                                    return {}
  700              0.000334     else
  700              0.001103         return self.children[index]
                                endif
                            

FUNCTION  157()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 218
Called 6 times
Total time:   0.059838
 Self time:   0.000167

count  total (s)   self (s)
    6   0.059753   0.000082     let array_to_search = a:visible? self.getVisibleChildren() : self.children
    6              0.000031     if a:indx > len(array_to_search)
                                    throw "NERDTree.InvalidArgumentsError: Index is out of bounds."
    6              0.000005     endif
    6              0.000024     return array_to_search[a:indx]

FUNCTION  158()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 234
Called 700 times
Total time:   0.713257
 Self time:   0.103355

count  total (s)   self (s)
  700   0.123921   0.005837     if stridx(a:path.str(), self.path.str(), 0) ==# -1
                                    return -1
  700              0.000284     endif
                            
                                "do a binary search for the child
  700              0.000887     let a = 0
  700   0.004697   0.003121     let z = self.getChildCount()
 5724              0.005422     while a < z
 5724              0.008506         let mid = (a+z)/2
 5724   0.530256   0.040014         let diff = a:path.compareTo(self.children[mid].path)
                            
 5724              0.005290         if diff ==# -1
 2678              0.002733             let z = mid
 3046              0.002836         elseif diff ==# 1
 2346              0.002659             let a = mid+1
  700              0.000338         else
  700              0.000576             return mid
 5024              0.002577         endif
 5024              0.003385     endwhile
                                return -1

FUNCTION  <SNR>79_not_git_dir()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 63
Called 13 times
Total time:   0.003338
 Self time:   0.000532

count  total (s)   self (s)
   13   0.003321   0.000514   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  415()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 470
Called 12 times
Total time:   0.000255
 Self time:   0.000177

count  total (s)   self (s)
   12   0.000245   0.000167   return self.size() == 0

FUNCTION  360()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 174
Called 2 times
Total time:   0.000872
 Self time:   0.000221

count  total (s)   self (s)
    2   0.000100   0.000047     let registry = g:SyntasticRegistry.Instance()
                            
    2              0.000011     if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft, 1)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
    2              0.000003     else
    2   0.000492   0.000042         let checker = g:SyntasticChecker.New(a:args)
    2              0.000003     endif
    2   0.000184   0.000036     call registry._registerChecker(checker)

FUNCTION  361()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 197
Called 2 times
Total time:   0.004349
 Self time:   0.000412

count  total (s)   self (s)
    2   0.000138   0.000021     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    2              0.000022     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    2              0.000004     let cnames = []
    2              0.000006     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
    2              0.000002     else
    4              0.000010         for ft in ftlist
    2   0.000107   0.000022             call self._sanityCheck(ft)
    2              0.000037             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    2              0.000045             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    4              0.000007         endfor
    2              0.000002     endif
    2   0.000141   0.000031     let cnames = syntastic#util#unique(cnames)
                            
    3   0.000139   0.000053     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    1   0.003417   0.000022         call self._loadCheckersFor(ft, 0)
    3              0.000006     endfor
                            
    2   0.000173   0.000029     return self._filterCheckersByName(cnames)

FUNCTION  366()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 267
Called 4 times
Total time:   0.000301
 Self time:   0.000183

count  total (s)   self (s)
    4   0.000294   0.000176     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  368()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 336
Called 2 times
Total time:   0.000148
 Self time:   0.000130

count  total (s)   self (s)
    2   0.000038   0.000029     let ft = a:checker.getFiletype()
    2              0.000012     if !has_key(self._checkerMap, ft)
    1              0.000011         let self._checkerMap[ft] = {}
    2              0.000003     endif
                            
    2   0.000033   0.000024     let name = a:checker.getName()
    2              0.000013     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
    2              0.000002     endif
                            
    2              0.000015     let self._checkerMap[ft][name] = a:checker

FUNCTION  369()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 350
Called 2 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    2              0.000017     let sep_idx = stridx(a:cname, '/')
    2              0.000007     if sep_idx > 0
    2              0.000012         let ft = a:cname[: sep_idx-1]
    2              0.000011         let name = a:cname[sep_idx+1 :]
                                else
                                    let ft = &filetype
                                    let name = a:cname
    2              0.000002     endif
    2              0.000018     return get(self._checkerMap[ft], name, {})

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 42
Called 5 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    5              0.000040     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>11_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim line 33
Called 7 times
Total time:   0.114686
 Self time:   0.006081

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    7              0.000709   syn clear
    7              0.000041   if exists("b:current_syntax")
                                unlet b:current_syntax
    7              0.000009   endif
                            
    7              0.000042   let s = expand("<amatch>")
    7              0.000020   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    7              0.000018   elseif s == "OFF"
                                let s = ""
    7              0.000007   endif
                            
    7              0.000015   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   14              0.000180     for name in split(s, '\.')
    7   0.113406   0.004801       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   14              0.000032     endfor
    7              0.000010   endif

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 100
Called 62 times
Total time:   0.001069
 Self time:   0.001069

count  total (s)   self (s)
   62              0.000363     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   62              0.000581     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  160()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 277
Called 30 times
Total time:   0.052105
 Self time:   0.037460

count  total (s)   self (s)
                            
                                " Construct a path specification such that "globpath()" will return
                                " relative pathnames, if possible.
   30   0.006978   0.000633     if self.path.str() == getcwd()
    6              0.000023         let l:pathSpec = ','
   24              0.000028     else
   24   0.008751   0.000777         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                            
                                    " On Windows, the drive letter may be removed by "fnamemodify()".
   24   0.000713   0.000386         if nerdtree#runningWindows() && l:pathSpec[0] == g:NERDTreePath.Slash()
                                        let l:pathSpec = self.path.drive . l:pathSpec
   24              0.000031         endif
   30              0.000030     endif
                            
   30              0.000116     let l:globList = []
                            
                                " See ":h version7.txt" and ":h version8.txt" for details on the
                                " development of the "glob()" and "globpath()" functions.
   30              0.000178     if v:version > 704 || (v:version == 704 && has('patch654'))
   30              0.030846         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                elseif v:version == 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version == 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
   30              0.000035     endif
                            
                                " If "a:all" is false, filter "." and ".." from the output.
   30              0.000076     if !a:all
   15              0.000052         let l:toRemove = []
                            
   30              0.000126         for l:file in l:globList
   30              0.000195             let l:tail = fnamemodify(l:file, ':t')
                            
                                        " If l:file has a trailing slash, then its :tail will be ''. Use
                                        " :h to drop the slash and the empty string after it; then use :t
                                        " to get the directory name.
   30              0.000088             if l:tail == ''
                                            let l:tail = fnamemodify(l:file, ':h:t')
   30              0.000032             endif
                            
   30              0.000121             if l:tail == '.' || l:tail == '..'
   30              0.000178                 call add(l:toRemove, l:file)
   30              0.000118                 if len(l:toRemove) == 2
   15              0.000027                     break
   15              0.000014                 endif
   15              0.000014             endif
   30              0.000075         endfor
                            
   45              0.000106         for l:file in l:toRemove
   30              0.000216             call remove(l:globList, index(l:globList, l:file))
   45              0.000060         endfor
   30              0.000034     endif
                            
   30              0.000091     return l:globList

FUNCTION  163()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 363
Called 43 times
Total time:   0.352524
 Self time:   0.046612

count  total (s)   self (s)
   43              0.000136     let toReturn = []
 3000              0.005865     for i in self.children
 2957   0.334042   0.028130         if i.path.ignore(self.getNerdtree()) ==# 0
 2957              0.007179             call add(toReturn, i)
 2957              0.001700         endif
 3000              0.002014     endfor
   43              0.000073     return toReturn

FUNCTION  165()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 385
Called 2135 times
Total time:   0.005804
 Self time:   0.005804

count  total (s)   self (s)
 2135              0.003219     if g:NERDTreeCascadeSingleChildDir == 0
 2135              0.001750         return 0
                                endif
                            
                                if self.path.isSymLink
                                    return 0
                                endif
                            
                                for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
                                endfor
                            
                                let c = self.getVisibleChildren()
                                return len(c) == 1 && c[0].path.isDirectory

FUNCTION  166()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 412
Called 8 times
Total time:   3.145286
 Self time:   0.026254

count  total (s)   self (s)
                                "remove all the current child nodes
    8              0.000048     let self.children = []
                            
    8   0.037282   0.000862     let files = self._glob('*', 1) + self._glob('.*', 0)
                            
    8              0.000093     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
    1   0.000206   0.000109         call nerdtree#echo("Please wait, caching a large dir ...")
    8              0.000013     endif
                            
    8              0.000045     let invalidFilesFound = 0
  727              0.001075     for i in files
  719              0.000653         try
  719   0.298892   0.005465             let path = g:NERDTreePath.New(i)
  719   0.068017   0.004439             call self.createChild(path, 0)
  719   2.314288   0.008968             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                    catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
  719              0.000678         endtry
  727              0.000543     endfor
                            
    8   0.387758   0.000100     call self.sortChildren()
                            
    8   0.032615   0.000137     call nerdtree#echo("")
                            
    8              0.000027     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . " file(s) could not be loaded into the NERD tree")
    8              0.000009     endif
    8   0.000181   0.000126     return self.getChildCount()

FUNCTION  167()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 449
Called 686 times
Total time:   0.033693
 Self time:   0.033693

count  total (s)   self (s)
  686              0.001097     if a:path.isDirectory != 1
                                    throw "NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object."
  686              0.000397     endif
                            
  686              0.021926     let newTreeNode = copy(self)
  686              0.001549     let newTreeNode.path = a:path
                            
  686              0.001213     let newTreeNode.isOpen = 0
  686              0.001327     let newTreeNode.children = []
                            
  686              0.001206     let newTreeNode.parent = {}
  686              0.001390     let newTreeNode._nerdtree = a:nerdtree
                            
  686              0.000887     return newTreeNode

FUNCTION  ale#Var()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 186
Called 635 times
Total time:   0.018211
 Self time:   0.018211

count  total (s)   self (s)
  635              0.003978     let l:full_name = 'ale_' . a:variable_name
  635              0.007140     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  635              0.005530     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  370()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 362
Called 2 times
Total time:   0.000144
 Self time:   0.000061

count  total (s)   self (s)
    2   0.000143   0.000059     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  371()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 366
Called 1 time
Total time:   0.003395
 Self time:   0.000836

count  total (s)   self (s)
    1              0.000009     if !a:force && has_key(self._checkerMap, a:filetype)
                                    return
    1              0.000002     endif
                            
    1   0.003363   0.000803     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    1              0.000009     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
    1              0.000002     endif

FUNCTION  372()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 379
Called 2 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    2              0.000023     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
    2              0.000002     endif
                            
    2              0.000022     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
    2              0.000002     endif

FUNCTION  374()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/signs.vim line 27
Called 14 times
Total time:   0.000730
 Self time:   0.000271

count  total (s)   self (s)
   14   0.000719   0.000260     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  375()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/signs.vim line 31
Called 7 times
Total time:   0.002002
 Self time:   0.000556

count  total (s)   self (s)
    7   0.000258   0.000104     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    7   0.000207   0.000085     let old_signs = copy(self._bufSignIds())
    7   0.000385   0.000054     if self.enabled()
    7              0.000019         if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
    7              0.000009         endif
                            
    7   0.000746   0.000107         call self._signErrors(a:loclist)
    7              0.000008     endif
    7   0.000283   0.000083     call self._removeSigns(old_signs)

FUNCTION  377()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/signs.vim line 86
Called 7 times
Total time:   0.000639
 Self time:   0.000608

count  total (s)   self (s)
    7              0.000029     let loclist = a:loclist
    7   0.000086   0.000055     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
    7              0.000008     endif

FUNCTION  378()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/signs.vim line 119
Called 7 times
Total time:   0.000200
 Self time:   0.000200

count  total (s)   self (s)
    7              0.000047     if has('signs')
    7              0.000054         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
    7              0.000015         endfor
    7              0.000008     endif

FUNCTION  379()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/signs.vim line 129
Called 7 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    7              0.000041     if !exists('b:syntastic_private_sign_ids')
    4              0.000020         let b:syntastic_private_sign_ids = []
    7              0.000009     endif
    7              0.000022     return b:syntastic_private_sign_ids

FUNCTION  ale#job#Stop()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/job.vim line 346
Called 47 times
Total time:   0.002947
 Self time:   0.002947

count  total (s)   self (s)
   47              0.000230     if !has_key(s:job_map, a:job_id)
                                    return
   47              0.000037     endif
                            
   47              0.000295     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
   47              0.001010         silent! call jobstop(a:job_id)
                                else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
   47              0.000034     endif

FUNCTION  <SNR>25_escape_mappings()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 177
Called 14 times
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
   14              0.000051     let feedkeyargs = a:mapping.noremap ? "nt" : "mt"
   14              0.000095     let rstring = substitute(a:mapping.rhs, '\', '\\\\', 'g')
   14              0.000154     let rstring = substitute(rstring, '<\([^<>]*\)>', '\\<\1>', 'g')
   14              0.000062     let rstring = substitute(rstring, '"', '\\"', 'g')
   14              0.000064     let rstring = 'call feedkeys("'.rstring.'", "'.feedkeyargs.'")'
   14              0.000024     return rstring

FUNCTION  <SNR>109_tabpwd()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 122
Called 240 times
Total time:   0.014459
 Self time:   0.010686

count  total (s)   self (s)
  240              0.000908   if a:tabnr == tabpagenr()
   80   0.003609   0.001603     cal s:settabvar(a:tabnr, "taboo_tab_wd", getcwd())
  240              0.000239   endif
                            
  240   0.004676   0.002909   let tabcwd = s:gettabvar(a:tabnr, "taboo_tab_wd")
                            
  240              0.000519   if a:last_component
  120              0.001589     let tabcwd = get(split(tabcwd, "/"), -1, "")
  240              0.000245   endif
                            
  240              0.000485   return tabcwd

FUNCTION  deoplete#util#rpcnotify()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 155
Called 86 times
Total time:   0.010183
 Self time:   0.006983

count  total (s)   self (s)
   86   0.002122   0.001396   if !deoplete#init#_channel_initialized()
                                return ''
   86              0.000071   endif
                            
   86              0.000408   let a:context['rpc'] = a:method
                            
   86   0.003429   0.000954   if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:method, a:context)
   86              0.000087   else
   86              0.002578     call rpcnotify(g:deoplete#_channel_id, a:method, a:context)
   86              0.000101   endif
                            
   86              0.000128   return ''

FUNCTION  85()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/key_map.vim line 30
Called 10 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
   10              0.000193     return get(s:keyMaps, a:key . a:scope, {})

FUNCTION  86()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/key_map.vim line 35
Called 3 times
Total time:   0.019163
 Self time:   0.002999

count  total (s)   self (s)
  159              0.000671     for i in values(s:keyMaps)
  156   0.018120   0.001957         call i.bind()
  159              0.000277     endfor

FUNCTION  87()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/key_map.vim line 42
Called 156 times
Total time:   0.016163
 Self time:   0.016163

count  total (s)   self (s)
                                " If the key sequence we're trying to map contains any '<>' notation, we
                                " must replace each of the '<' characters with '<lt>' to ensure the string
                                " is not translated into its corresponding keycode during the later part
                                " of the map command below
                                " :he <>
  156              0.000865     let specialNotationRegex = '\m<\([[:alnum:]_-]\+>\)'
  156              0.001659     if self.key =~# specialNotationRegex
   24              0.000542         let keymapInvokeString = substitute(self.key, specialNotationRegex, '<lt>\1', 'g')
  132              0.000191     else
  132              0.000591         let keymapInvokeString = self.key
  156              0.000205     endif
  156              0.001137     let keymapInvokeString = escape(keymapInvokeString, '\')
                            
  156              0.000832     let premap = self.key == "<LeftRelease>" ? " <LeftRelease>" : " "
                            
  156              0.007967     exec 'nnoremap <buffer> <silent> '. self.key . premap . ':call nerdtree#ui_glue#invokeKeyMap("'. keymapInvokeString .'")<cr>'

FUNCTION  89()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/key_map.vim line 68
Called 8 times
Total time:   7.063158
 Self time:   0.000547

count  total (s)   self (s)
    8              0.000166     let Callback = function(self.callback)
    8              0.000027     if a:0
    7   4.671650   0.000218         call Callback(a:1)
    1              0.000002     else
    1   2.391212   0.000033         call Callback()
    8              0.000008     endif

FUNCTION  gitgutter#debug#log()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/debug.vim line 80
Called 10 times
Total time:   0.000791
 Self time:   0.000791

count  total (s)   self (s)
   10              0.000041   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   10              0.000014   endif

FUNCTION  ale#command#Run()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 252
Called 52 times
Total time:   0.160121
 Self time:   0.018429

count  total (s)   self (s)
   52              0.000308     let l:options = get(a:000, 0, {})
                            
   52              0.000146     if len(a:000) > 1
                                    throw 'Too many arguments!'
   52              0.000039     endif
                            
   52              0.000255     let l:output_stream = get(l:options, 'output_stream', 'stdout')
   52              0.000117     let l:line_list = []
                            
   52   0.027552   0.001326     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),)
   52   0.005585   0.001083     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
   52              0.001139     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
   52              0.000155     if l:output_stream is# 'stdout'
   52              0.000611         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
   52              0.000039     endif
                            
   52              0.000120     let l:status = 'failed'
                            
   52              0.000217     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
   52              0.000269     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
   52              0.000043     else
   52   0.106818   0.001678         let l:job_id = ale#job#Start(l:command, l:job_options)
   52              0.000153     endif
                            
   52              0.000074     if l:job_id
   52              0.000199         let l:status = 'started'
   52              0.000445         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
   52   0.003007   0.002088         call ale#command#InitData(a:buffer)
   52              0.000462         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
   52              0.000041     endif
                            
   52              0.000118     if g:ale_history_enabled
   52   0.005928   0.001022         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
   52              0.000043     endif
                            
   52              0.000082     if !l:job_id
                                    return 0
   52              0.000035     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
   52              0.000599     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
   52              0.000229     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
   52              0.000044     endif
                            
   52              0.000133     return l:result

FUNCTION  <SNR>109_gettabvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 283
Called 492 times
Total time:   0.004290
 Self time:   0.004290

count  total (s)   self (s)
  492              0.001322     if v:version > 702
  492              0.002541         return gettabvar(a:tabnr, a:var)
                                endif
                                for winnr in s:windows(a:tabnr)
                                    let value = gettabwinvar(a:tabnr, winnr, a:var)
                                    if !empty(value)
                                        return value
                                    endif
                                endfor
                                return ""

FUNCTION  174()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 556
Called 678 times
Total time:   4.782112
 Self time:   3.916136

count  total (s)   self (s)
  678   0.759989   0.005008     call self.path.refresh(self.getNerdtree())
                            
                                "if this node was ever opened, refresh its children
  678              0.001562     if self.isOpen || !empty(self.children)
    7   0.016053   0.000368         let files = self._glob('*', 1) + self._glob('.*', 0)
    7              0.000015         let newChildNodes = []
    7              0.000014         let invalidFilesFound = 0
  707              0.000842         for i in files
  700              0.000456             try
                                            "create a new path and see if it exists in this nodes children
  700   0.248847   0.012992                 let path = g:NERDTreePath.New(i)
  700   0.861351   0.005870                 let newNode = self.getChild(path)
  700              0.001008                 if newNode != {}
  700   0.020503   0.002674                     call newNode.refresh()
  700              0.001879                     call add(newChildNodes, newNode)
                            
                                            "the node doesnt exist so create it
                                            else
                                                let newNode = g:NERDTreeFileNode.New(path, self.getNerdtree())
                                                let newNode.parent = self
                                                call add(newChildNodes, newNode)
  700              0.000350                 endif
                                        catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                            let invalidFilesFound = 1
  700              0.000488             endtry
  707              0.000493         endfor
                            
                                    "swap this nodes children out for the children we just read/refreshed
    7              0.000138         let self.children = newChildNodes
    7   0.307491   0.000076         call self.sortChildren()
                            
    7              0.000009         if invalidFilesFound
                                        call nerdtree#echoWarning("some files could not be loaded into the NERD tree")
    7              0.000004         endif
  678              0.000294     endif

FUNCTION  177()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 612
Called 1 time
Total time:   0.007764
 Self time:   0.000072

count  total (s)   self (s)
    1              0.000003     let opts = a:0 ? a:1 : {}
                            
    1   0.000290   0.000006     if !a:path.isUnder(self.path)
                                    throw "NERDTree.InvalidArgumentsError: " . a:path.str() . " should be under " . self.path.str()
    1              0.000001     endif
                            
    1   0.000054   0.000007     call self.open()
                            
    1   0.000738   0.000029     if self.path.equals(a:path.getParent())
    1   0.006664   0.000012         let n = self.findNode(a:path)
    1              0.000002         if has_key(opts, "open")
                                        call n.open()
    1              0.000001         endif
    1              0.000001         return n
                                endif
                            
                                let p = a:path
                                while !p.getParent().equals(self.path)
                                    let p = p.getParent()
                                endwhile
                            
                                let n = self.findNode(p)
                                return n.reveal(a:path, opts)

FUNCTION  179()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_dir_node.vim line 657
Called 15 times
Total time:   0.695073
 Self time:   0.034275

count  total (s)   self (s)
   15              0.000117     if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
   15              0.000012     endif
   15              0.000105     let CompareFunc = function("nerdtree#compareNodesBySortKey")
   15   0.694716   0.033918     call sort(self.children, CompareFunc)
   15              0.000056     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder

FUNCTION  <SNR>262_AddHintsForTypeScriptParsingErrors()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 61
Called 5 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    7              0.000016     for l:item in a:output
    2              0.000036         let l:item.text = substitute(   l:item.text,   '^\(Parsing error\)',   '\1 (You may need configure typescript-eslint-parser)',   '',)
    7              0.000008     endfor

FUNCTION  311()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/cursor.vim line 31
Called 2 times
Total time:   0.000105
 Self time:   0.000065

count  total (s)   self (s)
    2   0.000070   0.000030     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    2              0.000019     autocmd! syntastic CursorMoved
    2              0.000006     unlet! b:syntastic_private_messages
    2              0.000008     let b:syntastic_private_line = -1

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/job.vim line 144
Called 52 times
Total time:   0.000439
 Self time:   0.000439

count  total (s)   self (s)
   52              0.000230     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
   52              0.000041     endif

FUNCTION  nerdtree#echo()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree.vim line 170
Called 11 times
Total time:   0.034182
 Self time:   0.034182

count  total (s)   self (s)
   11              0.033760     redraw
   11              0.000388     echomsg empty(a:msg) ? "" : ("NERDTree: " . a:msg)

FUNCTION  313()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/highlighting.vim line 28
Called 14 times
Total time:   0.000635
 Self time:   0.000222

count  total (s)   self (s)
   14   0.000626   0.000213     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  deoplete#util#get_keyword_pattern()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 138
Called 2 times
Total time:   0.001031
 Self time:   0.000174

count  total (s)   self (s)
    2   0.000052   0.000034   let keyword_patterns = deoplete#custom#_get_option('keyword_patterns')
    2              0.000007   if empty(keyword_patterns)
                                let patterns = deoplete#custom#_get_filetype_option(   'keyword_patterns', a:filetype, '')
    2              0.000002   else
    2              0.000011     let filetype = has_key(keyword_patterns, a:filetype) ? a:filetype : '_'
    2              0.000010     let patterns = get(keyword_patterns, filetype, '')
    2              0.000002   endif
    2   0.000047   0.000030   let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
    2   0.000857   0.000035   let k_pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
    2              0.000025   return substitute(pattern, '\\k', '\=k_pattern', 'g')

FUNCTION  ale#command#IsDeferred()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 377
Called 104 times
Total time:   0.000742
 Self time:   0.000742

count  total (s)   self (s)
  104              0.000670     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>69_set()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 153
Called 276 times
Total time:   0.019187
 Self time:   0.003577

count  total (s)   self (s)
  276   0.019042   0.003432   return call('delimitMate#Set', a:000)

FUNCTION  anyfold#set_options()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 130
Called 21 times
Total time:   0.001811
 Self time:   0.001296

count  total (s)   self (s)
                            
   21   0.000935   0.000420     if s:AnyfoldDisable()
                                    return
   21              0.000025     endif
                            
   21              0.000260     setlocal foldmethod=expr
   21              0.000174     set foldexpr=b:anyfold_ind_buffer[v:lnum-1]
   21              0.000084     if g:anyfold_fold_display
   21              0.000143         setlocal foldtext=MinimalFoldText()
   21              0.000029     endif
                            

FUNCTION  <SNR>18_ftplugin()
    Defined: ~/config/nvim/.cache/init.vim/.dein/ftplugin.vim line 10
Called 7 times
Total time:   0.014729
 Self time:   0.012083

count  total (s)   self (s)
    7              0.000044   if exists("b:undo_ftplugin")
                                silent! execute b:undo_ftplugin
                                unlet! b:undo_ftplugin b:did_ftplugin
    7              0.000009   endif
                            
    7              0.000052   let filetype = expand("<amatch>")
    7              0.000022   if filetype !=# ""
    7              0.000064     if &cpoptions =~# "S" && exists("b:did_ftplugin")
                                  unlet b:did_ftplugin
    7              0.000008     endif
   14              0.000093     for ft in split(filetype, '\.')
    7   0.014091   0.011451       execute "runtime! ftplugin/" . ft . ".vim" "ftplugin/" . ft . "_*.vim" "ftplugin/" . ft . "/*.vim"
   14              0.000038     endfor
    7              0.000010   endif
    7   0.000156   0.000150   call s:after_ftplugin()

FUNCTION  TSCloseWindow()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 167
Called 247 times
Total time:   0.028836
 Self time:   0.008345

count  total (s)   self (s)
  247   0.028136   0.007645 return remote#define#notify(17, "/home/ajs/config/nvim/repos/github.com/mhartington/nvim-typescript/rplugin/node/nvim_typescript:function:TSCloseWindow", a:000)

FUNCTION  ale#list#SetLists()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/list.vim line 183
Called 5 times
Total time:   0.000244
 Self time:   0.000152

count  total (s)   self (s)
    5              0.000033     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    5              0.000004     else
    5   0.000167   0.000075         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    5              0.000003     endif

FUNCTION  90()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/key_map.vim line 87
Called 8 times
Total time:   7.158947
 Self time:   0.002184

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    8   0.000361   0.000212     if !g:NERDTree.ExistsForBuf()
                                    return {}
    8              0.000027     endif
                            
    8   0.093856   0.000691     let node = g:NERDTreeFileNode.GetSelected()
    8              0.000063     if !empty(node)
                            
                                    "try file node
    8              0.000039         if !node.path.isDirectory
    1   0.000092   0.000044             let km = s:KeyMap.FindFor(a:key, "FileNode")
    1              0.000006             if !empty(km)
    1   2.119695   0.000030                 return km.invoke(node)
                                        endif
    7              0.000012         endif
                            
                                    "try dir node
    7              0.000024         if node.path.isDirectory
    7   0.000436   0.000310             let km = s:KeyMap.FindFor(a:key, "DirNode")
    7              0.000038             if !empty(km)
    6   2.552406   0.000164                 return km.invoke(node)
    1              0.000002             endif
    1              0.000001         endif
                            
                                    "try generic node
    1   0.000034   0.000023         let km = s:KeyMap.FindFor(a:key, "Node")
    1              0.000004         if !empty(km)
                                        return km.invoke(node)
    1              0.000002         endif
                            
    1              0.000002     endif
                            
                                "try bookmark
    1   0.000113   0.000028     let bm = g:NERDTreeBookmark.GetSelected()
    1              0.000005     if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
    1              0.000001     endif
                            
                                "try all
    1   0.000043   0.000022     let km = s:KeyMap.FindFor(a:key, "all")
    1              0.000005     if !empty(km)
    1   2.391275   0.000024         return km.invoke()
                                endif

FUNCTION  95()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/bookmark.vim line 35
Called 1422 times
Total time:   0.008056
 Self time:   0.008056

count  total (s)   self (s)
 1422              0.003582     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
 1422              0.000645     endif
 1422              0.001695     return g:NERDTreeBookmarks

FUNCTION  96()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/bookmark.vim line 45
Called 2 times
Total time:   0.000358
 Self time:   0.000187

count  total (s)   self (s)
    2              0.000005     try
    2   0.000217   0.000046         call s:Bookmark.BookmarkFor(a:name)
                                    return 1
    2              0.000101     catch /^NERDTree.BookmarkNotFoundError/
    2              0.000012         return 0
    2              0.000007     endtry

FUNCTION  97()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/bookmark.vim line 57
Called 2 times
Total time:   0.000171
 Self time:   0.000123

count  total (s)   self (s)
    2              0.000010     let l:result = {}
    2   0.000084   0.000037     for l:bookmark in s:Bookmark.Bookmarks()
                                    if l:bookmark.name ==# a:name
                                        let l:result = l:bookmark
                                        break
                                    endif
    2              0.000006     endfor
    2              0.000016     if empty(l:result)
    1             13.592370         throw 'NERDTree.BookmarkNotFoundError: "' . a:name  . '" not found'
                                endif
                                return l:result

FUNCTION  <SNR>152_on_exit_nvim()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/async.vim line 69
Called 5 times
Total time:   0.004907
 Self time:   0.000176

count  total (s)   self (s)
    5              0.000032   if !a:exit_code
    4   0.004847   0.000115     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    5              0.000006   endif

FUNCTION  183()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 43
Called 2 times
Total time:   0.000073
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000008     if self._keepopen
                                    return
    2              0.000002     endif
                            
    2              0.000015     if (a:newtab && self._where == 't') || !a:newtab
    1   0.000030   0.000014         call g:NERDTree.CloseIfQuitOnOpen()
    2              0.000003     endif

FUNCTION  185()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 71
Called 1 time
Total time:   0.015552
 Self time:   0.000114

count  total (s)   self (s)
    1   0.000028   0.000020     if b:NERDTree.isWinTree()
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
    1              0.000001     else
    1   0.000036   0.000013         call self._checkToCloseTree(1)
                            
    1              0.000003         if self._where == 'v'
                                        call self._newVSplit()
    1              0.000003         elseif self._where == 'h'
                                        call self._newSplit()
    1              0.000002         elseif self._where == 't'
                                        tabnew
    1              0.000003         elseif self._where == 'p'
    1   0.015369   0.000011             call self._previousWindow()
    1              0.000001         endif
                            
    1   0.000070   0.000020         call self._checkToCloseTree(0)
    1              0.000001     endif

FUNCTION  186()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 103
Called 2 times
Total time:   0.011583
 Self time:   0.000219

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    2              0.000009     if winnr("$") ==# 1
                                    return 0
    2              0.000003     endif
                            
    2              0.000011     let oldwinnr = winnr()
    2   0.007599   0.000045     call nerdtree#exec(a:winnumber . "wincmd p")
    2              0.000039     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    2              0.000013     let modified = &modified
    2   0.003858   0.000049     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    2              0.000007     if specialWindow
                                    return 0
    2              0.000003     endif
                            
    2              0.000006     if &hidden
    2              0.000004         return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  187()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 139
Called 1 time
Total time:   0.000181
 Self time:   0.000144

count  total (s)   self (s)
    1              0.000043     let l:newOpener = copy(self)
                            
    1   0.000033   0.000021     let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000007     let l:newOpener._nerdtree = b:NERDTree
    1              0.000005     let l:newOpener._path = a:path
    1              0.000011     let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
    1   0.000035   0.000026     let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
    1              0.000009     let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
    1   0.000027   0.000012     call l:newOpener._saveCursorPos()
                            
    1              0.000003     return l:newOpener

FUNCTION  <SNR>119_is_in_buflist()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 629
Called 3 times
Total time:   0.000221
 Self time:   0.000132

count  total (s)   self (s)
    3              0.000025   let tabpage = a:tabnr == 0 ? tabpagenr() : a:tabnr
    3              0.000018   let window = a:winnr == 0 ? winnr() : a:winnr
    3   0.000152   0.000063   let buflist = wintabs#gettabwinvar(tabpage, window, 'wintabs_buflist', [])
    3              0.000017   return index(buflist, a:buffer) != -1

FUNCTION  <SNR>263_process_user_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 909
Called 15 times
Total time:   0.005193
 Self time:   0.002098

count  total (s)   self (s)
                              " Grr this is frustrating. In Insert mode, between the feedkey call and here,
                              " the current position could actually CHANGE for some odd reason. Forcing a
                              " position reset here
   15   0.000518   0.000303   let cursor_position = s:cm.get_current()
   15              0.000114   call cursor(cursor_position.position)
                            
                              " Before applying the user input, we need to revert back to the mode the user
                              " was in when the input was entered
   15   0.001550   0.000241   call s:revert_mode(s:to_mode, s:from_mode)
                            
                              " Update the line length BEFORE applying any actions. TODO(terryma): Is there
                              " a better place to do this?
                              " let cursor_position = s:cm.get_current()
   15   0.000577   0.000177   call cursor_position.update_line_length()
   15              0.000087   let s:saved_linecount = line('$')
                            
                              " Restore unnamed register only in Normal mode. This should happen before user
                              " input is processed.
   15              0.000067   if s:from_mode ==# 'n' || s:from_mode ==# 'v' || s:from_mode ==# 'V'
    5   0.000138   0.000050     call cursor_position.restore_unnamed_register()
   15              0.000015   endif
                            
                              " Apply the user input. Note that the above could potentially change mode, we
                              " use the mapping below to help us determine what the new mode is
                              " Note that it's possible that \<Plug>(multiple-cursors-apply) never gets called, we have a
                              " detection mechanism using \<Plug>(multiple-cursors-detect). See its documentation for more details
                            
                              " Assume that input is not valid
   15              0.000067   let s:valid_input = 0
                            
                              " If we're coming from insert mode or going into insert mode, always chain the
                              " undos together.
                              " FIXME(terryma): Undo always places the cursor at the beginning of the line.
                              " Figure out why.
   15              0.000045   if s:from_mode ==# 'i' || s:to_mode ==# 'i'
   14   0.001328   0.000331     silent! undojoin | call s:feedkeys(s:char."\<Plug>(multiple-cursors-apply)")
    1              0.000002   else
    1   0.000112   0.000025     call s:feedkeys(s:char."\<Plug>(multiple-cursors-apply)")
   15              0.000012   endif
                            
                              " Even when s:char produces invalid input, this method is always called. The
                              " 't' here is important
   15              0.000151   call feedkeys("\<Plug>(multiple-cursors-detect)", 't')

FUNCTION  dein#util#_expand()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/util.vim line 560
Called 12 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
   12              0.000289   let path = (a:path =~# '^\~') ? fnamemodify(a:path, ':p') : (a:path =~# '^\$\h\w*') ? substitute(a:path,               '^\$\h\w*', '\=eval(submatch(0))', '') : a:path
   12              0.000112   return (s:is_windows && path =~# '\\') ? dein#util#_substitute_path(path) : path

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/hunk.vim line 6
Called 4 times
Total time:   0.000181
 Self time:   0.000083

count  total (s)   self (s)
    4   0.000177   0.000079   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>263_wait_for_user_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1206
Called 8 times
Total time:   0.192337
 Self time:   0.112685

count  total (s)   self (s)
    8   0.000682   0.000122   call s:display_error()
                            
    8              0.000034   let s:from_mode = a:mode
    8              0.000035   if empty(a:mode)
    3              0.000007     let s:from_mode = s:to_mode
    8              0.000008   endif
    8              0.000026   let s:to_mode = ''
                            
                              " Right before redraw, apply the highlighting bug fix
    8   0.000372   0.000133   call s:apply_highlight_fix()
                            
    8              0.105562   redraw
                            
                              " Immediately revert the change to leave the user's buffer unchanged
    8   0.000497   0.000221   call s:revert_highlight_fix()
                            
    8   0.000569   0.000125   call s:end_latency_measure()
                            
    8              0.000062   let s:char = s:retry_keys . s:saved_keys
    8              0.000042   if len(s:saved_keys) == 0
    7   0.075268   0.000196     let s:char .= s:get_char()
    7   0.000611   0.000366     call s:handle_visual_IA_to_normal()
    1              0.000001   else
    1              0.000006     let s:saved_keys = ""
    8              0.000009   endif
                            
                              " ambiguous mappings are not supported; e.g.:
                              "   imap jj JJ
                              "   imap jjj JJJ
                              " will always trigger the 'jj' mapping
    8              0.000240   if s:from_mode ==# 'i' && mapcheck(s:char, "i") != ""
                                let map_dict = {}
                                let s_time = s:get_time_in_ms()
                                while 1
                                  let map_dict = maparg(s:char, "i", 0, 1)
                                  " break if chars exactly match mapping
                                  if map_dict != {}
                                    if get(map_dict, 'expr', 0)
                                      " handle case where {rhs} is a function
                                      exec 'let char_mapping = ' . map_dict['rhs']
                                    else
                                      let char_mapping = maparg(s:char, "i")
                                    endif
                                    " handle case where mapping is <esc>
                                    exec 'let s:char = "'.substitute(char_mapping, '<', '\\<', 'g').'"'
                                    break
                                  endif
                                  " break if chars don't match beginning of mapping anymore
                                  if mapcheck(s:char, "i") == ""
                                    break
                                  endif
                                  if s:get_time_in_ms() > (s_time + &timeoutlen)
                                    break
                                  endif
                                  let new_char = s:get_char(0)
                                  let s:char .= new_char
                                  if new_char == ''
                                    sleep 50m
                                  endif
                                endwhile
    8              0.000060   elseif s:from_mode !=# 'i' && s:char[0] ==# ":"
                                call feedkeys(s:char)
                                call s:cm.reset(1, 1, 1)
                                return
    8              0.000106   elseif s:from_mode ==# 'n' || s:from_mode =~# 'v\|V'
    5   0.000245   0.000179     while match(s:last_char(), "\\d") == 0
                                  if match(s:char, '\(^\|\a\)0') == 0
                                    " fixes an edge case concerning the `0` key.
                                    " The 0 key behaves differently from [1-9].
                                    " It's consumed immediately when it is the
                                    " first key typed while we're waiting for input.
                                    " References: issue #152, pull #241
                                    break
                                  endif
                                  let s:char .= s:get_char()
    5              0.000027     endwhile
    8              0.000012   endif
                            
    8   0.000303   0.000191   call s:start_latency_measure()
                            
                              " Clears any echoes we might've added
    8              0.001463   normal! :<Esc>
                            
                              " add chars to s:char if it start like a special/quit key
    8              0.000077   let is_special_key = 0
    8              0.000127   let sk_list = get(s:special_keys, s:from_mode, [])
    8              0.000079   let is_special_key = (index(sk_list, s:char) != -1)
    8              0.000027   let is_quit_key = 0
    8   0.000676   0.000210   let s_time = s:get_time_in_ms()
    8              0.000029   while 1
    8              0.000322     let start_special_key = (index(map(sk_list[:], 'v:val[0:len(s:char)-1] == s:char'), 1) > -1)
    8              0.000091     let start_quit_key = (g:multi_cursor_quit_key[0:len(s:char)-1] == s:char)
    8              0.000046     if start_special_key == 0 && start_quit_key == 0
    3              0.000008       break
    5              0.000011     else
    5              0.000044       let is_special_key = (index(sk_list, s:char) != -1)
    5              0.000033       let is_quit_key = (g:multi_cursor_quit_key == s:char)
    5              0.000025       if is_special_key == 1 || is_quit_key == 1
    5              0.000011         break
                                  else
                                    if s:get_time_in_ms() > (s_time + &timeoutlen)
                                      break
                                    endif
                                    let new_char = s:get_char(0)
                                    let s:char .= new_char
                                    if new_char == ''
                                      sleep 50m
                                    endif
                                  endif
                                end
    8              0.000036   endwhile
                            
    8   0.001058   0.000141   if s:exit()
    1              0.000001     return
    7              0.000009   endif
                            
                              " If the key is a special key and we're in the right mode, handle it
    7              0.000023   if is_special_key == 1
    4   0.001160   0.000275     call s:handle_special_key(s:char, s:from_mode)
    4   0.000183   0.000124     call s:skip_latency_measure()
    3              0.000003   else
    3   0.000074   0.000042     call s:cm.start_loop()
    3   0.000359   0.000080     call s:feedkeys("\<Plug>(multiple-cursors-input)")
    7              0.000010   endif

FUNCTION  syntastic#util#getbufvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 121
Called 9 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    9              0.000114     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  190()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 235
Called 1 time
Total time:   2.119190
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000004     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
    1              0.000002     endif
                            
    1   2.119173   0.000023     call self._openFile()

FUNCTION  191()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 245
Called 1 time
Total time:   2.119150
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000017     if !self._stay && !and(g:NERDTreeQuitOnOpen,1) && exists("b:NERDTreeZoomed") && b:NERDTreeZoomed
                                    call b:NERDTree.ui.toggleZoom()
    1              0.000001     endif
                            
    1   0.001913   0.000013     if self._reuseWindow()
                                    return
    1              0.000001     endif
                            
    1   0.015569   0.000017     call self._gotoTargetWin()
                            
    1              0.000003     if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
    1              0.000001     endif
                            
    1   2.101617   0.000024     call self._path.edit()

FUNCTION  193()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 287
Called 1 time
Total time:   0.015358
 Self time:   0.000116

count  total (s)   self (s)
    1   0.006038   0.000021     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
    1              0.000002     else
    1              0.000002         try
    1   0.005592   0.000026             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
    1              0.000002             else
    1   0.003680   0.000020                 call nerdtree#exec('wincmd p')
    1              0.000002             endif
                                    catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
    1              0.000002         endtry
    1              0.000001     endif

FUNCTION  195()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 316
Called 1 time
Total time:   0.001900
 Self time:   0.001100

count  total (s)   self (s)
    1              0.000006     if empty(self._reuse)
                                    return 0
    1              0.000001     endif
                            
                                "check the current tab for the window
    1   0.001262   0.000998     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000007     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
    1              0.000001     endif
                            
    1              0.000005     if self._reuse == 'currenttab'
                                    return 0
    1              0.000001     endif
                            
                                "check other tabs
    1   0.000559   0.000023     let tabnr = self._path.tabnr()
    1              0.000003     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec(tabnr . 'tabnext')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
    1              0.000001     endif
                            
    1              0.000002     return 0

FUNCTION  196()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/opener.vim line 347
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000007     let self._bufnr = bufnr("")
    1              0.000006     let self._tabnr = tabpagenr()

FUNCTION  197()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 15
Called 3 times
Total time:   0.019989
 Self time:   0.000826

count  total (s)   self (s)
                                "make <cr> do the same as the activate node mapping
    3              0.000256     nnoremap <silent> <buffer> <cr> :call nerdtree#ui_glue#invokeKeyMap(g:NERDTreeMapActivateNode)<cr>
                            
    3   0.019228   0.000065     call g:NERDTreeKeyMap.BindAll()
                            
    3              0.000072     command! -buffer -nargs=? Bookmark :call nerdtree#ui_glue#bookmarkNode('<args>')
    3              0.000073     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 RevealBookmark :call nerdtree#ui_glue#revealBookmark('<args>')
    3              0.000058     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=1 OpenBookmark call nerdtree#ui_glue#openBookmark('<args>')
    3              0.000051     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=* ClearBookmarks call nerdtree#ui_glue#clearBookmarks('<args>')
    3              0.000055     command! -buffer -complete=customlist,nerdtree#completeBookmarks -nargs=+ BookmarkToRoot call g:NERDTreeBookmark.ToRoot('<args>', b:NERDTree)
    3              0.000052     command! -buffer -nargs=0 ClearAllBookmarks call g:NERDTreeBookmark.ClearAll() <bar> call b:NERDTree.render()
    3              0.000059     command! -buffer -nargs=0 ReadBookmarks call g:NERDTreeBookmark.CacheBookmarks(0) <bar> call b:NERDTree.render()
    3              0.000030     command! -buffer -nargs=0 WriteBookmarks call g:NERDTreeBookmark.Write()
    3              0.000027     command! -buffer -nargs=0 EditBookmarks call g:NERDTreeBookmark.Edit()

FUNCTION  198()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 33
Called 2 times
Total time:   0.000061
 Self time:   0.000038

count  total (s)   self (s)
    2   0.000059   0.000037     silent doautocmd User NERDTreeInit

FUNCTION  199()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 38
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007     return 'NERD_tree_'

FUNCTION  <SNR>158_RunJob()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 438
Called 52 times
Total time:   0.171576
 Self time:   0.008858

count  total (s)   self (s)
   52   0.000907   0.000534     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
   52              0.000041     endif
                            
   52              0.000136     let l:command = a:command
                            
   52              0.000116     if empty(l:command)
                                    return 0
   52              0.000032     endif
                            
   52              0.000160     let l:executable = a:options.executable
   52              0.000134     let l:buffer = a:options.buffer
   52              0.000117     let l:linter = a:options.linter
   52              0.000145     let l:output_stream = a:options.output_stream
   52              0.000149     let l:next_chain_index = a:options.next_chain_index
   52              0.000126     let l:read_buffer = a:options.read_buffer
   52              0.000233     let l:info = g:ale_buffer_info[l:buffer]
                            
   52              0.000919     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,   'next_chain_index': l:next_chain_index,}])
   52   0.162338   0.002216     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),})
                            
                                " Only proceed if the job is being run.
   52              0.000167     if empty(l:result)
                                    return 0
   52              0.000035     endif
                            
   52   0.003032   0.001293     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
   52   0.001531   0.001046     silent doautocmd <nomodeline> User ALEJobStarted
                            
   52              0.000224     return 1

FUNCTION  <SNR>25_merge()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 50
Called 4 times
Total time:   0.001389
 Self time:   0.001178

count  total (s)   self (s)
    4              0.000007     let target = a:dict_t
    4              0.000005     let other = a:dict_o
   44              0.000044     for k in keys(target)
   40              0.000107         if type(target[k]) == type({}) && has_key(other, k)
    3              0.000006             if type(other[k]) == type({})
    3              0.000005                 if has_key(target[k], 'name')
    3              0.000007                     let other[k].name = target[k].name
    3              0.000001                 endif
    3              0.000012                 call s:merge(target[k], other[k])
                                        elseif type(other[k]) == type([])
                                            if g:leaderGuide_flatten == 0 || type(target[k]) == type({})
                                                let target[k.'m'] = target[k]
                                            endif
                                            let target[k] = other[k]
                                            if has_key(other, k."m") && type(other[k."m"]) == type({})
                                                call s:merge(target[k."m"], other[k."m"])
                                            endif
    3              0.000001             endif
   40              0.000014         endif
   44              0.000020     endfor
    4              0.000018     call extend(target, other, "keep")

FUNCTION  wintabs#renderers#buffer_sep()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 22
Called 20 times
Total time:   0.000935
 Self time:   0.000935

count  total (s)   self (s)
   20              0.000107   let label = g:wintabs_ui_sep_inbetween
   20              0.000102   let is_active = a:config.is_active && a:config.is_active_window
   20              0.000045   if a:config.is_leftmost
    8              0.000031     let label = g:wintabs_ui_sep_leftmost
   20              0.000021   endif
   20              0.000039   if a:config.is_rightmost
    8              0.000027     let label = g:wintabs_ui_sep_rightmost
   20              0.000018   endif
   20              0.000056   if is_active && a:config.is_left
    4              0.000015     let label = g:wintabs_ui_active_left
   20              0.000017   endif
   20              0.000051   if is_active && a:config.is_right
    4              0.000014     let label = g:wintabs_ui_active_right
   20              0.000016   endif
   20              0.000153   return {'label': label,'highlight': is_active ? g:wintabs_ui_active_higroup : '',}

FUNCTION  <SNR>51_NERDTreeGetIndicator()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/git_status.vim line 183
Called 1441 times
Total time:   0.024823
 Self time:   0.024823

count  total (s)   self (s)
 1441              0.004220     if exists('g:NERDTreeIndicatorMapCustom')
                                    let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
                                    if l:indicator !=# ''
                                        return l:indicator
                                    endif
 1441              0.000627     endif
 1441              0.005455     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
 1441              0.002130     if l:indicator !=# ''
   21              0.000062         return l:indicator
 1420              0.000638     endif
 1420              0.001125     return ''

FUNCTION  <SNR>167_reset_summary()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/hunk.vim line 20
Called 4 times
Total time:   0.000288
 Self time:   0.000090

count  total (s)   self (s)
    4   0.000284   0.000086   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <lambda>83()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000029   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#Queue()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 129
Called 83 times
Total time:   0.330860
 Self time:   0.008118

count  total (s)   self (s)
   83              0.000242     if a:0 > 2
                                    throw 'too many arguments!'
   83              0.000084     endif
                            
   83              0.000479     let l:buffer = get(a:000, 1, v:null)
                            
   83              0.000282     if l:buffer is v:null
   75              0.000282         let l:buffer = bufnr('')
   83              0.000071     endif
                            
   83              0.000339     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
   83              0.000060     endif
                            
   83   0.015544   0.001449     if ale#ShouldDoNothing(l:buffer)
   16              0.000025         return
   67              0.000042     endif
                            
                                " Default linting_flag to ''
   67              0.000349     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
   67              0.000161     if s:lint_timer != -1
   18              0.000083         call timer_stop(s:lint_timer)
   18              0.000050         let s:lint_timer = -1
   67              0.000044     endif
                            
   67              0.000114     if a:delay > 0
   19              0.000400         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
   48              0.000051     else
   48   0.310115   0.001468         call s:Lint(l:buffer, l:should_lint_file, 0)
   67              0.000159     endif

FUNCTION  <SNR>263_end_latency_measure()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1180
Called 8 times
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
    8              0.000061   if g:multi_cursor_debug_latency && !empty(s:char)
                                if empty(s:latency_debug_file)
                                  let s:latency_debug_file = tempname()
                                  exec 'redir >> '.s:latency_debug_file
                                    silent! echom "Starting latency debug at ".reltimestr(reltime())
                                  redir END
                                endif
                            
                                if !s:skip_latency_measure
                                  exec 'redir >> '.s:latency_debug_file
                                    silent! echom "Processing '".s:char."' took ".string(str2float(reltimestr(reltime(s:start_time)))*1000).' ms in '.s:cm.size().' cursors. mode = '.s:from_mode
                                  redir END
                                endif
    8              0.000008   endif
    8              0.000031   let s:skip_latency_measure = 0

FUNCTION  <SNR>263_handle_visual_IA_to_normal()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 981
Called 7 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
    7              0.000154   if s:char =~# 'I\|A' && s:from_mode =~# 'v\|V'
                                let s:saved_char = s:char
                                let s:char = s:from_mode " spoof a 'v' or 'V' input to transiton from Visual into Normal mode
    7              0.000013   endif

FUNCTION  wintabs#renderers#padding()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 94
Called 1422 times
Total time:   0.015539
 Self time:   0.015539

count  total (s)   self (s)
 1422              0.014206   return {'type': 'sep','label': repeat(' ', a:len),'highlight': '',}

FUNCTION  dein#autoload#_source()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim line 7
Called 8 times
Total time:   0.000409
 Self time:   0.000255

count  total (s)   self (s)
    8   0.000337   0.000184   let plugins = empty(a:000) ? values(g:dein#_plugins) : dein#util#_convert2list(a:1)
    8              0.000028   if empty(plugins)
    8              0.000012     return
                              endif
                            
                              if type(plugins[0]) != v:t_dict
                                let plugins = map(dein#util#_convert2list(a:1),       'get(g:dein#_plugins, v:val, {})')
                              endif
                            
                              let rtps = dein#util#_split_rtp(&runtimepath)
                              let index = index(rtps, dein#util#_get_runtime_path())
                              if index < 0
                                return 1
                              endif
                            
                              let sourced = []
                              for plugin in filter(plugins, "!empty(v:val) && !v:val.sourced && v:val.rtp !=# ''")
                                call s:source_plugin(rtps, index, plugin, sourced)
                              endfor
                            
                              let filetype_before = dein#util#_redir('autocmd FileType')
                              let &runtimepath = dein#util#_join_rtp(rtps, &runtimepath, '')
                            
                              call dein#call_hook('source', sourced)
                            
                              " Reload script files.
                              for plugin in sourced
                                for directory in filter(['plugin', 'after/plugin'], "isdirectory(plugin.rtp.'/'.v:val)")
                                  for file in dein#util#_globlist(plugin.rtp.'/'.directory.'/**/*.vim')
                                    execute 'source' fnameescape(file)
                                  endfor
                                endfor
                            
                                if !has('vim_starting')
                                  let augroup = get(plugin, 'augroup', plugin.normalized_name)
                                  if exists('#'.augroup.'#VimEnter')
                                    execute 'doautocmd' augroup 'VimEnter'
                                  endif
                                  if has('gui_running') && &term ==# 'builtin_gui' && exists('#'.augroup.'#GUIEnter')
                                    execute 'doautocmd' augroup 'GUIEnter'
                                  endif
                                  if exists('#'.augroup.'#BufRead')
                                    execute 'doautocmd' augroup 'BufRead'
                                  endif
                                endif
                              endfor
                            
                              let filetype_after = dein#util#_redir('autocmd FileType')
                            
                              let is_reset = s:is_reset_ftplugin(sourced)
                              if is_reset
                                call s:reset_ftplugin()
                              endif
                            
                              if (is_reset || filetype_before !=# filetype_after) && &filetype !=# ''
                                " Recall FileType autocmd
                                let &filetype = &filetype
                              endif
                            
                              if !has('vim_starting')
                                call dein#call_hook('post_source', sourced)
                              endif

FUNCTION  syntastic#util#var()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 165
Called 63 times
Total time:   0.001864
 Self time:   0.001195

count  total (s)   self (s)
   63   0.001829   0.001159     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  provider#node#Require()
    Defined: /usr/share/nvim/runtime/autoload/provider/node.vim line 103
Called 1 time
Total time:   0.167644
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000002   if s:err != ''
                                echoerr s:err
                                return
    1              0.000001   endif
                            
    1              0.000002   let args = ['node']
                            
    1              0.000011   if !empty($NVIM_NODE_HOST_DEBUG) && provider#node#can_inspect()
                                call add(args, '--inspect-brk')
    1              0.000000   endif
                            
    1   0.000013   0.000010   call add(args, provider#node#Prog())
                            
    1   0.167609   0.000024   return provider#Poll(args, a:host.orig_name, '$NVIM_NODE_LOG_FILE')

FUNCTION  <SNR>120_truncate_line_non_memoized()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 155
Called 10 times
Total time:   0.031009
 Self time:   0.003755

count  total (s)   self (s)
   10              0.000067   let [line, active_start, active_end] = a:bufline
   10   0.000473   0.000126   let line_len = wintabs#element#len(line)
                            
                              " load line_start from saved value
   10   0.000301   0.000141   let line_start = wintabs#getwinvar(a:window, 'wintabs_bufline_start', 0)
   10              0.000029   let width = a:width
                            
                              " arrows are added to indicate truncation
   10              0.000029   let has_left_arrow = 0
   10              0.000025   let has_right_arrow = 0
   10   0.000292   0.000182   let left_arrow = g:wintabs_renderers.left_arrow()
   10   0.000242   0.000142   let right_arrow = g:wintabs_renderers.right_arrow()
   10   0.000435   0.000129   let left_arrow_len = wintabs#element#len(left_arrow)
   10   0.000378   0.000127   let right_arrow_len = wintabs#element#len(right_arrow)
                            
                              " adjust line_start and width to accommodate active buffer and arrows
                              " 3 passes are needed to satisfy enough constraints
   40              0.000111   for i in range(3)
                                " line_start <= active_start < active_end <= line_start + width
   30              0.000083     if active_start < active_end
   24              0.000062       if line_start > active_start
                                    let line_start = active_start
   24              0.000022       endif
   24              0.000070       if active_end > line_start + width
                                    let line_start = active_end - width
   24              0.000018       endif
   30              0.000024     endif
                            
                                " check if left arrow is needed
   30              0.000087     if !has_left_arrow && line_start > 0
                                  let has_left_arrow = 1
                                  let width -= left_arrow_len
   30              0.000022     endif
                            
                                " check if right arrow is needed
   30              0.000117     if !has_right_arrow && line_start + width < line_len
                                  let has_right_arrow = 1
                                  let width -= right_arrow_len
   30              0.000099     elseif has_right_arrow && line_start + width >= line_len
                                  let has_right_arrow = 0
                                  let width += right_arrow_len
   30              0.000021     endif
   40              0.000065   endfor
                            
                              " if it's at the end of bufline, try to expand as much as possible
   10              0.000028   if has_left_arrow && !has_right_arrow
                                let width = a:width
                                let line_start = line_len - width
                                if line_start <= 0
                                  let has_left_arrow = 0
                                  let line_start = 0
                                else
                                  let has_left_arrow = 1
                                  let line_start += left_arrow_len
                                  let width -= left_arrow_len
                                endif
   10              0.000010   endif
                            
                              " if active tab is longer than width, align to its start
   10              0.000034   if active_end - active_start > width
                                let line_start = active_start
                                " re-assess lefe arrow since this is an edge case
                                if has_left_arrow && line_start == 0
                                  let has_left_arrow = 0
                                  let width += left_arrow_len
                                endif
   10              0.000008   endif
                            
                              " save line_start
   10              0.000093   call setwinvar(a:window, 'wintabs_bufline_start', line_start)
                            
                              " final assembly
   10              0.000034   let elements = []
   10              0.000020   if has_left_arrow
                                call add(elements, left_arrow)
   10              0.000008   endif
   10   0.026176   0.000197   call add(elements, wintabs#element#slice(line, line_start, width))
   10              0.000027   if has_right_arrow
                                call add(elements, right_arrow)
   10              0.000012   endif
   10              0.000046   return [elements, line_start]

FUNCTION  <SNR>156_GetAliasedFiletype()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 403
Called 81 times
Total time:   0.005545
 Self time:   0.005545

count  total (s)   self (s)
   81              0.000555     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
   81              0.000591     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
   81              0.000077     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
  324              0.001070     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
  243              0.000898         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
  243              0.000170         endif
  324              0.000334     endfor
                            
   81              0.000181     return a:original_filetype

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 52
Called 52 times
Total time:   0.001286
 Self time:   0.001221

count  total (s)   self (s)
   52              0.000151     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
   52              0.000038     endif
                            
                                " Check for a cached executable() check.
   52              0.000461     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   52              0.000119     if l:result isnot v:null
   51              0.000079         return l:result
    1              0.000001     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    1              0.000024     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    1              0.000005     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
    1              0.000010         let s:executable_cache_map[a:executable] = l:result
    1              0.000001     endif
                            
    1              0.000003     if g:ale_history_enabled
    1   0.000091   0.000027         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    1              0.000001     endif
                            
    1              0.000003     return l:result

FUNCTION  <SNR>143_setup_maps()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter.vim line 111
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000019   if !g:gitgutter_map_keys
    2              0.000007     return
                              endif
                            
                              if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>GitGutterPrevHunk
                              endif
                              if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>GitGutterNextHunk
                              endif
                            
                              if !hasmapto('<Plug>GitGutterStageHunk') && maparg('<Leader>hs', 'n') ==# ''
                                nmap <buffer> <Leader>hs <Plug>GitGutterStageHunk
                              endif
                              if !hasmapto('<Plug>GitGutterUndoHunk') && maparg('<Leader>hu', 'n') ==# ''
                                nmap <buffer> <Leader>hu <Plug>GitGutterUndoHunk
                              endif
                              if !hasmapto('<Plug>GitGutterPreviewHunk') && maparg('<Leader>hp', 'n') ==# ''
                                nmap <buffer> <Leader>hp <Plug>GitGutterPreviewHunk
                              endif
                            
                              if !hasmapto('<Plug>GitGutterTextObjectInnerPending') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectOuterPending') && maparg('ac', 'o') ==# ''
                                omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectInnerVisual') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
                              endif
                              if !hasmapto('<Plug>GitGutterTextObjectOuterVisual') && maparg('ac', 'x') ==# ''
                                xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
                              endif

FUNCTION  ale#Escape()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 225
Called 208 times
Total time:   0.004322
 Self time:   0.004322

count  total (s)   self (s)
  208              0.001183     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
  208              0.000165     endif
                            
  208              0.001012     return shellescape (a:str)

FUNCTION  <SNR>79_unc_path()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 175
Called 5 times
Total time:   0.000566
 Self time:   0.000120

count  total (s)   self (s)
    5   0.000560   0.000113   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  nerdtree#runningWindows()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree.vim line 153
Called 24995 times
Total time:   0.175348
 Self time:   0.175348

count  total (s)   self (s)
24995              0.167663     return has("win16") || has("win32") || has("win64")

FUNCTION  ale#util#GetFunction()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 82
Called 114 times
Total time:   0.001176
 Self time:   0.001176

count  total (s)   self (s)
  114              0.000439     if type(a:string_or_ref) is v:t_string
    5              0.000016         return function(a:string_or_ref)
  109              0.000107     endif
                            
  109              0.000181     return a:string_or_ref

FUNCTION  <SNR>143_reset_tick()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter.vim line 151
Called 28 times
Total time:   0.002236
 Self time:   0.000714

count  total (s)   self (s)
   28   0.002206   0.000685   call gitgutter#utility#setbufvar(a:bufnr, 'tick', 0)

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/events.vim line 69
Called 7 times
Total time:   0.000591
 Self time:   0.000305

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    7              0.000069     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    7              0.000062     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
    2              0.000022         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
    2              0.000008         if g:ale_lint_on_filetype_changed
    2   0.000325   0.000039             call ale#Queue(300, 'lint_file', a:buffer)
    2              0.000003         endif
    7              0.000006     endif

FUNCTION  deoplete#util#vimoption2python_not()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 51
Called 47 times
Total time:   0.028791
 Self time:   0.000744

count  total (s)   self (s)
   47   0.028748   0.000700   return '[^\w' . s:vimoption2python(a:option) . ']'

FUNCTION  <lambda>87()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000028
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  423()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 610
Called 15 times
Total time:   0.000244
 Self time:   0.000181

count  total (s)   self (s)
   15   0.000201   0.000138   let self.current_index = (self.current_index + 1) % self.size()

FUNCTION  jspc#init()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/jspc.vim line 8
Called 3 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    3              0.000020   let b:jspc_omnifunc = &omnifunc
    3              0.000008   let b:jspc_finding = 0
    3              0.000020   setlocal omnifunc=jspc#omni

FUNCTION  283()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/autoloclist.vim line 20
Called 7 times
Total time:   0.001119
 Self time:   0.000749

count  total (s)   self (s)
    7   0.000241   0.000096     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    7   0.000286   0.000092     let auto_loc_list = syntastic#util#var('auto_loc_list')
    7   0.000112   0.000081     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
    7              0.000009     else
    7              0.000077         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
    7              0.000009         endif
    7              0.000008     endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 92
Called 3 times
Total time:   0.000278
 Self time:   0.000058

count  total (s)   self (s)
    3   0.000271   0.000051   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>165_highlight_range()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 122
Called 2 times
Total time:   0.000255
 Self time:   0.000052

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
    2   0.000251   0.000049     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  wintabs#renderers#bufname()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 102
Called 12 times
Total time:   0.000604
 Self time:   0.000604

count  total (s)   self (s)
   12              0.000137   let name = fnamemodify(bufname(a:bufnr), ':t')
   12              0.000134   let name = substitute(name, '%', '%%', 'g')
   12              0.000039   if empty(name)
                                let name = '[No Name]'
   12              0.000012   endif
   12              0.000062   if getbufvar(a:bufnr, '&readonly')
                                let name = name.g:wintabs_ui_readonly
   12              0.000062   elseif getbufvar(a:bufnr, '&modified')
    1              0.000007     let name = name.g:wintabs_ui_modified
   12              0.000010   endif
   12              0.000026   return name

FUNCTION  416()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 475
Called 63 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
   63              0.000260   return len(self.cursors)

FUNCTION  dein#util#_convert2list()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/util.vim line 576
Called 8 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
    8              0.000138   return type(a:expr) ==# v:t_list ? copy(a:expr) : type(a:expr) ==# v:t_string ?   (a:expr ==# '' ? [] : split(a:expr, '\r\?\n', 1)) : [a:expr]

FUNCTION  429()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 684
Called 5 times
Total time:   0.000945
 Self time:   0.000160

count  total (s)   self (s)
    5   0.000926   0.000141   call s:select_in_visual_mode(self.get_current().visual)

FUNCTION  TabooTabline()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 50
Called 40 times
Total time:   0.106934
 Self time:   0.008704

count  total (s)   self (s)
   40              0.000223     let tabline = ''
  160   0.001354   0.000897     for i in s:tabs()
  120              0.000813         let tabline .= i == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
  120   0.002964   0.001703         let title = s:gettabvar(i, "taboo_tab_name")
  120              0.000886         let fmt = empty(title) ? g:taboo_tab_format : g:taboo_renamed_tab_format
  120              0.000662         let tabline .= '%' . i . 'T'
  120   0.098273   0.001760         let tabline .= s:expand(i, fmt)
  160              0.000230     endfor
   40              0.000159     let tabline .= '%#TabLineFill#%T'
   40              0.000236     let tabline .= '%=%#TabLine#%999X' . g:taboo_close_tabs_label
   40              0.000102     return tabline

FUNCTION  syntastic#util#compareLexi()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 186
Called 5 times
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
    7              0.000064     for idx in range(max([len(a:a), len(a:b)]))
    7              0.000055         let a_element = str2nr(get(a:a, idx, 0))
    7              0.000092         let b_element = str2nr(get(a:b, idx, 0))
    7              0.000021         if a_element != b_element
    5              0.000017             return a_element > b_element ? 1 : -1
    2              0.000002         endif
    2              0.000003     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  <SNR>143_has_fresh_changes()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter.vim line 147
Called 6 times
Total time:   0.000280
 Self time:   0.000150

count  total (s)   self (s)
    6   0.000266   0.000136   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>69_option_init()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 31
Called 276 times
Total time:   0.029764
 Self time:   0.010577

count  total (s)   self (s)
  276              0.001961   let b = exists("b:delimitMate_" . a:name)
  276              0.001530   let g = exists("g:delimitMate_" . a:name)
                              " Find value to use.
  276              0.000579   if !b && !g
  276              0.000803     let value = a:default
                              elseif b
                                exec "let value = b:delimitMate_" . a:name
                              else
                                exec "let value = g:delimitMate_" . a:name
  276              0.000237   endif
  276   0.022340   0.003153   call s:set(a:name, value)

FUNCTION  deoplete#handler#_check_omnifunc()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 77
Called 38 times
Total time:   0.005708
 Self time:   0.004347

count  total (s)   self (s)
   38              0.000190   let prev = g:deoplete#_prev_completion
   38              0.000111   let blacklist = ['LanguageClient#complete']
   38   0.001019   0.000779   if a:context.event ==# 'Manual' || &l:omnifunc ==# '' || index(blacklist, &l:omnifunc) >= 0 || prev.input ==# a:context.input || s:check_input_method()
                                return
   38              0.000031   endif
                            
   76              0.000176   for filetype in a:context.filetypes
   76   0.002178   0.001057     for pattern in deoplete#util#convert2list( deoplete#custom#_get_filetype_option(   'omni_patterns', filetype, ''))
   38              0.000116       if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    call deoplete#mapping#_set_completeopt()
                                    call feedkeys("\<C-x>\<C-o>", 'in')
                                    return 1
   38              0.000027       endif
   76              0.000072     endfor
   76              0.000078   endfor

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 44
Called 19 times
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
   19              0.000266     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  NERDTreeGitStatusRefreshListener()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/git_status.vim line 61
Called 1420 times
Total time:   2.730191
 Self time:   0.038951

count  total (s)   self (s)
 1420              0.004314     if !exists('b:NOT_A_GIT_REPOSITORY')
    2   0.516498   0.000079         call g:NERDTreeGitStatusRefresh()
 1420              0.000726     endif
 1420              0.002854     let l:path = a:event.subject
 1420   2.180540   0.012220     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
 1420   0.014812   0.008312     call l:path.flagSet.clearFlags('git')
 1420              0.001929     if l:flag !=# ''
                                    call l:path.flagSet.addFlag('git', l:flag)
 1420              0.000667     endif

FUNCTION  <SNR>69_get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 149
Called 468 times
Total time:   0.024536
 Self time:   0.005637

count  total (s)   self (s)
  468   0.024293   0.005393   return call('delimitMate#Get', a:000)

FUNCTION  <SNR>130_AddEval()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 274
Called 3 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000017   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
    3              0.000002   endif

FUNCTION  deoplete#util#convert2list()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 20
Called 88 times
Total time:   0.000790
 Self time:   0.000790

count  total (s)   self (s)
   88              0.000628   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  deoplete#util#vimoption2python()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 48
Called 2 times
Total time:   0.000823
 Self time:   0.000029

count  total (s)   self (s)
    2   0.000822   0.000028   return '[\w' . s:vimoption2python(a:option) . ']'

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 77
Called 27 times
Total time:   0.001816
 Self time:   0.001629

count  total (s)   self (s)
   27              0.001158   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   19              0.000053     return a:arg
    8   0.000327   0.000140   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    8              0.000014   else
    8              0.000094     return shellescape(a:arg)
                              endif

FUNCTION  ale#linter#GetCommand()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 535
Called 52 times
Total time:   0.046912
 Self time:   0.001556

count  total (s)   self (s)
   52              0.000536     let l:Command = has_key(a:linter, 'command_callback')   ? function(a:linter.command_callback)   : a:linter.command
                            
   52   0.046313   0.000957     return type(l:Command) is v:t_func   ? l:Command(a:buffer)   : l:Command

FUNCTION  syntastic#log#debugDump()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/log.vim line 122
Called 2 times
Total time:   0.000044
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000036   0.000028     if !s:_isDebugEnabled(a:level)
    2              0.000002         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>25_calc_layout()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 225
Called 1 time
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    1              0.000002     let ret = {}
    1              0.000023     let smap = filter(copy(s:lmap), 'v:key !=# "name"')
    1              0.000003     let ret.n_items = len(smap)
    1              0.000081     let length = values(map(smap,  'strdisplaywidth("[".v:key."]".'. '(type(v:val) == type({}) ? v:val["name"] : v:val[1]))'))
    1              0.000004     let maxlength = max(length) + g:leaderGuide_hspace
    1              0.000001     if g:leaderGuide_vertical
                                    let ret.n_rows = winheight(0) - 2
                                    let ret.n_cols = ret.n_items / ret.n_rows + (ret.n_items != ret.n_rows)
                                    let ret.col_width = maxlength
                                    let ret.win_dim = ret.n_cols * ret.col_width
    1              0.000001     else
    1              0.000003         let ret.n_cols = winwidth(0) / maxlength
    1              0.000002         let ret.col_width = winwidth(0) / ret.n_cols
    1              0.000012         let ret.n_rows = ret.n_items / ret.n_cols + (fmod(ret.n_items,ret.n_cols) > 0 ? 1 : 0)
    1              0.000002         let ret.win_dim = ret.n_rows
                                    "echom string(ret)
    1              0.000001     endif
    1              0.000001     return ret

FUNCTION  <SNR>181_is_exiting()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 333
Called 38 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
   38              0.000241   return exists('v:exiting') && v:exiting != v:null

FUNCTION  <lambda>41()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000048
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000048   0.000036 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  nerdtree#compareNodesBySortKey()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree.vim line 61
Called 6304 times
Total time:   0.660798
 Self time:   0.225215

count  total (s)   self (s)
 6304   0.248966   0.024651     let sortKey1 = a:n1.path.getSortKey()
 6304   0.235199   0.023931     let sortKey2 = a:n2.path.getSortKey()
 6304              0.006014     let i = 0
12538              0.036716     while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
12538              0.029757         if type(sortKey1[i]) == type(sortKey2[i])
12538              0.019455             if sortKey1[i] <# sortKey2[i]
 6011              0.004317                 return - 1
 6527              0.010496             elseif sortKey1[i] ># sortKey2[i]
  293              0.000239                 return 1
 6234              0.002586             endif
                                    elseif type(sortKey1[i]) == v:t_number
                                        return -1
                                    elseif type(sortKey2[i]) == v:t_number
                                        return 1
 6234              0.002407         endif
 6234              0.006361         let i = i + 1
 6234              0.003593     endwhile
                            
                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif

FUNCTION  gitgutter#async#available()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/async.vim line 9
Called 5 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    5              0.000021   return s:available

FUNCTION  <lambda>45()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  echodoc#enable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 33
Called 1 time
Total time:   0.000834
 Self time:   0.000834

count  total (s)   self (s)
    1              0.000014   if &showmode && &cmdheight < 2 && echodoc#is_echo()
                                " Increase the cmdheight so user can clearly see the error
                                set cmdheight=2
                                call s:print_error('Your cmdheight is too small. ' .'You must increase ''cmdheight'' value or set noshowmode.')
    1              0.000002   endif
                            
    1              0.000007   augroup echodoc
    1              0.000557     autocmd!
    1              0.000025     autocmd InsertEnter * call s:on_timer('InsertEnter')
    1              0.000019     autocmd CursorMovedI * call s:on_timer('CursorMovedI')
    1              0.000094     autocmd InsertLeave * call s:on_insert_leave()
    1              0.000005   augroup END
    2              0.000018   for event in g:echodoc#events
    1              0.000012     if exists('##' . event)
    1              0.000033       execute printf('autocmd echodoc %s * call s:on_event("%s")', event, event)
    1              0.000002     endif
    2              0.000005   endfor
    1              0.000005   let s:is_enabled = 1

FUNCTION  deoplete#handler#_do_complete()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 48
Called 38 times
Total time:   0.002786
 Self time:   0.002233

count  total (s)   self (s)
   38              0.000175   let context = g:deoplete#_context
   38              0.000178   let event = get(context, 'event', '')
   38              0.000199   let modes = (event ==# 'InsertEnter') ? ['n', 'i'] : ['i']
   38   0.001702   0.001148   if s:is_exiting() || index(modes, mode()) < 0 || s:check_input_method()
                                return
   38              0.000040   endif
                            
   38              0.000303   if empty(get(context, 'candidates', [])) || deoplete#util#get_input(context.event) !=# context.input
   38              0.000045     return
                              endif
                            
                              let prev = g:deoplete#_prev_completion
                              let prev.event = context.event
                              let prev.input = context.input
                              let prev.candidates = context.candidates
                              let prev.complete_position = context.complete_position
                              let prev.linenr = line('.')
                            
                              if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt')
                                call deoplete#mapping#_set_completeopt()
                              endif
                            
                              call deoplete#mapping#_complete()

FUNCTION  <SNR>168_upsert_new_gitgutter_signs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/sign.vim line 169
Called 4 times
Total time:   0.000645
 Self time:   0.000502

count  total (s)   self (s)
    4   0.000161   0.000085   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    4   0.000142   0.000075   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              " Handle special case where the first line is the site of two hunks:
                              " lines deleted above at the start of the file, and lines deleted
                              " immediately below.
    4              0.000051   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                let modified_lines = [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    4              0.000006   else
    4              0.000019     let modified_lines = a:modified_lines
    4              0.000005   endif
                            
    4              0.000018   for line in modified_lines
                                let line_number = line[0]  " <number>
                                if index(other_signs, line_number) == -1  " don't clobber others' signs
                                  let name = s:highlight_name_for_change(line[1])
                                  if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
                                    let old_sign = old_gitgutter_signs[line_number]
                                    if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
                                  endif
                                endif
    4              0.000009   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  deoplete#util#uniq()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 90
Called 49 times
Total time:   0.009676
 Self time:   0.009676

count  total (s)   self (s)
   49              0.001110   let list = map(copy(a:list), '[v:val, v:val]')
   49              0.000075   let i = 0
   49              0.000076   let seen = {}
  717              0.001094   while i < len(list)
  668              0.001539     let key = string(list[i][1])
  668              0.001075     if has_key(seen, key)
   47              0.000131       call remove(list, i)
  621              0.000252     else
  621              0.000903       let seen[key] = 1
  621              0.000588       let i += 1
  668              0.000282     endif
  717              0.000388   endwhile
   49              0.000616   return map(list, 'v:val[0]')

FUNCTION  <SNR>186_merge_higroup()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 166
Called 24 times
Total time:   0.005689
 Self time:   0.003814

count  total (s)   self (s)
   24              0.000120   if len(a:elements) < 2
    8              0.000021     return a:elements
   16              0.000016   endif
                            
   16              0.000086   let merged = [a:elements[0]]
   54              0.000206   for i in range(1, len(a:elements) - 1)
   38              0.000248     let prev = copy(merged[-1])
   38              0.000252     let curr = copy(a:elements[i])
   38              0.000943     if type(prev) == type({}) && type(curr) == type({}) &&synIDtrans(hlID(prev.highlight)) == synIDtrans(hlID(curr.highlight))
   16              0.000066       let highlight = prev.highlight
   16              0.000052       let prev.highlight = ''
   16              0.000039       let curr.highlight = ''
   16   0.002271   0.000397       let merged[-1] = {'type': 'merged','label': wintabs#element#render(prev).wintabs#element#render(curr),'highlight': highlight,}
   22              0.000026     else
   22              0.000095       call add(merged, curr)
   38              0.000050     endif
   54              0.000088   endfor
                            
   16              0.000040   return merged

FUNCTION  wintabs#ui#reset_statusline()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 38
Called 1422 times
Total time:   0.019531
 Self time:   0.019531

count  total (s)   self (s)
                              " reset statusline if its assigned winnr is stale
 1422              0.006669   if a:window != winnr()
                                call wintabs#ui#set_statusline()
 1422              0.001684   endif
 1422              0.002362   return ''

FUNCTION  <SNR>47_findAndRevealPath()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree/ui_glue.vim line 250
Called 1 time
Total time:   0.668546
 Self time:   0.000352

count  total (s)   self (s)
    1              0.000039     let l:pathStr = !empty(a:pathStr) ? a:pathStr : expand('%:p')
                            
    1              0.000005     if empty(l:pathStr)
                                    call nerdtree#echoWarning('no file for the current buffer')
                                    return
    1              0.000002     endif
                            
    1              0.000002     try
    1   0.000118   0.000027         let l:pathStr = g:NERDTreePath.Resolve(l:pathStr)
    1   0.000977   0.000024         let l:pathObj = g:NERDTreePath.New(l:pathStr)
                                catch /^NERDTree.InvalidArgumentsError/
                                    call nerdtree#echoWarning('invalid path')
                                    return
    1              0.000002     endtry
                            
    1   0.000034   0.000022     if !g:NERDTree.ExistsForTab()
    1              0.000002         try
    1   0.000785   0.000023             let l:cwd = g:NERDTreePath.New(getcwd())
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo('current directory does not exist.')
                                        let l:cwd = l:pathObj.getParent()
    1              0.000002         endtry
                            
    1   0.000651   0.000016         if l:pathObj.isUnder(l:cwd)
    1   0.650802   0.000069             call g:NERDTreeCreator.CreateTabTree(l:cwd.str())
                                    else
                                        call g:NERDTreeCreator.CreateTabTree(l:pathObj.getParent().str())
    1              0.000001         endif
                                else
                                    NERDTreeFocus
                            
                                    if !l:pathObj.isUnder(b:NERDTree.root.path)
                                        call s:chRoot(g:NERDTreeDirNode.New(l:pathObj.getParent(), b:NERDTree))
                                    endif
    1              0.000001     endif
                            
    1   0.000356   0.000013     if l:pathObj.isHiddenUnder(b:NERDTree.root.path)
                                    call b:NERDTree.ui.setShowHidden(1)
    1              0.000001     endif
                            
    1   0.007775   0.000011     let l:node = b:NERDTree.root.reveal(l:pathObj)
    1   0.005275   0.000009     call b:NERDTree.render()
    1   0.001644   0.000008     call l:node.putCursorHere(1, 0)

FUNCTION  288()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 10
Called 2 times
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
    2              0.000082     let newObj = copy(self)
                            
    2              0.000016     let newObj._filetype = a:args['filetype']
    2              0.000012     let newObj._name = a:args['name']
                            
    2              0.000005     if a:0
                                    " redirected checker
                                    let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
    2              0.000003     else
    2              0.000020         let newObj._exec_default = get(a:args, 'exec', newObj._name)
    2              0.000008         if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
    2              0.000003         endif
    2              0.000019         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
    2              0.000010         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
    2              0.000002         endif
    2              0.000003     endif
                            
    2              0.000025     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
    2              0.000020     if exists('*' . prefix . 'IsAvailable')
                                    let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    2              0.000003     else
    2              0.000030         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
    2              0.000003     endif
                            
    2              0.000019     if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    2              0.000002     endif
                            
    2              0.000006     return newObj

FUNCTION  ale#sign#ParsePattern()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 179
Called 5 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    5              0.000008     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " =1  id=1000001  =ale  =ALEErrorSign
                                    " =1  =1000001  =ale  =ALEWarningSign
                                    " lnea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
    5              0.000014         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " =1  id=1000001  =ALEErrorSign
                                    " =1  =1000001  =ALEWarningSign
                                    " lnea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    5              0.000003     endif
                            
    5              0.000008     return l:pattern

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/sign.vim line 57
Called 4 times
Total time:   0.003684
 Self time:   0.000691

count  total (s)   self (s)
    4   0.001549   0.000127   call s:find_current_signs(a:bufnr)
                            
    4              0.000052   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    4   0.000558   0.000147   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    4              0.000044   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    4              0.000011   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
    4              0.000005   endif
                            
    4   0.000622   0.000106   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    4   0.000749   0.000104   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    4              0.000012   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
    4              0.000004   endif

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/UltiSnips.vim line 146
Called 25 times
Total time:   0.031930
 Self time:   0.031930

count  total (s)   self (s)
   25              0.031905     exec g:_uspy "UltiSnips_Manager._track_change()"

FUNCTION  <SNR>70_set()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/delimitMate.vim line 15
Called 276 times
Total time:   0.012209
 Self time:   0.012209

count  total (s)   self (s)
  276              0.001085   let scope = a:0 ? a:1 : 's'
  276              0.001086   let bufnr = bufnr('%')
  276              0.001438   if !exists('s:options[bufnr]')
    4              0.000026     let s:options[bufnr] = {}
  276              0.000263   endif
  276              0.000626   if scope == 's'
  276              0.001452     let name = 's:options.' . bufnr . '.' . a:name
                              else
                                let name = scope . ':delimitMate_' . a:name
                                if exists('name')
                                  exec 'unlet! ' . name
                                endif
  276              0.000223   endif
  276              0.002501   exec 'let ' . name . ' = a:value'

FUNCTION  <SNR>84_doautocmd_user()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/obsession.vim line 57
Called 10 times
Total time:   0.000290
 Self time:   0.000290

count  total (s)   self (s)
   10              0.000216   if !exists('#User#' . a:arg)
   10              0.000039     return ''
                              elseif v:version >= 704
                                return 'doautocmd <nomodeline> User ' . fnameescape(a:arg)
                              else
                                return 'try | let [save_mls, &mls] = [&mls, 0] | ' . 'doautocmd <nomodeline> User ' . fnameescape(a:arg) . ' | ' . 'finally | let &mls = save_mls | endtry'
                              endif

FUNCTION  <SNR>264_on_insert_leave()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 183
Called 47 times
Total time:   0.004256
 Self time:   0.003136

count  total (s)   self (s)
   47   0.001058   0.000624   if echodoc#is_signature()
                                call rpcnotify(0, 'Gui', 'signature_hide')
   47              0.000047   endif
   47   0.000734   0.000376   if echodoc#is_floating()
   47              0.000160     if s:win != v:null
                                  call nvim_win_close(s:win, v:false)
                                  let s:win = v:null
   47              0.000036     endif
   47              0.000498     call nvim_buf_clear_namespace(s:floating_buf, s:echodoc_id, 0, -1)
   47              0.000043   endif
   47   0.000719   0.000392   if echodoc#is_virtual()
                                call nvim_buf_clear_namespace(bufnr('%'), s:echodoc_id, 0, -1)
   47              0.000036   endif

FUNCTION  ale#util#BinarySearch()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 226
Called 185 times
Total time:   0.004725
 Self time:   0.004725

count  total (s)   self (s)
  185              0.000678     let l:min = 0
  185              0.001192     let l:max = len(a:loclist) - 1
                            
  190              0.000651     while 1
  190              0.000702         if l:max < l:min
  185              0.000457             return -1
    5              0.000005         endif
                            
    5              0.000020         let l:mid = (l:min + l:max) / 2
    5              0.000017         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    5              0.000015         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
    5              0.000013         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
    5              0.000014         elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
    5              0.000011         elseif l:item.lnum > a:line
    5              0.000012             let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
    5              0.000005         endif
    5              0.000006     endwhile

FUNCTION  <SNR>164_ShouldOpen()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/list.vim line 34
Called 10 times
Total time:   0.000264
 Self time:   0.000144

count  total (s)   self (s)
   10   0.000187   0.000067     let l:val = ale#Var(a:buffer, 'open_list')
   10              0.000035     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   10              0.000032     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>151_ContextualIndents()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 351
Called 12 times
Total time:   0.024218
 Self time:   0.024218

count  total (s)   self (s)
   12              0.000065     let prev_ind = a:ind_list[0]
   12              0.000053     let hierind_list = [a:init_ind]
   12              0.000055     let ind_open_list = [a:ind_list[0]]
                            
  966              0.000816     for ind in a:ind_list
  954              0.001199         if ind > prev_ind
                                        " this line starts a new block
   48              0.000229             let hierind_list += [hierind_list[-1] + 1]
   48              0.000199             let ind_open_list += [ind]
  906              0.001124         elseif ind == prev_ind
                                        " this line continues a block
  878              0.002204             let hierind_list += [hierind_list[-1]]
   28              0.000064         elseif ind < prev_ind
                                        " this line closes current block only if indent is less or equal to
                                        " indent of the line starting the block (=ind_open_list[-2])
                                        " line may close more than one block
   28              0.000070             let n_closed = 0
   69              0.000373             while len(ind_open_list) >= 2 && ind <= ind_open_list[-2]
                                            " close block
   41              0.000204                 let ind_open_list = ind_open_list[:-2]
   41              0.000119                 let n_closed += 1
   69              0.000078             endwhile
                            
                                        " update current block indent
   28              0.000104             let ind_open_list[-1] = ind
                            
   28              0.000158             let hierind_list += [hierind_list[-1]-n_closed]
  954              0.000476         endif
  954              0.001248         let prev_ind = ind
  966              0.000556     endfor
   12              0.000197     let hierind_list = hierind_list[1:]
   12              0.000033     return hierind_list

FUNCTION  remote#host#PluginsForHost()
    Defined: /usr/share/nvim/runtime/autoload/remote/host.vim line 177
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000013   if !has_key(s:plugins_for_host, a:host)
    1              0.000004     let s:plugins_for_host[a:host] = []
    2              0.000002   end
    2              0.000005   return s:plugins_for_host[a:host]

FUNCTION  <SNR>186_slice()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 75
Called 43 times
Total time:   0.055727
 Self time:   0.029002

count  total (s)   self (s)
   43              0.000241   if type(a:var) == type('')
   13              0.000030     let skip = ''
   13              0.000028     let slice = ''
  126              0.000534     for char in split(a:var, '.\zs')
  113   0.003961   0.001339       if wintabs#element#len(skip) < a:start
                                    let skip = skip.char
                                    let width = wintabs#element#len(skip) - a:start
                                    if width > 0
                                      for i in range(1, max([min([width, a:width]), 0]))
                                        let slice = slice.' '
                                      endfor
                                    endif
  113   0.005185   0.001427       elseif wintabs#element#len(slice.char) > a:width
                                    for i in range(1, max([a:width - wintabs#element#len(slice), 0]))
                                      let slice = slice.' '
                                    endfor
                                    return slice
  113              0.000105       else
  113              0.000359         let slice = slice.char
  113              0.000098       endif
  126              0.000149     endfor
   13              0.000027     return slice
   30              0.000032   endif
                            
   30              0.000146   if type(a:var) == type({})
   20              0.000120     let element = copy(a:var)
   20   0.000935   0.000735     let element.label = wintabs#element#slice(element.label, a:start, a:width)
   20              0.000042     return element
   10              0.000009   endif
                            
   10              0.000040   if type(a:var) == type([])
   10              0.000026     let skip = []
   10              0.000023     let slice = []
   42              0.000101     for element in a:var
   32   0.001341   0.000458       let skip_len = wintabs#element#len(skip)
   32              0.000096       if skip_len < a:start
                                    call add(skip, element)
                                    if wintabs#element#len(skip) > a:start
                                      let start = a:start - skip_len
                                      call add(slice, wintabs#element#slice(element, start, a:width))
                                    endif
   32              0.000036       else
   32   0.003088   0.000436         let width = a:width - wintabs#element#len(slice)
   32              0.000079         if width <= 0
                                      return slice
   32              0.000034         endif
   32   0.001527   0.001083         call add(slice, wintabs#element#slice(element, 0, width))
   32              0.000038       endif
   42              0.000061     endfor
   10              0.000022     return slice
                              endif
                            
                              return []

FUNCTION  wintabs#element#slice()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 12
Called 62 times
Total time:   0.058945
 Self time:   0.000556

count  total (s)   self (s)
   62   0.020191   0.005008   return wintabs#memoize#call(function('s:slice'), a:var, a:start, a:width)

FUNCTION  <SNR>155_ApplyPartialTimer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 432
Called 5 times
Total time:   0.002083
 Self time:   0.000154

count  total (s)   self (s)
    5              0.000020     if has_key(s:partial_timers, a:timer_id)
    5              0.000038         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    5   0.002016   0.000087         call call(l:Callback, [a:timer_id] + l:args)
    5              0.000003     endif

FUNCTION  <SNR>151_NextNonBlankLine()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 227
Called 1037 times
Total time:   0.054817
 Self time:   0.020300

count  total (s)   self (s)
 1037              0.003127     let numlines = line('$')
 1037              0.002305     let curr_line = a:lnum + 1
                            
 1133              0.002314     while curr_line <= numlines
 1115   0.043150   0.008633         if s:ConsiderLine(curr_line)
 1019              0.001322             return curr_line
   96              0.000095         endif
                            
   96              0.000265         let curr_line += 1
  114              0.000149     endwhile
                            
   18              0.000036     return -1

FUNCTION  deoplete#send_event()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete.vim line 43
Called 48 times
Total time:   0.009238
 Self time:   0.002126

count  total (s)   self (s)
   48   0.001517   0.000958   let sources = deoplete#util#convert2list(get(a:000, 0, []))
   48   0.007550   0.000997   call deoplete#util#rpcnotify('deoplete_on_event', {'event': a:event, 'sources': sources})

FUNCTION  syntastic#util#bufIsActive()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 233
Called 7 times
Total time:   0.000411
 Self time:   0.000411

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    7              0.000055     let buf = str2nr(a:buffer)
                            
    7              0.000045     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
    7              0.000008     endif
                            
                                " get rid of hidden buffers
   15              0.000078     for tab in range(1, tabpagenr('$'))
   15              0.000112         if index(tabpagebuflist(tab), buf) >= 0
    7              0.000013             return 1
    8              0.000007         endif
    8              0.000009     endfor
                            
                                return 0

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 123
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000006     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
    2              0.000001     endif
                            
    2              0.000003     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
    2              0.000001     endif
                            
    2              0.000006     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
    2              0.000001     endif
                            
    2              0.000004     return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 668
Called 52 times
Total time:   0.288743
 Self time:   0.009450

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   52   0.001615   0.000749     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
   52   0.009878   0.000910     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
   52   0.003309   0.001361     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   52   0.001694   0.000763     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   52   0.000918   0.000818     silent doautocmd <nomodeline> User ALELintPre
                            
  104              0.000371     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   52              0.000158         if !l:linter.lint_file || a:should_lint_file
   52   0.267434   0.001202             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
   52              0.000202                 let l:can_clear_results = 0
   52              0.000051             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
   52              0.000040         endif
  104              0.000308     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   52              0.000104     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
   52              0.000101     elseif l:new_buffer
    1   0.000281   0.000033         call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
   52              0.000040     endif

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 9
Called 56 times
Total time:   0.002889
 Self time:   0.002889

count  total (s)   self (s)
   56              0.000282   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   56              0.000358   let bvars = getbufvar(buffer, '')
   56              0.000214   if empty(bvars)
                                let bvars = {}
   56              0.000076   endif
   56              0.000380   let dict = get(bvars, 'gitgutter', {})
   56              0.000315   let needs_setting = empty(dict)
   56              0.000442   let dict[a:varname] = a:val
   56              0.000140   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
   56              0.000065   endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree.vim line 121
Called 6755 times
Total time:   0.026239
 Self time:   0.026239

count  total (s)   self (s)
 6755              0.024479     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  ale#path#FindNearestDirectory()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/path.vim line 44
Called 52 times
Total time:   0.007985
 Self time:   0.007985

count  total (s)   self (s)
   52              0.001149     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   52              0.000368     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   52              0.005566     let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
   52              0.000181     if !empty(l:relative_path)
   52              0.000578         return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''

FUNCTION  <SNR>151_PrevNonBlankLine()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 245
Called 96 times
Total time:   0.007623
 Self time:   0.002781

count  total (s)   self (s)
   96              0.000350     let curr_line = a:lnum - 1
                            
  125              0.000278     while curr_line > 0
  116   0.006161   0.001319         if s:ConsiderLine(curr_line)
   87              0.000164             return curr_line
   29              0.000029         endif
                            
   29              0.000086         let curr_line += -1
   38              0.000049     endwhile
                            
    9              0.000014     return 0

FUNCTION  provider#Poll()
    Defined: /usr/share/nvim/runtime/autoload/provider.vim line 6
Called 2 times
Total time:   0.304726
 Self time:   0.304726

count  total (s)   self (s)
    2              0.000009   let job = {'rpc': v:true, 'stderr_buffered': v:true}
    2              0.000002   try
    2              0.003201     let channel_id = jobstart(a:argv, job)
    2              0.301421     if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
    2              0.000020       return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
    2              0.000013   endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)

FUNCTION  UltiSnips#SnippetsInCurrentScope()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/UltiSnips.vim line 87
Called 1 time
Total time:   0.025499
 Self time:   0.025499

count  total (s)   self (s)
    1              0.000040     let g:current_ulti_dict = {}
    1              0.000009     let all = get(a:, 1, 0)
    1              0.000002     if all
                                  let g:current_ulti_dict_info = {}
    1              0.000001     endif
    1              0.025432     exec g:_uspy "UltiSnips_Manager.snippets_in_current_scope(" . all . ")"
    1              0.000010     return g:current_ulti_dict

FUNCTION  <SNR>79_strip_trailing_new_line()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 216
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015   return substitute(a:line, '[[:cntrl:]]$', '', '')

FUNCTION  <SNR>117_session_save_window()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/session.vim line 82
Called 1426 times
Total time:   0.207510
 Self time:   0.179595

count  total (s)   self (s)
 1426              0.012779   let s:session[a:tabpage][a:window] = []
 1426   0.052804   0.024889   let buflist = wintabs#gettabwinvar(a:tabpage, a:window, 'wintabs_buflist', [])
                            
                              " bufnr isn't persisted across sessions, but bufname is
 3922              0.011481   for buffer in buflist
 2496              0.086467     let pathname = fnamemodify(bufname(buffer), ':p')
 2496              0.019717     call add(s:session[a:tabpage][a:window], pathname)
 3922              0.006318   endfor

FUNCTION  <SNR>117_session_save_tabpage()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/session.vim line 93
Called 9 times
Total time:   0.002221
 Self time:   0.000644

count  total (s)   self (s)
    9              0.000189   let s:session[a:tabpage] = {}
   22              0.000120   for window in range(1, winnr('$'))
   13   0.001815   0.000238     call s:session_save_window(a:tabpage, window)
   22              0.000030   endfor

FUNCTION  multiple_cursors#new()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 123
Called 5 times
Total time:   0.128438
 Self time:   0.002113

count  total (s)   self (s)
                              " Call before function if exists only once until it is canceled (<Esc>)
    5   0.000374   0.000163   call s:fire_pre_triggers()
    5              0.000073   let s:use_word_boundary = a:word_boundary
    5              0.000027   if a:mode ==# 'n'
                                " Reset all existing cursors, don't restore view and setting
    1   0.000194   0.000022     call s:cm.reset(0, 0)
                            
                                " Select the word under cursor to set the '< and '> marks
    1              0.000084     exec "normal! viw"
    1   0.000112   0.000030     call s:exit_visual_mode()
                            
                                " Add cursor with the current visual selection
    1   0.001201   0.000053     call s:cm.add(s:pos("'>"), s:region("'<", "'>"))
    1   0.023805   0.000031     call s:wait_for_user_input('v')
    4              0.000016   elseif a:mode ==# 'v'
                                " If the visual area covers the same line, then do a search for next
                                " occurrence
    4              0.000047     let start = line("'<")
    4              0.000019     let finish = line("'>")
    4              0.000017     if start != finish
                                  call s:cm.reset(0, 0)
                                  let col = col("'<")
                                  for line in range(line("'<"), line("'>"))
                                    let pos = [line, col]
                                    call s:cm.add(pos)
                                  endfor
                                  " Start in normal mode
                                  call s:wait_for_user_input('n')
    4              0.000007     else
                                  " Came directly from visual mode
    4   0.000179   0.000068       if s:cm.is_empty()
                                    call s:cm.reset(0, 0)
                            
                                    if visualmode() ==# 'V'
                                      let left = [line('.'), 1]
                                      let right = [line('.'), col('$')-1]
                                      if right[1] == 0 " empty line
                                        return
                                      endif
                                      call s:cm.add(right, [left, right])
                                    else
                                      call s:cm.add(s:pos("'>"), s:region("'<", "'>"))
                                    endif
    4              0.000006       endif
    4   0.003585   0.000175       let content = s:get_text(s:region("'<", "'>"))
    4   0.000783   0.000120       let next = s:find_next(content)
    4   0.002147   0.000083       if s:cm.add(next[1], next)
    4   0.001046   0.000101         call s:update_visual_markers(next)
                                  else
                                    call cursor(s:cm.get_current().position)
                                    echohl WarningMsg | echo 'No more matches' | echohl None
    4              0.000006       endif
    4   0.093861   0.000116       call s:wait_for_user_input('v')
    4              0.000007     endif
    5              0.000007   endif

FUNCTION  426()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 636
Called 1 time
Total time:   0.000576
 Self time:   0.000162

count  total (s)   self (s)
    1              0.000011   let self.saved_settings['virtualedit'] = &virtualedit
    1              0.000007   let self.saved_settings['cursorline'] = &cursorline
    1              0.000005   let self.saved_settings['lazyredraw'] = &lazyredraw
    1              0.000005   let self.saved_settings['paste'] = &paste
    1              0.000005   let self.saved_settings['clipboard'] = &clipboard
    1   0.000121   0.000020   let &virtualedit = "onemore"
    1   0.000091   0.000021   let &cursorline = 0
    1   0.000070   0.000009   let &lazyredraw = 1
    1   0.000072   0.000013   let &paste = 0
    1   0.000145   0.000021   set clipboard-=unnamed clipboard-=unnamedplus
                              " We could have already saved the view from multiple_cursors#find
    1              0.000004   if !self.start_from_find
    1              0.000011     let self.saved_winview = winsaveview()
    1              0.000001   endif
                            
                              " Save contents and type of unnamed register upon entering multicursor mode
                              " to restore it later when leaving mode
    1              0.000011   let s:paste_buffer_temporary_text = getreg('"')
    1              0.000008   let s:paste_buffer_temporary_type = getregtype('"')

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 470
Called 185 times
Total time:   0.017006
 Self time:   0.012281

count  total (s)   self (s)
  185              0.002217     let l:info = get(g:ale_buffer_info, a:buffer, {})
  185              0.001462     let l:loclist = get(l:info, 'loclist', [])
  185              0.001491     let l:pos = getpos('.')
  185   0.009092   0.004366     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
  185              0.001227     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  185              0.000823     return [l:info, l:loc]

FUNCTION  <SNR>109_tabname()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 136
Called 120 times
Total time:   0.002713
 Self time:   0.001591

count  total (s)   self (s)
  120   0.002651   0.001530     return s:gettabvar(a:tabnr, "taboo_tab_name")

FUNCTION  provider#python3#Prog()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim line 13
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:prog

FUNCTION  wintabs#renderers#right_arrow()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/renderers.vim line 78
Called 10 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
   10              0.000077   return {'type': 'right_arrow','label': g:wintabs_ui_arrow_right,'highlight': '',}

FUNCTION  echodoc#default#get_cache()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc/default.vim line 83
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000014   if !has_key(s:complete_cache, a:filetype)
    1              0.000006     let s:complete_cache[a:filetype] = {}
    2              0.000002   endif
                            
    2              0.000009   return s:complete_cache[a:filetype]

FUNCTION  <SNR>164_WinFindBuf()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/list.vim line 74
Called 5 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    5              0.000042     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>264_on_event()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 126
Called 2 times
Total time:   0.001041
 Self time:   0.000276

count  total (s)   self (s)
    2              0.000014   unlet! s:_timer
                            
    2   0.000785   0.000059   let filetype = s:context_filetype_enabled() ? context_filetype#get_filetype(&filetype) : &l:filetype
    2              0.000007   if filetype ==# ''
                                let filetype = 'nothing'
    2              0.000002   endif
                            
    2              0.000016   let completed_item = get(v:, 'completed_item', {})
    2              0.000015   if empty(completed_item) && exists('v:event')
    2              0.000013     let completed_item = get(v:event, 'completed_item', {})
    2              0.000002   endif
    2              0.000011   if filetype !=# '' && !empty(completed_item)
                                call echodoc#default#make_cache(filetype, completed_item)
    2              0.000002   endif
                            
    2              0.000044   let dicts = filter(copy(s:echodoc_dicts), "empty(get(v:val, 'filetypes', {}))  || get(v:val.filetypes, filetype, 0)")
                            
    2              0.000012   let defaut_only = len(dicts) == 1
                            
    2   0.000080   0.000041   if defaut_only && empty(echodoc#default#get_cache(filetype))
    2              0.000003     return
                              endif
                            
                              let cur_text = echodoc#util#get_func_text()
                            
                              " No function text was found
                              if cur_text ==# '' && defaut_only
                                return
                              endif
                            
                              let echodoc = {}
                              for doc_dict in dicts
                                if doc_dict.name ==# 'default'
                                  let ret = doc_dict.search(cur_text, filetype)
                                else
                                  let ret = doc_dict.search(cur_text)
                                endif
                            
                                if !empty(ret)
                                  " Overwrite cached result
                                  let echodoc = ret
                                  break
                                endif
                              endfor
                            
                              if !empty(echodoc)
                                let b:echodoc = echodoc
                                call s:display(echodoc, filetype)
                              elseif exists('b:echodoc')
                                unlet b:echodoc
                              endif

FUNCTION  NERDTreeGitStatusRefresh()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/git_status.vim line 75
Called 9 times
Total time:   2.235688
 Self time:   0.003129

count  total (s)   self (s)
    9              0.000083     let b:NERDTreeCachedGitFileStatus = {}
    9              0.000051     let b:NERDTreeCachedGitDirtyDir   = {}
    9              0.000044     let b:NOT_A_GIT_REPOSITORY        = 1
                            
    9   0.003214   0.000417     let l:root = fnamemodify(b:NERDTree.root.path.str(), ":p:S")
    9              0.000057     let l:gitcmd = 'git -c color.status=false status -s'
    9              0.000036     if g:NERDTreeShowIgnoredStatus
                                    let l:gitcmd = l:gitcmd . ' --ignored'
    9              0.000012     endif
    9              0.000075     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
    9              0.000009     endif
    9   2.230262   0.000500     let l:statusesStr = system(l:gitcmd . ' ' . l:root)
    9              0.000451     let l:statusesSplit = split(l:statusesStr, '\n')
    9              0.000083     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
    9              0.000021     endif
    9              0.000059     let b:NOT_A_GIT_REPOSITORY = 0
                            
    9              0.000090     for l:statusLine in l:statusesSplit
                                    " cache git status of files
                                    let l:pathStr = substitute(l:statusLine, '...', '', '')
                                    let l:pathSplit = split(l:pathStr, ' -> ')
                                    if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
                                    else
                                        let l:pathStr = l:pathSplit[0]
                                    endif
                                    let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
                                    if l:pathStr =~# '\.\./.*'
                                        continue
                                    endif
                                    let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
                                    let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
                                    if l:statusKey == 'Ignored'
                                        if isdirectory(l:pathStr)
                                            let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
                                        endif
                                    else
                                        call s:NERDTreeCacheDirtyDir(l:pathStr)
                                    endif
    9              0.000032     endfor

FUNCTION  <SNR>151_AnyfoldDisable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 633
Called 25 times
Total time:   0.000604
 Self time:   0.000604

count  total (s)   self (s)
   25              0.000210     if &diff || (&buftype ==# "terminal")
                                    if &foldtext=="MinimalFoldText()"
                                        setlocal foldtext=foldtext() " reset foldtext to default
                                    endif
                                    return 1
   25              0.000035     else
   25              0.000051         return 0
                                endif

FUNCTION  deoplete#custom#_get_option()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 84
Called 667 times
Total time:   0.003514
 Self time:   0.003514

count  total (s)   self (s)
  667              0.002928   return s:cached.option[a:name]

FUNCTION  ale#path#CdString()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/path.vim line 74
Called 52 times
Total time:   0.002565
 Self time:   0.001285

count  total (s)   self (s)
   52              0.000423     if has('win32')
                                    return 'cd /d ' . ale#Escape(a:directory) . ' && '
   52              0.000074     else
   52   0.001822   0.000541         return 'cd ' . ale#Escape(a:directory) . ' && '
                                endif

FUNCTION  nerdtree#exec()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree.vim line 113
Called 23 times
Total time:   0.028237
 Self time:   0.003457

count  total (s)   self (s)
   23              0.000370     let old_ei = &ei
   23   0.002029   0.000556     set ei=BufEnter,BufLeave,VimEnter
   23   0.024115   0.002090     exec a:cmd
   23   0.001671   0.000389     let &ei = old_ei

FUNCTION  <SNR>158_RemoveProblemsForDisabledLinters()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 561
Called 52 times
Total time:   0.001948
 Self time:   0.001948

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
   52              0.000200     let l:name_map = {}
                            
  104              0.000298     for l:linter in a:linters
   52              0.000287         let l:name_map[l:linter.name] = 1
  104              0.000134     endfor
                            
   52              0.000673     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>263_get_time_in_ms()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1198
Called 8 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
    8              0.000452   return str2nr(substitute(reltimestr(reltime()), '\.\(...\).*', '\1', ''))

FUNCTION  <SNR>109_fullpath()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 226
Called 120 times
Total time:   0.004986
 Self time:   0.004986

count  total (s)   self (s)
  120              0.002945     let path = fnamemodify(a:bufname, ':p')
  120              0.001919     return a:pretty ? substitute(path, $HOME, '~', '') : path

FUNCTION  <SNR>25_start_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 330
Called 1 time
Total time:   0.709197
 Self time:   0.000197

count  total (s)   self (s)
    1              0.000004     let s:winv = winsaveview()
    1              0.000002     let s:winnr = winnr()
    1              0.000003     let s:winres = winrestcmd()
                            
    1   0.000016   0.000009     call s:trigger_before_open()
                            
    1   0.006557   0.000008     call s:winopen()
    1   0.000158   0.000012     let layout = s:calc_layout()
    1   0.001588   0.000017     let string = s:create_string(layout)
                            
    1              0.000002     if g:leaderGuide_max_size
                                    let layout.win_dim = min([g:leaderGuide_max_size, layout.win_dim])
    1              0.000001     endif
                            
    1   0.000039   0.000004     setlocal modifiable
    1              0.000001     if g:leaderGuide_vertical
                                    noautocmd execute 'vert res '.layout.win_dim
    1              0.000001     else
    1              0.000024         noautocmd execute 'res '.layout.win_dim
    1              0.000001     endif
    1              0.000040     silent 1put!=string
    1              0.000038     normal! gg"_dd
    1   0.000035   0.000005     setlocal nomodifiable
    1   0.700674   0.000013     call s:wait_for_input()

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 72
Called 19 times
Total time:   0.001180
 Self time:   0.000883

count  total (s)   self (s)
   19              0.000079     if s:has_nvim_highlight
   19   0.000713   0.000416         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
   19              0.000019     endif

FUNCTION  <SNR>109_expand()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 105
Called 120 times
Total time:   0.096512
 Self time:   0.027839

count  total (s)   self (s)
  120              0.000390     let out = a:fmt
  120   0.015329   0.002512     let out = substitute(out, '\C%f', s:bufname(a:tabnr), "")
  120   0.015304   0.002371     let out = substitute(out, '\C%a', s:bufpath(a:tabnr), "")
  120   0.003572   0.002145     let out = substitute(out, '\C%n', s:tabnum(a:tabnr, 0), "")
  120   0.002413   0.001844     let out = substitute(out, '\C%N', s:tabnum(a:tabnr, 1), "")
  120   0.003921   0.001923     let out = substitute(out, '\C%w', s:wincount(a:tabnr, 0), "")
  120   0.003042   0.001911     let out = substitute(out, '\C%W', s:wincount(a:tabnr, 1), "")
  120   0.010559   0.002682     let out = substitute(out, '\C%u', s:wincountUnicode(a:tabnr, 0), "")
  120   0.008982   0.002729     let out = substitute(out, '\C%U', s:wincountUnicode(a:tabnr, 1), "")
  120   0.008797   0.002299     let out = substitute(out, '\C%m', s:modflag(a:tabnr), "")
  120   0.004969   0.002257     let out = substitute(out, '\C%l', s:tabname(a:tabnr), "")
  120   0.009251   0.002077     let out = substitute(out, '\C%p', s:tabpwd(a:tabnr, 0), "")
  120   0.009272   0.001987     let out = substitute(out, '\C%P', s:tabpwd(a:tabnr, 1), "")
  120              0.000242     return out

FUNCTION  ale#engine#Cleanup()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 707
Called 5 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
    5              0.000048     if get(v:, 'exiting', v:null) isnot v:null
                                    return
    5              0.000007     endif
                            
    5              0.000028     if exists('*ale#lsp#CloseDocument')
                                    call ale#lsp#CloseDocument(a:buffer)
    5              0.000006     endif
                            
    5              0.000036     if !has_key(g:ale_buffer_info, a:buffer)
    5              0.000009         return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>262_parseJSON()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 97
Called 5 times
Total time:   0.000487
 Self time:   0.000487

count  total (s)   self (s)
    5              0.000011     let l:parsed = []
                            
   10              0.000020     for l:line in a:lines
    5              0.000005         try
    5              0.000144             let l:parsed = extend(l:parsed, json_decode(l:line))
                                    catch
    5              0.000005         endtry
   10              0.000009     endfor
                            
    5              0.000022     if type(l:parsed) != v:t_list || empty(l:parsed)
                                    return []
    5              0.000003     endif
                            
    5              0.000017     let l:errors = l:parsed[0]['messages']
                            
    5              0.000009     if empty(l:errors)
    3              0.000003         return []
    2              0.000001     endif
                            
    2              0.000003     let l:output = []
                            
    4              0.000007     for l:error in l:errors
    2              0.000016         let l:obj = ({   'lnum': get(l:error, 'line', 0),   'text': get(l:error, 'message', ''),   'type': 'E',})
                            
    2              0.000006         if get(l:error, 'severity', 0) is# 1
                                        let l:obj.type = 'W'
    2              0.000001         endif
                            
    2              0.000006         if has_key(l:error, 'ruleId')
    2              0.000005             let l:code = l:error['ruleId']
                            
                                        " Sometimes ESLint returns null here
    2              0.000004             if !empty(l:code)
                                            let l:obj.code = l:code
    2              0.000001             endif
    2              0.000001         endif
                            
    2              0.000004         if has_key(l:error, 'column')
    2              0.000005             let l:obj.col = l:error['column']
    2              0.000001         endif
                            
    2              0.000008         if has_key(l:error, 'endColumn')
                                        let l:obj.end_col = l:error['endColumn'] - 1
    2              0.000001         endif
                            
    2              0.000004         if has_key(l:error, 'endLine')
                                        let l:obj.end_lnum = l:error['endLine']
    2              0.000001         endif
                            
    2              0.000007         call add(l:output, l:obj)
    4              0.000005     endfor
                            
    2              0.000003     return l:output

FUNCTION  430()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 694
Called 5 times
Total time:   0.003131
 Self time:   0.000671

count  total (s)   self (s)
                              " Lazy init
    5   0.000156   0.000058   if self.is_empty()
    1   0.000589   0.000013     call self.initialize()
    5              0.000007   endif
                            
                              " Don't add duplicates
    5              0.000018   let i = 0
   15              0.000048   for c in self.cursors
   10              0.000041     if c.position == a:pos
                                  return 0
   10              0.000011     endif
   10              0.000029     let i+=1
   15              0.000025   endfor
                            
    5   0.000900   0.000095   let cursor = s:Cursor.new(a:pos)
                            
                              " Save the visual selection
    5              0.000019   if a:0 > 0
    5   0.001057   0.000076     call cursor.update_visual_selection(a:1)
    5              0.000008   endif
                            
    5              0.000039   call add(self.cursors, cursor)
    5              0.000024   let self.current_index += 1
    5              0.000011   return 1

FUNCTION  <SNR>69_ExtraMappings()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 325
Called 12 times
Total time:   0.008665
 Self time:   0.006712

count  total (s)   self (s)
                              " If pair is empty, delete both delimiters:
   12              0.000365   inoremap <silent> <Plug>delimitMateBS <C-R>=delimitMate#BS()<CR>
   12              0.000356   if !hasmapto('<Plug>delimitMateBS','i')
   12              0.000271     if empty(maparg('<BS>', 'i'))
   12              0.000309       silent! imap <unique> <buffer> <BS> <Plug>delimitMateBS
   12              0.000014     endif
   12              0.000265     if empty(maparg('<C-H>', 'i'))
   12              0.000262       silent! imap <unique> <buffer> <C-h> <Plug>delimitMateBS
   12              0.000011     endif
   12              0.000012   endif
                              " If pair is empty, delete closing delimiter:
   12              0.000348   inoremap <silent> <expr> <Plug>delimitMateS-BS delimitMate#WithinEmptyPair() ? "\<Del>" : "\<S-BS>"
   12              0.000536   if !hasmapto('<Plug>delimitMateS-BS','i') && maparg('<S-BS>', 'i') == ''
   12              0.000265     silent! imap <unique> <buffer> <S-BS> <Plug>delimitMateS-BS
   12              0.000012   endif
                              " Expand return if inside an empty pair:
   12              0.000345   inoremap <expr><silent> <Plug>delimitMateCR <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandReturn()\<CR>"
   12   0.000880   0.000196   if s:get('expand_cr') && !hasmapto('<Plug>delimitMateCR', 'i') && maparg('<CR>', 'i') == ''
                                silent! imap <unique> <buffer> <CR> <Plug>delimitMateCR
   12              0.000014   endif
                              " Expand space if inside an empty pair:
   12              0.000389   inoremap <expr><silent> <Plug>delimitMateSpace <SID>TriggerAbb()."\<C-R>=delimitMate#ExpandSpace()\<CR>"
   12   0.000840   0.000188   if s:get('expand_space') && !hasmapto('<Plug>delimitMateSpace', 'i') && maparg('<Space>', 'i') == ''
                                silent! imap <unique> <buffer> <Space> <Plug>delimitMateSpace
   12              0.000012   endif
                              " Jump over any delimiter:
   12              0.000379   inoremap <expr><silent> <Plug>delimitMateS-Tab <SID>TriggerAbb()."\<C-R>=delimitMate#JumpAny()\<CR>"
   12   0.001261   0.000644   if s:get('tab2exit') && !hasmapto('<Plug>delimitMateS-Tab', 'i') && maparg('<S-Tab>', 'i') == ''
                                silent! imap <unique> <buffer> <S-Tab> <Plug>delimitMateS-Tab
   12              0.000012   endif
                              " Jump over next delimiters
   12              0.000396   inoremap <expr><buffer> <Plug>delimitMateJumpMany <SID>TriggerAbb()."\<C-R>=delimitMate#JumpMany()\<CR>"
   12              0.000560   if !hasmapto('<Plug>delimitMateJumpMany', 'i') && maparg("<C-G>g", 'i') == ''
   12              0.000286     imap <silent> <buffer> <C-G>g <Plug>delimitMateJumpMany
   12              0.000013   endif

FUNCTION  <SNR>263_apply_user_input_next()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 989
Called 15 times
Total time:   0.006924
 Self time:   0.001428

count  total (s)   self (s)
   15              0.000095   let s:valid_input = 1
                            
                              " Save the current mode, only if we haven't already
   15              0.000061   if empty(s:to_mode)
    3              0.000013     let s:to_mode = a:mode
    3              0.000008     if s:to_mode ==# 'v'
                                  if visualmode() ==# 'V'
                                    let s:to_mode = 'V'
                                  endif
    3              0.000003     endif
   15              0.000012   endif
                            
                              " Update the current cursor's information
   15   0.005406   0.000269   let changed = s:cm.update_current()
                            
                              " Advance the cursor index
   15   0.000370   0.000126   call s:cm.next()
                            
                              " We're done if we're made the full round
   15   0.000153   0.000092   if s:cm.loop_done()
    3              0.000009     if s:to_mode ==# 'v' || s:to_mode ==# 'V'
                                  " This is necessary to set the "'<" and "'>" markers properly
                                  call s:update_visual_markers(s:cm.get_current().visual)
    3              0.000002     endif
    3              0.000039     call feedkeys("\<Plug>(multiple-cursors-wait)")
    3   0.000091   0.000036     call s:handle_visual_IA_to_insert()
   12              0.000014   else
                                " Continue to next
   12              0.000170     call feedkeys("\<Plug>(multiple-cursors-input)")
   15              0.000013   endif

FUNCTION  deoplete#handler#_completion_begin()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 180
Called 76 times
Total time:   0.037987
 Self time:   0.004772

count  total (s)   self (s)
   76   0.012636   0.001064   call deoplete#custom#_update_cache()
                            
   76   0.017949   0.001056   if s:is_skip(a:event)
   38              0.000140     let g:deoplete#_context.candidates = []
   38              0.000034     return
   38              0.000021   endif
                            
   38   0.001371   0.000739   call s:check_prev_completion(a:event)
                            
   38              0.000074   if a:event !=# 'Async'
   38   0.001050   0.000562     call deoplete#init#_prev_completion()
   38              0.000035   endif
                            
   38   0.004323   0.000692   call deoplete#util#rpcnotify( 'deoplete_auto_completion_begin', {'event': a:event})

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 445
Called 5 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    5              0.000046     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    5              0.000030     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    5              0.000008     return l:timer_id

FUNCTION  <SNR>120_get_bufline_non_memoized()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 71
Called 12 times
Total time:   0.009818
 Self time:   0.004046

count  total (s)   self (s)
   12              0.000036   let line = []
   12              0.000037   let active_start = 0
   12              0.000028   let active_end = 0
   12              0.000025   let i = 0
   12   0.000371   0.000170   let buffers = wintabs#getwinvar(a:window, 'wintabs_buflist', [])
   12              0.000077   let active_index = index(buffers, winbufnr(a:window))
                            
   24              0.000070   for buffer in buffers
   12              0.000054     let is_active = i == active_index
   12              0.000053     let is_next_active = i == active_index - 1
   12              0.000137     let is_active_window = g:wintabs_display == 'tabline'|| (g:wintabs_display == 'statusline' && a:window == winnr())
                            
   12              0.000023     if i == 0
    8              0.000015       if is_active
    4   0.000169   0.000053         let active_start = wintabs#element#len(line)
    8              0.000009       endif
                            
    8   0.000712   0.000306       let element = g:wintabs_renderers.buffer_sep({'is_leftmost': 1,'is_rightmost': 0,'is_left': active_index >= 0,'is_right': 0,'is_active': is_active,'is_active_window': is_active_window,'ordinal': i + 1,})
    8              0.000033       let element.type = 'sep'
    8              0.000041       call add(line, element)
   12              0.000012     endif
                            
   12   0.002034   0.000456     let element = g:wintabs_renderers.buffer(buffer, {'is_leftmost': 0,'is_rightmost': i == len(buffers) - 1,'is_left': active_index >= 0 && i < active_index,'is_right': active_index >= 0 && i > active_index,'is_active': is_active,'is_active_window': is_active_window,'ordinal': i + 1,})
   12              0.000042     let element.type = 'buffer'
   12              0.000038     let element.number = buffer
   12              0.000054     call add(line, element)
                            
   12              0.000035     if is_next_active
    4   0.000241   0.000064       let active_start = wintabs#element#len(line)
   12              0.000014     endif
                            
   12   0.000987   0.000459     let element = g:wintabs_renderers.buffer_sep({'is_leftmost': 0,'is_rightmost': i == len(buffers) - 1,'is_left': active_index >= 0 && i < active_index,'is_right': active_index >= 0 && i >= active_index,'is_active': is_active || is_next_active,'is_active_window': is_active_window,'ordinal': i + 1,})
   12              0.000040     let element.type = 'sep'
   12              0.000050     call add(line, element)
                            
   12              0.000023     if is_active
    8   0.002879   0.000113       let active_end = wintabs#element#len(line)
   12              0.000021     endif
                            
   12              0.000032     let i = i + 1
   24              0.000053   endfor
                            
   12              0.000060   return [line, active_start, active_end]

FUNCTION  deoplete#auto_complete()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete.vim line 49
Called 29 times
Total time:   0.009678
 Self time:   0.000615

count  total (s)   self (s)
   29   0.009643   0.000581   return deoplete#handler#_completion_begin(get(a:000, 0, 'Async'))

FUNCTION  ale#command#InitData()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 19
Called 104 times
Total time:   0.001560
 Self time:   0.001560

count  total (s)   self (s)
  104              0.000709     if !has_key(s:buffer_data, a:buffer)
    5              0.000074         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
  104              0.000090     endif

FUNCTION  echodoc#is_virtual()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 71
Called 47 times
Total time:   0.000327
 Self time:   0.000327

count  total (s)   self (s)
   47              0.000182   return g:echodoc#type ==# 'virtual' && exists('*nvim_buf_set_virtual_text')

FUNCTION  deoplete#custom#_get_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 67
Called 125 times
Total time:   0.001470
 Self time:   0.001457

count  total (s)   self (s)
  125              0.000417   if !exists('b:custom')
    1   0.000029   0.000015     call deoplete#custom#_init_buffer()
  125              0.000082   endif
                            
  125              0.000214   return b:custom

FUNCTION  <SNR>151_GetIndentFold()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 389
Called 954 times
Total time:   0.063860
 Self time:   0.057037

count  total (s)   self (s)
  954   0.015199   0.008376     if s:IsComment(a:lnum) && (s:IsComment(a:lnum-1) || s:IsComment(a:lnum+1))
                                    if g:anyfold_fold_comments
                                        " introduce artifical fold for docuboxes
                                        return b:anyfold_ind_contextual[a:lnum-1] + 1
                                    endif
  954              0.000512     endif
                            
  954              0.002840     let this_indent = b:anyfold_ind_contextual[a:lnum-1]
                            
  954              0.001751     if a:lnum >= line('$')
   11              0.000033         let next_indent = 0
  943              0.000570     else
  943              0.002443         let next_indent = b:anyfold_ind_contextual[a:lnum]
  954              0.000573     endif
                            
                                " heuristics to define blocks at foldlevel 0
  954              0.001814     if g:anyfold_fold_toplevel && this_indent == 0
                            
                                    let prev_indent = b:anyfold_ind_contextual[a:lnum-2]
                            
                                    if a:lnum == 1
                                        let prevprev_indent = 0
                                    else
                                        let prevprev_indent = b:anyfold_ind_contextual[a:lnum-3]
                                    endif
                            
                                    if a:lnum >= line('$') - 1
                                        let nextnext_indent = 0
                                    else
                                        let nextnext_indent = b:anyfold_ind_contextual[a:lnum+1]
                                    endif
                            
                                    if next_indent > 0
                                        return '>1'
                                    endif
                            
                                    if prev_indent > 0
                                        return 0
                                    else
                                        if prevprev_indent > 0
                                            if next_indent == 0 && nextnext_indent == 0
                                                return '>1'
                                            else
                                                return 0
                                            endif
                                        else
                                            return 1
                                        endif
                                    endif
  954              0.000484     endif
                            
  954              0.001490     if next_indent <= this_indent
  906              0.001091         return this_indent
   48              0.000046     else
   48              0.000149         return '>' . next_indent
                                endif
                            

FUNCTION  ale#completion#CanProvideCompletions()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/completion.vim line 669
Called 29 times
Total time:   0.017336
 Self time:   0.000959

count  total (s)   self (s)
   58   0.016946   0.000568     for l:linter in ale#linter#Get(&filetype)
   29              0.000085         if !empty(l:linter.lsp)
                                        return 1
   29              0.000019         endif
   58              0.000046     endfor
                            
   29              0.000036     return 0

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 112
Called 21 times
Total time:   0.001245
 Self time:   0.000625

count  total (s)   self (s)
   21   0.000928   0.000403   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
   21   0.000270   0.000175   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>69_Map()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 157
Called 12 times
Total time:   0.041621
 Self time:   0.002229

count  total (s)   self (s)
                              " Set mappings:
   12              0.000026   try
   12              0.000055     let save_keymap = &keymap
   12              0.000048     let save_iminsert = &iminsert
   12              0.000038     let save_imsearch = &imsearch
   12              0.000159     let save_cpo = &cpo
   12              0.000183     set keymap=
   12              0.000164     set cpo&vim
   12   0.000258   0.000222     silent! doautocmd <nomodeline> User delimitMate_map
   12   0.000877   0.000159     if s:get('autoclose')
   12   0.030157   0.000183       call s:AutoClose()
                                else
                                  call s:NoAutoClose()
   12              0.000014     endif
   12   0.008846   0.000181     call s:ExtraMappings()
   12              0.000028   finally
   12              0.000213     let &cpo = save_cpo
   12              0.000132     let &keymap = save_keymap
   12              0.000126     let &iminsert = save_iminsert
   12              0.000070     let &imsearch = save_imsearch
   12              0.000024   endtry
                            
   12              0.000052   let b:delimitMate_enabled = 1

FUNCTION  wintabs#session#save()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/session.vim line 19
Called 1422 times
Total time:   0.347082
 Self time:   0.138928

count  total (s)   self (s)
                              " do not save session during SessionLoadPost autocmd
 1422              0.007233   if exists('g:SessionLoad')
                                return
 1422              0.001252   endif
                            
                              " if tabpages count is correct, refresh passed tabpages, otherwise refresh all 
                              " tabpages
 1422              0.007775   if len(s:session) == tabpagenr('$')
 1422              0.007344     if !has_key(s:session, a:tabpage)
                                  let s:session[a:tabpage] = {}
 1422              0.001366     endif
                            
                                " if windows count is correct, refresh passed window, otherwise refresh all 
                                " windows
 1422              0.009666     if len(s:session[a:tabpage]) == winnr('$')
 1413   0.231547   0.025614       call s:session_save_window(a:tabpage, a:window)
    9              0.000012     else
                                  " this occurs on closing window
    9   0.002459   0.000238       call s:session_save_tabpage(a:tabpage)
 1422              0.001539     endif
                            
                              else
                                " this occurs on closing tabpage
                                call s:session_save_all()
 1422              0.001387   endif
                            
                              " serialize to session global
 1422              0.040182   let g:Wintabs_session_string = string(s:session)

FUNCTION  126()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/tree_file_node.vim line 102
Called 15 times
Total time:   0.007325
 Self time:   0.000363

count  total (s)   self (s)
   15   0.007309   0.000347     return self.path.str() ==# a:treenode.path.str()

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 48
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000005     if a:line >= a:end_line
                                    " For single lines, just return the one position.
    2              0.000009         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  <SNR>79_winshell()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 72
Called 8 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
    8              0.000175   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  echodoc#is_floating()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 74
Called 47 times
Total time:   0.000358
 Self time:   0.000358

count  total (s)   self (s)
   47              0.000309   return g:echodoc#type ==# 'floating' && exists('*nvim_open_win')

FUNCTION  <SNR>263_start_latency_measure()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1168
Called 8 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
    8              0.000053   if g:multi_cursor_debug_latency
                                let s:start_time = reltime()
    8              0.000014   endif

FUNCTION  <SNR>25_create_string()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 247
Called 1 time
Total time:   0.001571
 Self time:   0.001325

count  total (s)   self (s)
    1              0.000002     let l = a:layout
    1              0.000002     let l.capacity = l.n_rows * l.n_cols
    1              0.000002     let overcap = l.capacity - l.n_items
    1              0.000002     let overh = l.n_cols - overcap
    1              0.000001     let n_rows =  l.n_rows - 1
                            
    1              0.000001     let rows = []
    1              0.000001     let row = 0
    1              0.000001     let col = 0
    1              0.000023     let smap = sort(filter(keys(s:lmap), 'v:val !=# "name"'),'1')
   20              0.000017     for k in smap
   19              0.000083         let desc = type(s:lmap[k]) == type({}) ? s:lmap[k].name : s:lmap[k][1]
   19   0.000278   0.000154         let displaystring = "[".s:show_displayname(k)."] ".desc
   19              0.000042         let crow = get(rows, row, [])
   19              0.000023         if empty(crow)
    7              0.000012             call add(rows, crow)
   19              0.000008         endif
   19              0.000034         call add(crow, displaystring)
   19              0.000075         call add(crow, repeat(' ', l.col_width - strdisplaywidth(displaystring)))
                            
   19              0.000023         if !g:leaderGuide_sort_horizontal
   19              0.000022             if row >= n_rows - 1
    4              0.000005                 if overh > 0 && row < n_rows
    1              0.000001                     let overh -= 1
    1              0.000001                     let row += 1
    3              0.000001                 else
    3              0.000003                     let row = 0
    3              0.000003                     let col += 1
    4              0.000002                 endif
   15              0.000006             else
   15              0.000017                 let row += 1
   19              0.000008             endif
                                    else
                                        if col == l.n_cols - 1
                                            let row +=1
                                            let col = 0
                                        else
                                            let col += 1
                                        endif
   19              0.000007         endif
   19   0.000520   0.000398         silent execute "cnoremap <nowait> <buffer> ".substitute(k, "|", "<Bar>", ""). " " . s:escape_keys(k) ."<CR>"
   20              0.000013     endfor
    1              0.000001     let r = []
    1              0.000001     let mlen = 0
    8              0.000006     for ro in rows
    7              0.000017         let line = join(ro, '')
    7              0.000010         call add(r, line)
    7              0.000021         if strdisplaywidth(line) > mlen
    1              0.000004             let mlen = strdisplaywidth(line)
    7              0.000002         endif
    8              0.000003     endfor
    1              0.000002     call insert(r, '')
    1              0.000007     let output = join(r, "\n ")
    1              0.000012     cnoremap <nowait> <buffer> <Space> <Space><CR>
    1              0.000012     cnoremap <nowait> <buffer> <silent> <c-c> <LGCMD>submode<CR>
    1              0.000003     return output

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 228
Called 5 times
Total time:   0.001061
 Self time:   0.000117

count  total (s)   self (s)
    5   0.000374   0.000054     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    5   0.000675   0.000050     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>263_update_visual_markers()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 806
Called 4 times
Total time:   0.000945
 Self time:   0.000611

count  total (s)   self (s)
    4              0.000027   if a:region[0] == a:region[1]
                                normal! v
    4              0.000007   else
    4              0.000031     call cursor(a:region[1])
    4              0.000200     normal! m`
    4              0.000029     call cursor(a:region[0])
    4              0.000193     normal! v``
    4              0.000007   endif
    4   0.000427   0.000093   call s:exit_visual_mode()

FUNCTION  <SNR>70_get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/delimitMate.vim line 32
Called 468 times
Total time:   0.013923
 Self time:   0.013923

count  total (s)   self (s)
  468              0.001043   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
  468              0.000880   elseif a:0 == 1
   24              0.000180     let bufoptions = get(s:options, bufnr('%'), {})
   24              0.000169     return deepcopy(get(bufoptions, a:name, a:1))
  444              0.000460   else
  444              0.004862     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  gitgutter#utility#windows()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 220
Called 5 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    5              0.000109   return has('win64') || has('win32') || has('win16')

FUNCTION  deoplete#init#_prev_completion()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/init.vim line 231
Called 85 times
Total time:   0.001707
 Self time:   0.001707

count  total (s)   self (s)
   85              0.001512   let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'linenr': -1, 'candidates': [], 'complete_position': -1, }

FUNCTION  ale#linter#GetAll()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 380
Called 81 times
Total time:   0.017109
 Self time:   0.006142

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
   81   0.004145   0.000689     if ale#util#InSandbox()
                                    return []
   81              0.000055     endif
                            
   81              0.000239     let l:combined_linters = []
                            
  162              0.000392     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   81              0.000355         if !has_key(s:runtime_loaded_map, l:filetype)
    1   0.008463   0.000952             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
    1              0.000009             let s:runtime_loaded_map[l:filetype] = 1
   81              0.000058         endif
                            
   81              0.001004         call extend(l:combined_linters, get(s:linters, l:filetype, []))
  162              0.000207     endfor
                            
   81              0.000170     return l:combined_linters

FUNCTION  401()
    Defined: /usr/share/nvim/runtime/autoload/provider/node.vim line 29
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000035   let bin_dir = join(get(self, 'stdout', []), '')
    2              0.000009   let entry_point = bin_dir . self.entry_point
    2              0.000037   let self.result = filereadable(entry_point) ? entry_point : ''

FUNCTION  403()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 326
Called 54 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   54              0.000149   return self.position[0]

FUNCTION  407()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 357
Called 15 times
Total time:   0.000880
 Self time:   0.000394

count  total (s)   self (s)
   15   0.000343   0.000135   call s:cm.remove_highlight(self.cursor_hi_id)
   15   0.000522   0.000244   let self.cursor_hi_id = s:highlight_cursor(self.position)

FUNCTION  408()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 364
Called 15 times
Total time:   0.000399
 Self time:   0.000341

count  total (s)   self (s)
   15   0.000330   0.000272   let self.line_length = col([self.line(), '$'])

FUNCTION  <SNR>181_is_skip_text()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 222
Called 76 times
Total time:   0.013784
 Self time:   0.008347

count  total (s)   self (s)
   76   0.005853   0.000961   let input = deoplete#util#get_input(a:event)
                            
   76              0.000915   let lastchar = matchstr(input, '.$')
   76   0.001419   0.001065   let skip_multibyte = deoplete#custom#_get_option('skip_multibyte')
   76              0.000523   if skip_multibyte && len(lastchar) != strwidth(lastchar) && empty(get(b:, 'eskk', []))
                                return 1
   76              0.000058   endif
                            
                              " Note: Use g:deoplete#_context is needed instead of
                              " g:deoplete#_prev_completion
   76              0.000445   let prev_input = get(g:deoplete#_context, 'input', '')
   76              0.000324   if input ==# prev_input && a:event !=# 'Manual' && a:event !=# 'Async' && a:event !=# 'TextChangedP'
    1              0.000003     return 1
   75              0.000046   endif
   75              0.000262   if a:event ==# 'Async' && prev_input !=# '' && input !=# prev_input
   29              0.000033     return 1
   46              0.000030   endif
                            
   46              0.000350   if (exists('b:eskk') && !empty(b:eskk)     && !s:check_eskk_phase_henkan(input))
                                return 1
   46              0.000028   endif
                            
   46              0.000390   let displaywidth = strdisplaywidth(input) + 1
   46              0.000573   if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
   46              0.000027   endif
                            
   46   0.000870   0.000679   let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
   46              0.000391   return (a:event !=# 'Manual' && input !=# ''     && index(skip_chars, input[-1:]) >= 0)

FUNCTION  <SNR>168_remove_signs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/sign.vim line 154
Called 4 times
Total time:   0.000516
 Self time:   0.000335

count  total (s)   self (s)
    4   0.000203   0.000104   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
    4   0.000167   0.000085     let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
    4              0.000045     execute "sign unplace * buffer=" . a:bufnr
    4              0.000012     if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
    4              0.000006     endif
                              else
                                for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    4              0.000005   endif

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 429
Called 81 times
Total time:   0.007648
 Self time:   0.002104

count  total (s)   self (s)
   81   0.006920   0.001375     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   81              0.000303     if type(l:filetype) isnot v:t_list
   81              0.000193         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>141__isDebugEnabled_smart()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/log.vim line 149
Called 86 times
Total time:   0.000532
 Self time:   0.000532

count  total (s)   self (s)
   86              0.000462     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>69_AutoClose()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/delimitMate.vim line 282
Called 12 times
Total time:   0.029974
 Self time:   0.015435

count  total (s)   self (s)
                              " Add matching pair and jump to the midle:
                              " inoremap <silent> <buffer> ( ()<Left>
   12              0.000035   let i = 0
   60   0.004382   0.001048   while i < len(s:get('matchpairs_list'))
   48   0.005905   0.001229     let ld = s:get('left_delims')[i] == '|' ? '<bar>' : s:get('left_delims')[i]
   48   0.005730   0.001139     let rd = s:get('right_delims')[i] == '|' ? '<bar>' : s:get('right_delims')[i]
   48              0.002581     exec 'inoremap <expr><silent> <Plug>delimitMate' . ld. ' <SID>TriggerAbb().delimitMate#ParenDelim("' . escape(rd, '|') . '")'
   48              0.001593     exec 'silent! imap <unique> <buffer> '.ld.' <Plug>delimitMate'.ld
   48              0.000164     let i += 1
   60              0.000116   endwhile
                            
                              " Exit from inside the matching pair:
   60   0.000894   0.000311   for delim in s:get('right_delims')
   48              0.000197     let delim = delim == '|' ? '<bar>' : delim
   48              0.001672     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb().delimitMate#JumpOut("\' . delim . '")'
   48              0.001326     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate'. delim
   60              0.000087   endfor
                            
                              " Add matching quote and jump to the midle, or exit if inside a pair of matching quotes:
                              " inoremap <silent> <buffer> " <C-R>=delimitMate#QuoteDelim("\"")<CR>
   48   0.000906   0.000249   for delim in s:get('quotes_list')
   36              0.000083     if delim == '|'
                                  let delim = '<Bar>'
   36              0.000038     endif
   36              0.001431     exec 'inoremap <expr><silent> <Plug>delimitMate' . delim. ' <SID>TriggerAbb()."<C-R>=delimitMate#QuoteDelim(\"\\\' . delim . '\")<CR>"'
   36              0.001002     exec 'silent! imap <unique> <buffer> ' . delim. ' <Plug>delimitMate' . delim
   48              0.000069   endfor
                            
                              " Try to fix the use of apostrophes (kept for backward compatibility):
                              " inoremap <silent> <buffer> n't n't
   12   0.000886   0.000188   for map in s:get('apostrophes_list')
                                exec "inoremap <silent> " . map . " " . map
                                exec 'silent! imap <unique> <buffer> ' . map . ' <Plug>delimitMate' . map
   12              0.000022   endfor

FUNCTION  deoplete#util#get_next_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 44
Called 88 times
Total time:   0.006735
 Self time:   0.001616

count  total (s)   self (s)
   88   0.006663   0.001544   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  ale#util#Mode()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 5
Called 257 times
Total time:   0.002617
 Self time:   0.002617

count  total (s)   self (s)
  257              0.002118     return call('mode', a:000)

FUNCTION  <SNR>263_handle_visual_IA_to_insert()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 970
Called 3 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    3              0.000018   if !empty(s:saved_char) && s:char =~# 'v\|V' && s:to_mode ==# 'n'
                                if s:saved_char ==# 'I'
                                  call s:cm.reposition_all_within_region(1)
                                endif
                                call feedkeys(tolower(s:saved_char))
                                let s:saved_char = ''
    3              0.000002   endif

FUNCTION  <SNR>263_find_next()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 822
Called 4 times
Total time:   0.000663
 Self time:   0.000554

count  total (s)   self (s)
    4              0.000085   let pattern = substitute(escape(a:text, '\'), '\n', '\\n', 'g')
    4              0.000020   if s:use_word_boundary == 1
    4              0.000026       let pattern = '\<'.pattern.'\>'
    4              0.000006   endif
    4              0.000018   let pattern = '\V\C'.pattern
    4              0.000154   call search(pattern)
    4   0.000135   0.000074   let start = s:pos('.')
    4              0.000075   call search(pattern, 'ce')
    4   0.000114   0.000066   let end = s:pos('.')
    4              0.000015   return [start, end]

FUNCTION  200()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 43
Called 1 time
Total time:   0.650496
 Self time:   0.000044

count  total (s)   self (s)
    1   0.000068   0.000018     let creator = s:Creator.New()
    1   0.650424   0.000023     call creator.createTabTree(a:name)

FUNCTION  201()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 50
Called 2 times
Total time:   1.324484
 Self time:   0.000329

count  total (s)   self (s)
    2   0.003487   0.000037     let l:path = self._pathForString(a:name)
                            
                                " Abort if an exception was thrown (i.e., if the bookmark or directory
                                " does not exist).
    2              0.000009     if empty(l:path)
                                    return
    2              0.000003     endif
                            
                                " Obey the user's preferences for changing the working directory.
    2              0.000009     if g:NERDTreeChDirMode != 0
                                    call l:path.changeToDir()
    2              0.000002     endif
                            
    2   0.000045   0.000025     if g:NERDTree.ExistsForTab()
                                    call g:NERDTree.Close()
                                    call self._removeTreeBufForTab()
    2              0.000002     endif
                            
    2   0.185062   0.000026     call self._createTreeWin()
    2   1.116869   0.000053     call self._createNERDTree(l:path, 'tab')
    2   0.017758   0.000034     call b:NERDTree.render()
    2   0.001091   0.000044     call b:NERDTree.root.putCursorHere(0, 0)
                            
    2   0.000087   0.000027     call self._broadcastInitEvent()

FUNCTION  204()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 111
Called 2 times
Total time:   1.116816
 Self time:   0.000139

count  total (s)   self (s)
    2   0.000771   0.000054     let b:NERDTree = g:NERDTree.New(a:path, a:type)
                            
                                " TODO: This assignment is kept for compatibility reasons.  Many other
                                " plugins use "b:NERDTreeRoot" instead of "b:NERDTree.root".  Remove this
                                " assignment in the future.
    2              0.000014     let b:NERDTreeRoot = b:NERDTree.root
                            
    2   1.116007   0.000047     call b:NERDTree.root.open()

FUNCTION  209()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 216
Called 6 times
Total time:   0.000404
 Self time:   0.000404

count  total (s)   self (s)
    6              0.000355     let newCreator = copy(self)
    6              0.000031     return newCreator

FUNCTION  syntastic#util#isRunningWindows()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 11
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000031     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>3_my_displayfunc()
    Defined: ~/config/nvim/init.vim line 905
Called 16 times
Total time:   0.000569
 Self time:   0.000569

count  total (s)   self (s)
   16              0.000167     let g:leaderGuide#displayname = substitute(g:leaderGuide#displayname, '\c<CR>$', '', '')
   16              0.000132     let g:leaderGuide#displayname = substitute(g:leaderGuide#displayname, '^<Plug>', '', '')
   16              0.000091     let g:leaderGuide#displayname = substitute(g:leaderGuide#displayname, ':', '', '')
   16              0.000079     let g:leaderGuide#displayname = substitute(g:leaderGuide#displayname, '(', '', '')
   16              0.000076     let g:leaderGuide#displayname = substitute(g:leaderGuide#displayname, ')', '', '')

FUNCTION  410()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 376
Called 5 times
Total time:   0.000194
 Self time:   0.000140

count  total (s)   self (s)
    5              0.000037   let self.saved_visual = deepcopy(self.visual)
    5              0.000021   let self.visual = []
                              " TODO(terryma): Move functionality into separate class
    5   0.000108   0.000054   call s:cm.remove_highlight(self.visual_hi_id)
    5              0.000012   let self.visual_hi_id = 0

FUNCTION  411()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 385
Called 5 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    5              0.000083   call setreg('"', self.paste_buffer_text, self.paste_buffer_type)

FUNCTION  412()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 390
Called 5 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    5              0.000041   let self.paste_buffer_text = getreg('"')
    5              0.000021   let self.paste_buffer_type = getregtype('"')

FUNCTION  <SNR>25_init_on_call()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 488
Called 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000013     let s:vis = a:vis ? 'gv' : ''
    1              0.000009     let s:count = v:count != 0 ? v:count : ''
    1              0.000005     let s:current_level = 1
    1              0.000004     let s:last_inp = []
                            
    1              0.000020     if has('nvim') && !exists('s:reg')
    1              0.000004         let s:reg = ''
                                else
                                    let s:reg = v:register != s:get_register() ? '"'.v:register : ''
    1              0.000002     endif

FUNCTION  414()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 425
Called 2 times
Total time:   0.000961
 Self time:   0.000543

count  total (s)   self (s)
    2              0.000005   if a:restore_view
                                " Return the view back to the beginning
    1              0.000003     if !empty(self.saved_winview)
    1              0.000008       call winrestview(self.saved_winview)
    1              0.000001     endif
                            
                                " If the cursor moved, just restoring the view could get confusing, let's
                                " put the cursor at where the user left it. Only do this if we didn't start
                                " from find mode
    1   0.000020   0.000008     if !self.is_empty() && !self.start_from_find
    1   0.000018   0.000012       call cursor(self.get(0).position)
    1              0.000001     endif
    2              0.000002   endif
                            
                              " Delete all cursors and clear their highlights. Don't do clearmatches() as
                              " that will potentially interfere with other plugins
    2   0.000056   0.000022   if !self.is_empty()
    6   0.000018   0.000016     for i in range(self.size())
    5   0.000099   0.000047       call self.remove_highlight(self.get(i).cursor_hi_id)
    5   0.000116   0.000075       call self.remove_highlight(self.get(i).visual_hi_id)
    6              0.000006     endfor
    2              0.000002   endif
                            
    2              0.000131   let self.cursors = []
    2              0.000008   let self.current_index = -1
    2              0.000005   let self.starting_index = -1
    2              0.000009   let self.saved_winview = []
    2              0.000005   let self.start_from_find = 0
    2              0.000005   let s:char = ''
    2              0.000005   let s:saved_char = ''
    2              0.000005   if a:restore_setting
    1   0.000281   0.000019     call self.restore_user_settings()
    2              0.000002   endif
                              " Call after function if exists and only if action is canceled (<Esc>)
    2              0.000007   if a:0 && s:before_function_called
    1              0.000004     if exists('*Multiple_cursors_after')
                                  exe "call Multiple_cursors_after()"
    1              0.000001     endif
    1   0.000026   0.000018     silent doautocmd User MultipleCursorsPost
    1              0.000005     let s:before_function_called = 0
    2              0.000002   endif

FUNCTION  <SNR>159_TemporaryFilename()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 116
Called 52 times
Total time:   0.003720
 Self time:   0.001896

count  total (s)   self (s)
   52              0.000326     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   52              0.000128     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
   52              0.000038     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   52   0.002728   0.000904     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  417()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 480
Called 35 times
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
   35              0.000305   return self.cursors[self.current_index]

FUNCTION  <SNR>263_strpart()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1035
Called 4 times
Total time:   0.002871
 Self time:   0.002871

count  total (s)   self (s)
    4              0.000018   if a:l == 0
                                return ''
    4              0.000008   endif
    4              0.000031   let [s, l] = ['', 0]
  152              0.000834   for c in split(a:s[a:i :], '\zs')
  152              0.000449     let s .= c
  152              0.000544     let l += len(c)
  152              0.000325     if l >= a:l
    4              0.000007       break
  148              0.000133     endif
  152              0.000204   endfor
    4              0.000013   return s

FUNCTION  deoplete#mapping#_restore_completeopt()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/mapping.vim line 52
Called 85 times
Total time:   0.001066
 Self time:   0.001066

count  total (s)   self (s)
   85              0.000496   if exists('g:deoplete#_saved_completeopt')
                                let &completeopt = g:deoplete#_saved_completeopt
                                unlet g:deoplete#_saved_completeopt
   85              0.000080   endif

FUNCTION  <SNR>107__skip_file()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 727
Called 4 times
Total time:   0.000711
 Self time:   0.000417

count  total (s)   self (s)
    4              0.000026     let fname = bufname(a:buf)
    4   0.000627   0.000334     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    4              0.000009     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
    4              0.000004     endif
    4              0.000008     return skip

FUNCTION  echodoc#is_signature()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 67
Called 47 times
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
   47              0.000391   return g:echodoc#type ==# 'signature' && has('nvim') && get(g:, 'gonvim_running', 0)

FUNCTION  ale#util#InSandbox()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 284
Called 348 times
Total time:   0.029866
 Self time:   0.009486

count  total (s)   self (s)
  348              0.000835     try
  348   0.025015   0.004635         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
  348              0.000721     endtry
                            
  348              0.000584     return 0

FUNCTION  <SNR>163_UpdateLineNumbers()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 256
Called 5 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
    5              0.000013     let l:line_map = {}
    5              0.000011     let l:line_numbers_changed = 0
                            
    7              0.000021     for [l:line, l:sign_id, l:name] in a:current_sign_list
    2              0.000009         let l:line_map[l:sign_id] = l:line
    7              0.000007     endfor
                            
    7              0.000012     for l:item in a:loclist
    2              0.000004         if l:item.bufnr == a:buffer
    2              0.000011             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
    2              0.000004             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
    2              0.000001             endif
    2              0.000001         endif
    7              0.000007     endfor
                            
                                " When the line numbers change, sort the list again
    5              0.000008     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    5              0.000003     endif

FUNCTION  gitgutter#init_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter.vim line 25
Called 11 times
Total time:   0.013211
 Self time:   0.000881

count  total (s)   self (s)
   11   0.004066   0.000235   if gitgutter#utility#is_active(a:bufnr)
    6   0.000424   0.000135     let p = gitgutter#utility#repo_path(a:bufnr, 0)
    6              0.000047     if type(p) != s:t_string || empty(p)
    2   0.008264   0.000087       call gitgutter#utility#set_repo_path(a:bufnr)
    2   0.000161   0.000128       call s:setup_maps()
    6              0.000019     endif
   11              0.000015   endif

FUNCTION  210()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 223
Called 2 times
Total time:   0.000105
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000097   0.000042     let name = s:Creator.BufNamePrefix() . self._nextBufferNumber()
    2              0.000006     return name

FUNCTION  211()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 230
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000013     if !exists("s:Creator._NextBufNum")
    1              0.000004         let s:Creator._NextBufNum = 1
    1              0.000002     else
    1              0.000005         let s:Creator._NextBufNum += 1
    2              0.000003     endif
                            
    2              0.000006     return s:Creator._NextBufNum

FUNCTION  212()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 242
Called 2 times
Total time:   0.003451
 Self time:   0.000426

count  total (s)   self (s)
    2              0.000010     let path = {}
    2   0.000402   0.000044     if g:NERDTreeBookmark.BookmarkExistsFor(a:str)
                                    let path = g:NERDTreeBookmark.BookmarkFor(a:str).path
    2              0.000005     else
    2              0.000051         let dir = a:str ==# '' ? getcwd() : a:str
                            
                                    "hack to get an absolute path if a relative path is given
    2              0.000025         if dir =~# '^\.'
                                        let dir = getcwd() . g:NERDTreePath.Slash() . dir
    2              0.000005         endif
    2   0.000350   0.000094         let dir = g:NERDTreePath.Resolve(dir)
                            
    2              0.000011         try
    2   0.002478   0.000067             let path = g:NERDTreePath.New(dir)
                                    catch /^NERDTree.InvalidArgumentsError/
                                        call nerdtree#echo("No bookmark or directory found for: " . a:str)
                                        return {}
    2              0.000005         endtry
    2              0.000003     endif
    2              0.000006     if !path.isDirectory
                                    let path = path.getParent()
    2              0.000002     endif
                            
    2              0.000005     return path

FUNCTION  214()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 287
Called 3 times
Total time:   0.084123
 Self time:   0.000813

count  total (s)   self (s)
                            
                                " Options for a non-file/control buffer.
    3   0.000296   0.000053     setlocal bufhidden=hide
    3   0.000212   0.000028     setlocal buftype=nofile
    3   0.000399   0.000188     setlocal noswapfile
                            
                                " Options for controlling buffer/window appearance.
    3   0.000214   0.000035     setlocal foldcolumn=0
    3   0.000203   0.000026     setlocal foldmethod=manual
    3   0.000429   0.000033     setlocal nobuflisted
    3   0.000199   0.000023     setlocal nofoldenable
    3   0.000195   0.000023     setlocal nolist
    3   0.000194   0.000022     setlocal nospell
    3   0.000184   0.000021     setlocal nowrap
                            
    3              0.000012     if g:NERDTreeShowLineNumbers
    3   0.000220   0.000050         setlocal nu
                                else
                                    setlocal nonu
                                    if v:version >= 703
                                        setlocal nornu
                                    endif
    3              0.000004     endif
                            
    3              0.000008     iabc <buffer>
                            
    3              0.000013     if g:NERDTreeHighlightCursorline
    3   0.000195   0.000025         setlocal cursorline
    3              0.000004     endif
                            
    3   0.000520   0.000044     call self._setupStatusline()
    3   0.020037   0.000048     call self._bindMappings()
                            
    3   0.060498   0.000067     setlocal filetype=nerdtree

FUNCTION  215()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 325
Called 3 times
Total time:   0.000476
 Self time:   0.000069

count  total (s)   self (s)
    3              0.000021     if g:NERDTreeStatusline != -1
    3   0.000447   0.000040         let &l:statusline = g:NERDTreeStatusline
    3              0.000004     endif

FUNCTION  217()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 350
Called 5 times
Total time:   0.786174
 Self time:   0.000369

count  total (s)   self (s)
    5   0.000558   0.000205     let creator = s:Creator.New()
    5   0.785562   0.000110     call creator.toggleTabTree(a:dir)

FUNCTION  218()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/creator.vim line 362
Called 5 times
Total time:   0.785452
 Self time:   0.000579

count  total (s)   self (s)
    5   0.001533   0.000134     if g:NERDTree.ExistsForTab()
    4   0.001341   0.000089         if !g:NERDTree.IsOpen()
    1   0.047358   0.000045             call self._createTreeWin()
    1              0.000004             if !&hidden
                                            call b:NERDTree.render()
    1              0.000002             endif
    1   0.000316   0.000025             call b:NERDTree.ui.restoreScreenState()
    3              0.000006         else
    3   0.060602   0.000067             call g:NERDTree.Close()
    4              0.000005         endif
    1              0.000002     else
    1   0.674122   0.000040         call self.createTabTree(a:dir)
    5              0.000005     endif

FUNCTION  420()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 499
Called 35 times
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
   35              0.000083   if a:hi_id
                                " If the user did a matchdelete or a clearmatches, we don't want to barf if
                                " the matchid is no longer valid
   25              0.000169     silent! call matchdelete(a:hi_id)
   35              0.000036   endif

FUNCTION  422()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 527
Called 15 times
Total time:   0.005136
 Self time:   0.003047

count  total (s)   self (s)
   15   0.000379   0.000181   let cur = self.get_current()
   15              0.000055   if s:to_mode ==# 'v' || s:to_mode ==# 'V'
                                " If we're in visual line mode, we need to go to visual mode before we can
                                " update the visual region
                                if s:to_mode ==# 'V'
                                  exec "normal! gvv\<Esc>"
                                endif
                                " Sets the cursor at the right place
                                exec "normal! gv\<Esc>"
                                call cur.update_visual_selection(s:get_visual_region(s:pos('.')))
   15              0.000049   elseif s:from_mode ==# 'v' || s:from_mode ==# 'V'
                                " Save contents of unnamed register after each operation in Visual mode.
                                " This should be executed after user input is processed, when unnamed
                                " register already contains the text.
    5   0.000128   0.000055     call cur.save_unnamed_register()
    5   0.000227   0.000033     call cur.remove_visual_selection()
   10              0.000040   elseif s:from_mode ==# 'i' && s:to_mode ==# 'n' && self.current_index != 0
                                normal! h
   10              0.000016   elseif s:from_mode ==# 'n'
                                " Save contents of unnamed register after each operation in Normal mode.
                                call cur.save_unnamed_register()
   15              0.000012   endif
   15   0.000367   0.000186   let pos = s:pos('.')
                            
                              " If the total number of lines changed in the buffer, we need to potentially
                              " adjust other cursor locations
   15              0.000064   let vdelta = line('$') - s:saved_linecount
   15              0.000027   if vdelta != 0
                                if self.current_index != self.size() - 1
                                  let cur_column_offset = (cur.column() - col('.')) * -1
                                  let new_line_length = len(getline('.'))
                                  for i in range(self.current_index+1, self.size()-1)
                                    let hdelta = 0
                                    " Note: some versions of Vim don't like chaining function calls like
                                    " a.b().c(). For compatibility reasons, don't do it
                                    let c = self.get(i)
                                    " If there're other cursors on the same line, we need to adjust their
                                    " columns. This needs to happen before we adjust their line!
                                    if cur.line() == c.line() || cur.position == pos
                                      if vdelta > 0
                                        " Added a line
                                        let hdelta = cur_column_offset
                                      else
                                        " Removed a line
                                        let hdelta = new_line_length
                                      endif
                                    endif
                                    call c.move(vdelta, hdelta)
                                  endfor
                                endif
   15              0.000013   else
                                " If the line length changes, for all the other cursors on the same line as
                                " the current one, update their cursor location as well
   15              0.000083     let hdelta = col('$') - cur.line_length
                                " Only do this if we're still on the same line as before
   15   0.000222   0.000161     if hdelta != 0 && cur.line() == line('.')
                                  " Update all the cursor's positions that occur after the current cursor on
                                  " the same line
   15   0.000196   0.000138       if self.current_index != self.size() - 1
   12   0.000168   0.000132         for i in range(self.current_index+1, self.size()-1)
   12   0.000194   0.000119           let c = self.get(i)
                                      " Only do it for cursors on the same line
   12   0.000188   0.000125           if cur.line() == c.line()
                                        call c.move(0, hdelta)
   12              0.000013           else
                                        " Early exit, if we're not on the same line, neither will any cursor
                                        " that come after this
   12              0.000017             break
                                      endif
   12              0.000035         endfor
   15              0.000013       endif
   15              0.000010     endif
   15              0.000010   endif
                            
   15              0.000041   if cur.position == pos
                                return 0
   15              0.000014   endif
   15   0.001303   0.000153   call cur.update_position(pos)
   15              0.000023   return 1

FUNCTION  424()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 615
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000017   let self.current_index  = 0
    3              0.000010   let self.starting_index = 0

FUNCTION  425()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 621
Called 15 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   15              0.000042   return self.current_index == self.starting_index

FUNCTION  427()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 659
Called 1 time
Total time:   0.000262
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000003   if !empty(self.saved_settings)
    1   0.000082   0.000017     let &virtualedit = self.saved_settings['virtualedit']
    1   0.000046   0.000012     let &cursorline = self.saved_settings['cursorline']
    1   0.000036   0.000006     let &lazyredraw = self.saved_settings['lazyredraw']
    1   0.000040   0.000011     let &paste = self.saved_settings['paste']
    1   0.000037   0.000009     let &clipboard = self.saved_settings['clipboard']
    1              0.000001   endif
                            
                              " Restore original contents and type of unnamed register. This method is
                              " called from reset, which calls us only when restore_setting argument is
                              " true, which happens only when we leave multicursor mode. This should be
                              " symmetrical to saving of unnamed register upon the start of multicursor
                              " mode.
    1              0.000012   call setreg('"', s:paste_buffer_temporary_text, s:paste_buffer_temporary_type)

FUNCTION  deoplete#util#get_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 27
Called 252 times
Total time:   0.016679
 Self time:   0.016679

count  total (s)   self (s)
  252              0.001203   let mode = mode()
  252              0.000640   if a:event ==# 'InsertEnter'
  217              0.000380     let mode = 'i'
  252              0.000213   endif
  252              0.011451   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
  252              0.000688   if a:event ==# 'InsertCharPre'
                                let input .= v:char
  252              0.000194   endif
                            
  252              0.000453   return input

FUNCTION  <SNR>109_modflag()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 174
Called 120 times
Total time:   0.006498
 Self time:   0.006498

count  total (s)   self (s)
  255              0.000902     for buf in tabpagebuflist(a:tabnr)
  142              0.001497         if getbufvar(buf, "&mod")
    7              0.000020             if a:tabnr == tabpagenr()
    7              0.000039                return "%#TabModifiedSelected#". g:taboo_modified_tab_flag. "%#TabLineSel#"
                                        else
                                           return "%#TabModified#". g:taboo_modified_tab_flag. "%#TabLine#"
                                        endif
  135              0.000132         endif
  248              0.000339     endfor
  113              0.000202     return ""

FUNCTION  <lambda>31()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#node#FindExecutable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/node.vim line 10
Called 104 times
Total time:   0.055977
 Self time:   0.007697

count  total (s)   self (s)
  104   0.003693   0.001461     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
  104              0.000100     endif
                            
  208              0.000651     for l:path in a:path_list
  208   0.049454   0.003406         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
  208              0.000555         if !empty(l:executable)
  104              0.000189             return l:executable
  104              0.000080         endif
  104              0.000132     endfor
                            
                                return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  deoplete#custom#_get_filetype_option()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 87
Called 388 times
Total time:   0.012623
 Self time:   0.012623

count  total (s)   self (s)
  388              0.002603   let buffer_option = s:cached.buffer_option
  388              0.001963   if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
  388              0.000408   endif
                            
  388              0.001567   let option = s:cached.option[a:name]
  388              0.002055   let filetype = has_key(option, a:filetype) ? a:filetype : '_'
  388              0.001771   return get(option, filetype, a:default)

FUNCTION  ale#util#GetLineCount()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 78
Called 5 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    5              0.000165     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  <lambda>77()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000033
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000032   0.000020 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>109_basename()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 222
Called 120 times
Total time:   0.004024
 Self time:   0.004024

count  total (s)   self (s)
  120              0.003943     return fnamemodify(a:bufname, ':p:t')

FUNCTION  221()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/flag_set.vim line 15
Called 1420 times
Total time:   0.006500
 Self time:   0.006500

count  total (s)   self (s)
 1420              0.006063     let self._flags[a:scope] = []

FUNCTION  223()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/flag_set.vim line 28
Called 1432 times
Total time:   0.011739
 Self time:   0.011739

count  total (s)   self (s)
 1432              0.006740     let newObj = copy(self)
 1432              0.002673     let newObj._flags = {}
 1432              0.001655     return newObj

FUNCTION  225()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/flag_set.vim line 45
Called 2276 times
Total time:   0.032166
 Self time:   0.032166

count  total (s)   self (s)
 2276              0.003619     let flagstring = ""
 4552              0.008813     for i in values(self._flags)
 2276              0.005460         let flagstring .= join(i)
 4552              0.002721     endfor
                            
 2276              0.003974     if len(flagstring) == 0
 2276              0.001829         return ""
                                endif
                            
                                return '[' . flagstring . ']'

FUNCTION  228()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 35
Called 3 times
Total time:   0.060535
 Self time:   0.001542

count  total (s)   self (s)
    3   0.000850   0.000054     if !s:NERDTree.IsOpen()
                                    return
    3              0.000006     endif
                            
    3              0.000027     if winnr("$") != 1
                                    " Use the window ID to identify the currently active window or fall
                                    " back on the buffer ID if win_getid/win_gotoid are not available, in
                                    " which case we'll focus an arbitrary window showing the buffer.
    3              0.000058         let l:useWinId = exists('*win_getid') && exists('*win_gotoid')
                            
    3   0.000811   0.000085         if winnr() == s:NERDTree.GetWinNum()
    2   0.005455   0.000068             call nerdtree#exec("wincmd p")
    2              0.000030             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr("")
    2   0.004987   0.000050             call nerdtree#exec("wincmd p")
    1              0.000001         else
    1              0.000006             let l:activeBufOrWin = l:useWinId ? win_getid() : bufnr("")
    3              0.000004         endif
                            
    3   0.002538   0.000113         call nerdtree#exec(s:NERDTree.GetWinNum() . " wincmd w")
    3   0.045065   0.000847         close
    3              0.000010         if l:useWinId
    3   0.000556   0.000051             call nerdtree#exec("call win_gotoid(" . l:activeBufOrWin . ")")
                                    else
                                        call nerdtree#exec(bufwinnr(l:activeBufOrWin) . " wincmd w")
    3              0.000003         endif
                                else
                                    close
    3              0.000003     endif

FUNCTION  229()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 68
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000009     if and(g:NERDTreeQuitOnOpen,1) && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
    1              0.000001     endif

FUNCTION  ale#highlight#BufferHidden()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 193
Called 4 times
Total time:   0.000410
 Self time:   0.000109

count  total (s)   self (s)
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
    4   0.000384   0.000083     call ale#highlight#RemoveHighlights()

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 205
Called 5 times
Total time:   0.001111
 Self time:   0.000164

count  total (s)   self (s)
    5              0.000058     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    5              0.000042     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    5   0.000995   0.000047     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>263_apply_highlight_fix()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1123
Called 8 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
                              " Only do this if we're on the last character of the line
    8              0.000053   if col('.') == col('$')
                                let s:saved_line = getline('.')
                                if s:from_mode ==# 'i'
                                  silent! undojoin | call setline('.', s:saved_line.' ')
                                else
                                  call setline('.', s:saved_line.' ')
                                endif
    8              0.000008   endif

FUNCTION  <SNR>263_handle_special_key()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1099
Called 4 times
Total time:   0.000885
 Self time:   0.000360

count  total (s)   self (s)
                              " Use feedkeys here instead of calling the function directly to prevent
                              " increasing the call stack, since feedkeys execute after the current call
                              " finishes
    4              0.000036   if a:key == g:multi_cursor_next_key
    4              0.000020     if s:use_word_boundary == 1
    4   0.000666   0.000140       call s:feedkeys("\<Plug>(multiple-cursors-new-word)")
                                else
                                  call s:feedkeys("\<Plug>(multiple-cursors-new)")
    4              0.000006     endif
                              elseif a:key == g:multi_cursor_prev_key
                                call s:feedkeys("\<Plug>(multiple-cursors-prev)")
                              elseif a:key == g:multi_cursor_skip_key
                                call s:feedkeys("\<Plug>(multiple-cursors-skip)")
    4              0.000006   endif

FUNCTION  ale#engine#SetResults()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 234
Called 5 times
Total time:   0.009988
 Self time:   0.000693

count  total (s)   self (s)
    5   0.000123   0.000049     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    5              0.000008     if g:ale_set_signs
    5   0.003500   0.000071         call ale#sign#SetSigns(a:buffer, a:loclist)
    5              0.000003     endif
                            
    5              0.000011     if g:ale_set_quickfix || g:ale_set_loclist
    5   0.000306   0.000062         call ale#list#SetLists(a:buffer, a:loclist)
    5              0.000003     endif
                            
    5              0.000017     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    5              0.000003     endif
                            
    5              0.000007     if g:ale_set_highlights
    5   0.001168   0.000057         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    5              0.000003     endif
                            
    5              0.000007     if l:linting_is_done
    5              0.000007         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    5   0.001515   0.000054             call ale#cursor#EchoCursorWarning()
    5              0.000003         endif
                            
    5              0.000008         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    5              0.000003         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    5              0.000020         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    5              0.000036         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    5   0.003056   0.000090         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    5   0.000087   0.000076         silent doautocmd <nomodeline> User ALELintPost
    5              0.000004     endif

FUNCTION  <SNR>25_show_displayname()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 212
Called 19 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   19              0.000056     if has_key(s:displaynames, toupper(a:inp))
                                    return s:displaynames[toupper(a:inp)]
   19              0.000010     else
   19              0.000017         return a:inp
                                end

FUNCTION  <SNR>152_build_command()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/async.vim line 40
Called 5 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    5              0.000021   if has('unix')
    5              0.000024     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>152_on_stderr_nvim()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/async.vim line 63
Called 6 times
Total time:   0.000258
 Self time:   0.000146

count  total (s)   self (s)
    6              0.000062   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
    1   0.000140   0.000028     call self.handler.err(self.buffer)
    6              0.000008   endif

FUNCTION  231()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 99
Called 3 times
Total time:   0.001651
 Self time:   0.000124

count  total (s)   self (s)
    3   0.000765   0.000030     call g:NERDTree.MustBeOpen()
    3   0.000883   0.000090     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  232()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 106
Called 23 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
   23              0.000216     return exists("b:NERDTree")

FUNCTION  233()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 112
Called 11 times
Total time:   0.001827
 Self time:   0.001827

count  total (s)   self (s)
   11              0.000113     if !exists("t:NERDTreeBufName")
    6              0.000015         return
    5              0.000015     end
                            
                                "check b:NERDTree is still there and hasn't been e.g. :bdeleted
    5              0.001628     return !empty(getbufvar(bufnr(t:NERDTreeBufName), 'NERDTree'))

FUNCTION  237()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 146
Called 25 times
Total time:   0.005880
 Self time:   0.005880

count  total (s)   self (s)
   25              0.000201     if exists("t:NERDTreeBufName")
   24              0.005604         return bufwinnr(t:NERDTreeBufName)
    1              0.000002     endif
                            
    1              0.000003     return -1

FUNCTION  238()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 155
Called 15 times
Total time:   0.003810
 Self time:   0.000316

count  total (s)   self (s)
   15   0.003774   0.000281     return s:NERDTree.GetWinNum() != -1

FUNCTION  <SNR>158_RunLinter()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 656
Called 52 times
Total time:   0.266231
 Self time:   0.003994

count  total (s)   self (s)
   52              0.000201     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
   52              0.000097     else
   52   0.035951   0.000975         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   52   0.229530   0.002268         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  <SNR>109_tabs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 214
Called 42 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
   42              0.000382     return range(1, tabpagenr('$'))

FUNCTION  gitgutter#diff#handler()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/diff.vim line 172
Called 4 times
Total time:   0.006450
 Self time:   0.000975

count  total (s)   self (s)
    4   0.000403   0.000080   call gitgutter#debug#log(a:diff)
                            
    4              0.000022   if !bufexists(a:bufnr)
                                return
    4              0.000005   endif
                            
    4   0.001047   0.000156   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    4   0.000444   0.000161   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    4              0.000040   let signs_count = len(modified_lines)
    4              0.000027   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    4              0.000008   else
    4              0.000023     if g:gitgutter_signs || g:gitgutter_highlight_lines
    4   0.003816   0.000133       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    4              0.000006     endif
    4              0.000004   endif
                            
    4   0.000383   0.000090   call s:save_last_seen_change(a:bufnr)
    4              0.000047   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    4              0.000004   endif

FUNCTION  <SNR>262_FilterResult()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 208
Called 2 times
Total time:   0.000085
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000057   0.000022     if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                    if a:obj.text =~# '^File ignored'
                                        return 0
                                    endif
    2              0.000001     endif
                            
    2              0.000009     if has_key(a:obj, 'code') && a:obj.code is# 'no-trailing-spaces'&& !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                    return 0
    2              0.000001     endif
                            
    2              0.000002     return 1

FUNCTION  syntastic#util#fname2buf()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 301
Called 17 times
Total time:   0.015993
 Self time:   0.015993

count  total (s)   self (s)
   17              0.000151     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
   17              0.000024     endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
   17              0.000068     let buf = -1
   29              0.000184     for md in [':~:.', ':~', ':p']
   25              0.000064         try
                                        " Older versions of Vim can throw E94 here
   25              0.010873             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
                                    catch
                                        " catch everything
   25              0.000051         endtry
   25              0.000089         if buf != -1
   13              0.000023             break
   12              0.000015         endif
   29              0.000109     endfor
   17              0.000049     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
    4              0.003441         let buf = bufnr(fnamemodify(a:fname, ':p'))
   17              0.000028     endif
                            
   17              0.000096     if exists('+shellslash')
                                    let &shellslash = old_shellslash
   17              0.000018     endif
                            
   17              0.000048     return buf

FUNCTION  <SNR>158_HandleExit()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/engine.vim line 186
Called 5 times
Total time:   0.016370
 Self time:   0.000580

count  total (s)   self (s)
    5              0.000029     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    5              0.000011     if empty(l:buffer_info)
                                    return
    5              0.000003     endif
                            
    5              0.000012     let l:linter = a:job_info.linter
    5              0.000013     let l:executable = a:job_info.executable
    5              0.000015     let l:next_chain_index = a:job_info.next_chain_index
                            
                                " Remove this job from the list.
    5   0.000115   0.000063     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    5   0.000366   0.000036     if ale#util#InSandbox()
                                    return
    5              0.000003     endif
                            
    5              0.000053     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    5              0.000003     endif
                            
    5              0.000025     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   l:executable,   l:linter,   l:next_chain_index,   a:output,)
                            
                                    call s:RunJob(l:command, l:options)
                            
                                    return
    5              0.000003     endif
                            
    5              0.000005     try
    5   0.003024   0.000097         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    5              0.000004     endtry
                            
    5   0.012557   0.000076     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>130_GetFunctionPrefix()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 250
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000018   let res = "function! ".a:name."(...)"
    3              0.000010   if has_key(a:opts, 'range')
                                let res = res." range"
    3              0.000003   endif
    3              0.000009   return res."\n"

FUNCTION  <SNR>181_check_prev_completion()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 129
Called 38 times
Total time:   0.000632
 Self time:   0.000632

count  total (s)   self (s)
   38              0.000198   let prev = g:deoplete#_prev_completion
   38              0.000322   if a:event ==# 'Async' || mode() !=# 'i' || empty(get(prev, 'candidates', [])) || s:check_input_method()
   38              0.000046     return
                              endif
                            
                              let input = deoplete#util#get_input(a:event)
                              let complete_str = matchstr(input, '\w\+$')
                              let min_pattern_length = deoplete#custom#_get_option('min_pattern_length')
                              if prev.linenr != line('.') || len(complete_str) < min_pattern_length
                                return
                              endif
                            
                              call deoplete#mapping#_set_completeopt()
                            
                              let mode = deoplete#custom#_get_option('prev_completion_mode')
                              let candidates = copy(prev.candidates)
                            
                              if mode ==# 'filter' || mode ==# 'length'
                                let input = input[prev.complete_position :]
                                let escaped_input = escape(input, '~\.^$[]*')
                                let pattern = substitute(escaped_input, '\w', '\\w*\0', 'g')
                                call filter(candidates, 'v:val.word =~? pattern')
                                if mode ==# 'length'
                                  call filter(candidates, 'len(v:val.word) > len(input)')
                                endif
                              elseif mode ==# 'mirror'
                                " pass
                              else
                                return
                              endif
                            
                              let g:deoplete#_filtered_prev = { 'complete_position': prev.complete_position, 'candidates': candidates, }
                              call deoplete#mapping#_prev_complete()

FUNCTION  240()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 165
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000007     return self._type == "window"

FUNCTION  241()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 170
Called 3 times
Total time:   0.000734
 Self time:   0.000071

count  total (s)   self (s)
    3   0.000695   0.000032     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
    3              0.000006     endif

FUNCTION  242()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 177
Called 2 times
Total time:   0.000717
 Self time:   0.000168

count  total (s)   self (s)
    2              0.000055     let newObj = copy(self)
    2   0.000237   0.000045     let newObj.ui = g:NERDTreeUI.New(newObj)
    2   0.000404   0.000047     let newObj.root = g:NERDTreeDirNode.New(a:path, newObj)
    2              0.000010     let newObj._type = a:type
    2              0.000005     return newObj

FUNCTION  243()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 186
Called 2957 times
Total time:   0.020357
 Self time:   0.020357

count  total (s)   self (s)
 2957              0.008868     if !exists('s:NERDTree._PathFilters')
    1              0.000009         let s:NERDTree._PathFilters = []
 2957              0.001647     endif
 2957              0.004141     return s:NERDTree._PathFilters

FUNCTION  246()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/nerdtree.vim line 204
Called 10 times
Total time:   0.597006
 Self time:   0.000144

count  total (s)   self (s)
   10   0.596997   0.000135     call self.ui.render()

FUNCTION  248()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 25
Called 10 times
Total time:   0.002527
 Self time:   0.002431

count  total (s)   self (s)
   10   0.000170   0.000121     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapPreview .": preview file\n"
                                    let help .= "\" ". g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
   10   0.000164   0.000117     elseif !self.isMinimal()
                                    let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
                                    silent! put =help
   10              0.000009     endif

FUNCTION  249()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 136
Called 2 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    2              0.000111     let newObj = copy(self)
    2              0.000013     let newObj.nerdtree = a:nerdtree
    2              0.000009     let newObj._showHelp = 0
    2              0.000008     let newObj._ignoreEnabled = 1
    2              0.000011     let newObj._showFiles = g:NERDTreeShowFiles
    2              0.000010     let newObj._showHidden = g:NERDTreeShowHidden
    2              0.000011     let newObj._showBookmarks = g:NERDTreeShowBookmarks
                            
    2              0.000007     return newObj

FUNCTION  <SNR>151_ActualIndents()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 280
Called 12 times
Total time:   0.132191
 Self time:   0.058126

count  total (s)   self (s)
   12              0.000057     let curr_line = a:line_start
   12              0.000037     let offset = curr_line
                            
                                " need to start with a line that has an indent
   12              0.000076     while curr_line > 1 && s:ConsiderLine(curr_line) == 0
                                    let curr_line -= 1
   12              0.000021     endwhile
   12              0.000044     let offset -= curr_line
                            
   12              0.000072     let ind_list = [indent(curr_line)]
  953              0.001659     while curr_line < a:line_end
  941              0.001700         let curr_line += 1
  941              0.002058         let prev_indent = ind_list[-1]
  941   0.056809   0.009769         let next_indent = indent(s:NextNonBlankLine(curr_line))
  941   0.034210   0.007184         if s:ConsiderLine(curr_line)
                                        " non-empty lines that define an indent
  915              0.003382             let ind_list += [indent(curr_line)]
   26              0.000268         elseif getline(curr_line) =~? '^\s*{\W*$'
                                        " line consisting of { brace: this increases indent level
                                        let ind_list += [min([ind_list[-1] + shiftwidth(), next_indent])]
   26              0.000225         elseif getline(curr_line) =~? '^\s*}\W*$'
                                        " line consisting of } brace: this has indent of line with matching {
    8              0.000087             let restore = winsaveview()
    8              0.000068             keepjumps exe curr_line
    8              0.004181             keepjumps normal! %
    8              0.000099             let br_open_pos = getpos('.')[1]
    8              0.000075             call winrestview(restore)
    8              0.000095             if br_open_pos < curr_line && br_open_pos >= a:line_start - offset
    8              0.000090                 let ind_list += [ind_list[offset + br_open_pos - a:line_start]]
                                        else
                                            " in case matching { does not exist or is out of range
                                            let ind_list += [max([prev_indent, next_indent])]
    8              0.000011             endif
   18              0.000024         else
   18              0.000181             let ind_list += [max([prev_indent, next_indent])]
  941              0.000544         endif
  953              0.000823     endwhile
   12              0.000136     return ind_list[offset : ]

FUNCTION  <lambda>101()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>103()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>105()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000028
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>107()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 94
Called 52 times
Total time:   0.010861
 Self time:   0.005470

count  total (s)   self (s)
   52              0.000165     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
   52              0.000036     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
   52              0.001577     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
   52              0.000301     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   52              0.001343     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   52   0.002342   0.000754     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   52   0.004538   0.000734     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   52              0.000116     return 1

FUNCTION  <SNR>264_on_timer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/echodoc.vim line 115
Called 46 times
Total time:   0.001849
 Self time:   0.001849

count  total (s)   self (s)
   46              0.000298   if !has('timers')
                                return s:on_event()
   46              0.000034   endif
                            
   46              0.000145   if exists('s:_timer')
   44              0.000238     call timer_stop(s:_timer)
   46              0.000033   endif
                            
   46              0.000782   let s:_timer = timer_start(100, {-> s:on_event(a:event)})

FUNCTION  <SNR>109_wincountUnicode()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 156
Called 240 times
Total time:   0.014129
 Self time:   0.014129

count  total (s)   self (s)
  240              0.001331     let buffers_number = tabpagewinnr(a:tabnr, '$')
  240              0.000629     let number_to_show = ""
                            
  240              0.001705     let small_numbers = ["", "", "", "", "", "", "", "", "", ""]
  240              0.001499     let number_str    = string(buffers_number)
                            
  480              0.002309     for i in range(0, len(number_str) - 1)
  240              0.002092         let number_to_show .= small_numbers[str2nr(number_str[i])]
  480              0.000734     endfor
                            
  240              0.000476     if a:ubiquitous
  120              0.000299         return number_to_show
  120              0.000117     endif
                            
  120              0.000561     return a:tabnr == tabpagenr() ? number_to_show : ''

FUNCTION  <SNR>165_matchaddpos()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/highlight.vim line 89
Called 2 times
Total time:   0.000187
 Self time:   0.000143

count  total (s)   self (s)
    2              0.000003     if s:has_nvim_highlight
    4              0.000007         for l:pos in a:pos_list
    2              0.000011             let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
    2              0.000007             if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
    2              0.000001             else
    2              0.000005                 let l:col_start = l:pos[1] - 1
    2              0.000007                 let l:col_end = l:col_start + get(l:pos, 2, 1)
    2              0.000001             endif
                            
    2   0.000083   0.000039             call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
    4              0.000004         endfor
                                else
                                    call matchaddpos(a:group, a:pos_list)
    2              0.000001     endif

FUNCTION  <SNR>120_get_bufline()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 54
Called 1422 times
Total time:   0.814061
 Self time:   0.135556

count  total (s)   self (s)
 1422   0.631373   0.022856   call wintabs#refresh_buflist(a:window)
 1422   0.050699   0.025635   let buffers = wintabs#getwinvar(a:window, 'wintabs_buflist', [])
 1422              0.016979   let bufnames = map(copy(buffers), "bufname(v:val)")
 1422              0.019991   let modified = map(copy(buffers), "getbufvar(v:val, '&modified')")
 1422   0.088142   0.043218   let bufline = wintabs#memoize#call(function('s:get_bufline_non_memoized'),a:window,buffers,bufnames,modified,winnr(),winbufnr(a:window),)
 1422              0.003110   return bufline

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/cursor.vim line 62
Called 277 times
Total time:   0.128530
 Self time:   0.037077

count  total (s)   self (s)
  277              0.005511     let l:buffer = bufnr('')
                            
  277              0.001805     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
  277              0.000559     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  277              0.002260     if mode(1) isnot# 'n'
   48              0.000054         return
  229              0.000268     endif
                            
  229   0.079761   0.005314     if ale#ShouldDoNothing(l:buffer)
   44              0.000123         return
  185              0.000191     endif
                            
  185   0.021851   0.004845     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
  185              0.000618     if g:ale_echo_cursor
  185              0.000882         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
  185              0.000945         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
  185              0.000264         endif
  185              0.000235     endif
                            
  185              0.000504     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
  185              0.000188     endif

FUNCTION  <SNR>263_highlight_region()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 852
Called 5 times
Total time:   0.000664
 Self time:   0.000594

count  total (s)   self (s)
    5   0.000213   0.000143   let s = sort(copy(a:region), "s:compare_pos")
    5              0.000023   if s:to_mode ==# 'V'
                                let pattern = '\%>'.(s[0][0]-1).'l\%<'.(s[1][0]+1).'l.*\ze.\_$'
    5              0.000009   else
    5              0.000030     if (s[0][0] == s[1][0])
                                  " Same line
    5              0.000083       let pattern = '\%'.s[0][0].'l\%>'.(s[0][1]-1).'c.*\%<'.(s[1][1]+1).'c.'
                                else
                                  " Two lines
                                  let s1 = '\%'.s[0][0].'l.\%>'.s[0][1].'c.*'
                                  let s2 = '\%'.s[1][0].'l.*\%<'.s[1][1].'c..'
                                  let pattern = s1.'\|'.s2
                                  " More than two lines
                                  if (s[1][0] - s[0][0] > 1)
                                    let pattern = pattern.'\|\%>'.s[0][0].'l\%<'.s[1][0].'l.*\ze.\_$'
                                  endif
    5              0.000007     endif
    5              0.000007   endif
    5              0.000094   return matchadd(s:hi_group_visual, pattern)

FUNCTION  <SNR>181_check_input_method()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/handler.vim line 265
Called 76 times
Total time:   0.000527
 Self time:   0.000527

count  total (s)   self (s)
   76              0.000480   return has('win32') && &iminsert

FUNCTION  deoplete#custom#_get()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 60
Called 49 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
   49              0.000207   if !exists('s:custom')
                                call deoplete#custom#_init()
   49              0.000034   endif
                            
   49              0.000062   return s:custom

FUNCTION  <lambda>79()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>61()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  cursorword#matchadd()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/cursorword.vim line 23
Called 383 times
Total time:   0.087094
 Self time:   0.087094

count  total (s)   self (s)
  383              0.010479   let enable = get(b:, 'cursorword', get(g:, 'cursorword', 1)) && !has('vim_starting')
  383              0.003643   if !enable && !get(w:, 'cursorword_match') | return | endif
  383              0.005153   let i = (a:0 ? a:1 : mode() ==# 'i' || mode() ==# 'R') && col('.') > 1
  383              0.002692   let line = getline('.')
  383              0.002042   let linenr = line('.')
  383              0.019709   let word = matchstr(line[:(col('.')-i-1)], '\k*$') . matchstr(line[(col('.')-i-1):], '^\k*')[1:]
  383              0.008042   if get(w:, 'cursorword_state', []) ==# [ linenr, word, enable ] | return | endif
  262              0.002622   let w:cursorword_state = [ linenr, word, enable ]
  262              0.007066   silent! call matchdelete(w:cursorword_id0)
  262              0.003340   silent! call matchdelete(w:cursorword_id1)
  262              0.001454   let w:cursorword_match = 0
  262              0.004816   if !enable || word ==# '' || len(word) !=# strchars(word) && word !~# s:alphabets || len(word) > 1000 | return | endif
  103              0.001289   let pattern = '\<' . escape(word, '~"\.^$[]*') . '\>'
  103              0.005967   let w:cursorword_id0 = matchadd('CursorWord0', pattern, -1)
  103              0.004847   let w:cursorword_id1 = matchadd('CursorWord' . &l:cursorline, '\%' . linenr . 'l' . pattern, -1)
  103              0.000467   let w:cursorword_match = 1

FUNCTION  251()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 205
Called 9 times
Total time:   0.014625
 Self time:   0.005298

count  total (s)   self (s)
                            
    9   0.004036   0.000072     if a:node.isRoot()
    2   0.000074   0.000019         return self.getRootLineNum()
    7              0.000006     endif
                            
    7   0.001102   0.000239     let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
    7              0.000028     let l:currentPathComponent = 1
                            
    7   0.000922   0.000094     let l:fullPath = a:node.path.str({'format': 'UI'})
                            
   58   0.000482   0.000314     for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
   58              0.000262         let l:currentLine = getline(l:lineNumber)
   58   0.002834   0.000587         let l:indentLevel = self._indentLevelFor(l:currentLine)
                            
   58              0.000199         if l:indentLevel != l:currentPathComponent
                                        continue
   58              0.000046         endif
                            
   58   0.001762   0.000561         let l:currentLine = self._stripMarkup(l:currentLine)
   58              0.000445         let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                            
                                    " Directories: If the current path "starts with" the full path, then
                                    " either the paths are equal or the line is a cascade containing the
                                    " full path.
   58              0.000405         if l:fullPath[-1:] == '/' && stridx(l:currentPath, l:fullPath) == 0
    6              0.000014             return l:lineNumber
   52              0.000043         endif
                            
                                    " Files: The paths must exactly match.
   52              0.000149         if l:fullPath ==# l:currentPath
    1              0.000001             return l:lineNumber
   51              0.000036         endif
                            
                                    " Otherwise: If the full path starts with the current path and the
                                    " current path is a directory, we add a new path component.
   51              0.000276         if stridx(l:fullPath, l:currentPath) == 0 && l:currentPath[-1:] == '/'
   13              0.000160             let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
   13              0.000083             call add(l:pathComponents, l:currentLine)
   13              0.000060             let l:currentPathComponent += 1
   51              0.000039         endif
   51              0.000066     endfor
                            
                                return -1

FUNCTION  252()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 253
Called 17 times
Total time:   0.000630
 Self time:   0.000630

count  total (s)   self (s)
   17              0.000071     let rootLine = 1
   17              0.000362     while getline(rootLine) !~# '^\(/\|<\)'
                                    let rootLine = rootLine + 1
   17              0.000045     endwhile
   17              0.000048     return rootLine

FUNCTION  253()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 262
Called 10 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
   10              0.000026     return self._showBookmarks

FUNCTION  254()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 267
Called 2957 times
Total time:   0.004908
 Self time:   0.004908

count  total (s)   self (s)
 2957              0.004015     return self._showFiles

FUNCTION  255()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 272
Called 10 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
   10              0.000033     return self._showHelp

FUNCTION  256()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 277
Called 2957 times
Total time:   0.005228
 Self time:   0.005228

count  total (s)   self (s)
 2957              0.004276     return self._showHidden

FUNCTION  257()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 282
Called 113 times
Total time:   0.006716
 Self time:   0.006285

count  total (s)   self (s)
                                " Replace multi-character DirArrows with a single space so the
                                " indentation calculation doesn't get messed up.
  113              0.002708     let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
  113              0.001695     let leadChars = match(l:line, '\M\[^ ]')
  113   0.001888   0.001457     return leadChars / s:UI.IndentWid()

FUNCTION  258()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 291
Called 113 times
Total time:   0.000431
 Self time:   0.000431

count  total (s)   self (s)
  113              0.000299     return 2

FUNCTION  259()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 296
Called 2957 times
Total time:   0.005792
 Self time:   0.005792

count  total (s)   self (s)
 2957              0.004698     return self._ignoreEnabled == 1

FUNCTION  <lambda>65()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000031
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>176_NeoVimCallback()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/job.vim line 29
Called 109 times
Total time:   0.030189
 Self time:   0.007596

count  total (s)   self (s)
  109              0.000738     let l:info = s:job_map[a:job]
                            
  109              0.000257     if a:event is# 'stdout'
   57   0.004690   0.001549         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
   52              0.000083     elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
   52              0.000038     else
   52              0.000200         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
   52              0.000033         endif
                            
   52              0.000153         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
   52              0.000028         endif
                            
   52              0.000045         try
   52   0.020319   0.000866             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
   52              0.000053         finally
                                        " Automatically forget about the job after it's done.
   52              0.000132             if has_key(s:job_map, a:job)
   52              0.000158                 call remove(s:job_map, a:job)
   52              0.000038             endif
   52              0.000045         endtry
  109              0.000068     endif

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 34
Called 52 times
Total time:   0.001588
 Self time:   0.000947

count  total (s)   self (s)
   52   0.001183   0.000543     call ale#command#InitData(a:buffer)
   52              0.000337     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  <lambda>97()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>113()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.003737
 Self time:   0.000029

count  total (s)   self (s)
    1   0.003736   0.000028 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>115()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.004093
 Self time:   0.000032

count  total (s)   self (s)
    1   0.004092   0.000031 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>117()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000071
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000069   0.000042 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>118()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.002956
 Self time:   0.000027

count  total (s)   self (s)
    1   0.002954   0.000026 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>111()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.004532
 Self time:   0.000028

count  total (s)   self (s)
    1   0.004531   0.000027 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>14()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 127
Called 1 time
Total time:   0.000067
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000066   0.000019 return gitgutter#utility#setbufvar(bufnr, 'path', s:strip_trailing_new_line(path))

FUNCTION  <lambda>17()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.002154
 Self time:   0.000024

count  total (s)   self (s)
    1   0.002154   0.000023 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>19()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000051
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000050   0.000031 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  413()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 401
Called 1 time
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000029   let obj = copy(self)
                              " List of Cursors we're managing
    1              0.000006   let obj.cursors = []
                              " Current index into the s:cursors array
    1              0.000004   let obj.current_index = -1
                              " This marks the starting cursor index into the s:cursors array
    1              0.000003   let obj.starting_index = -1
                              " We save some user settings when the plugin loads initially
    1              0.000025   let obj.saved_settings = { 'virtualedit': &virtualedit, 'cursorline': &cursorline, 'lazyredraw': &lazyredraw, 'paste': &paste, 'clipboard': &clipboard, }
                              " We save the window view when multicursor mode is entered
    1              0.000004   let obj.saved_winview = []
                              " Track whether we started multicursor mode from calling multiple_cursors#find
    1              0.000004   let obj.start_from_find = 0
    1              0.000004   return obj

FUNCTION  <SNR>152_on_stdout_nvim()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/async.vim line 53
Called 6 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
    6              0.000088   if empty(self.stdoutbuffer)
    5              0.000047     let self.stdoutbuffer = a:data
    1              0.000001   else
    1              0.000009     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    6              0.000009   endif

FUNCTION  ale#Set()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale.vim line 196
Called 19 times
Total time:   0.000434
 Self time:   0.000434

count  total (s)   self (s)
   19              0.000151     let l:full_name = 'ale_' . a:variable_name
                            
   19              0.000101     if !has_key(g:, l:full_name)
   18              0.000113         let g:[l:full_name] = a:default
   19              0.000023     endif

FUNCTION  ale#linter#Define()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 360
Called 6 times
Total time:   0.004292
 Self time:   0.000414

count  total (s)   self (s)
                                " This command will throw from the sandbox.
    6              0.000076     let &l:equalprg=&l:equalprg
                            
    6   0.004006   0.000128     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
    6              0.000033     if !has_key(s:linters, a:filetype)
    1              0.000004         let s:linters[a:filetype] = []
    6              0.000006     endif
                            
                                " Remove previously defined linters with the same name.
    6              0.000082     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
    6              0.000037     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  syntastic#util#unique()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 336
Called 8 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
    8              0.000030     let seen = {}
    8              0.000021     let uniques = []
   16              0.000042     for e in a:list
    8              0.000045         let k = string(e)
    8              0.000037         if !has_key(seen, k)
    7              0.000031             let seen[k] = 1
    7              0.000037             call add(uniques, e)
    8              0.000009         endif
   16              0.000022     endfor
    8              0.000018     return uniques

FUNCTION  <SNR>156_GetLinterNames()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 439
Called 81 times
Total time:   0.003077
 Self time:   0.003077

count  total (s)   self (s)
   81              0.000443     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   81              0.000192     if l:buffer_ale_linters is# 'all'
                                    return 'all'
   81              0.000064     endif
                            
                                " b:ale_linters can be set to a List.
   81              0.000264     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
   81              0.000052     endif
                            
                                " Try to get a buffer-local setting for the filetype
   81              0.000287     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
   81              0.000051     endif
                            
                                " Try to get a global setting for the filetype
   81              0.000467     if has_key(g:ale_linters, a:original_filetype)
   81              0.000358         return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  347()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/modemap.vim line 31
Called 2 times
Total time:   0.000404
 Self time:   0.000127

count  total (s)   self (s)
    2   0.000079   0.000034     let registry = g:SyntasticRegistry.Instance()
    2   0.000215   0.000032     let fts = registry.resolveFiletypes(a:filetype)
                            
    2   0.000033   0.000021     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
    2              0.000003     else
    2   0.000060   0.000024         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  <SNR>164_FixList()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/list.vim line 54
Called 5 times
Total time:   0.000442
 Self time:   0.000223

count  total (s)   self (s)
    5   0.000112   0.000039     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    5              0.000010     let l:new_list = []
                            
    7              0.000015     for l:item in a:list
    2              0.000011         let l:fixed_item = copy(l:item)
                            
    2   0.000173   0.000027         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
    2              0.000004         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
    2              0.000001         endif
                            
    2              0.000008         call add(l:new_list, l:fixed_item)
    7              0.000009     endfor
                            
    5              0.000008     return l:new_list

FUNCTION  <SNR>151_CommentLine()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 160
Called 1040 times
Total time:   0.044229
 Self time:   0.044229

count  total (s)   self (s)
 1040              0.005416     if getline(a:lnum) !~? '\v\S'
                                    " empty line
   16              0.000032         return 0
 1024              0.000625     endif
                            
 1024              0.001757     if g:anyfold_identify_comments == 0
                                    return 0
 1024              0.000561     endif
                            
 1024              0.001626     if g:anyfold_identify_comments >= 1
                                    " using foldignore option to detect comments
                                    " note: this may not work for multiline comments
 2048              0.007489         for char in split(&foldignore, '\zs')
 1024              0.004052             if char ==? getline(a:lnum)[indent(a:lnum)]
                                            return 1
 1024              0.000657             endif
 2048              0.001625         endfor
 1024              0.000643     endif
                            
 1024              0.001645     if g:anyfold_identify_comments >= 2
                                    " synID is very slow, therefore we only call this if user wants highest
                                    " accuracy for comment identification
                                    return synIDattr(synID(a:lnum,indent(a:lnum)+1,1),"name") =~? s:comments_string
 1024              0.000618     endif
                            
 1024              0.000980     return 0
                            

FUNCTION  deoplete#custom#_get_source_vars()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/custom.vim line 98
Called 154 times
Total time:   0.001443
 Self time:   0.001443

count  total (s)   self (s)
  154              0.001271   return get(s:cached.source_vars, a:name, {})

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 54
Called 23 times
Total time:   0.008798
 Self time:   0.001730

count  total (s)   self (s)
   23   0.008765   0.001697   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  260()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 301
Called 30 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
   30              0.000085     return g:NERDTreeMinimalUI

FUNCTION  263()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 337
Called 1 time
Total time:   0.000291
 Self time:   0.000154

count  total (s)   self (s)
    1              0.000008     if !has_key(self, '_screenState')
                                    return
    1              0.000001     endif
    1              0.000019     exec("silent vertical resize " . self._screenState['oldWindowSize'])
                            
    1              0.000007     let old_scrolloff=&scrolloff
    1   0.000077   0.000012     let &scrolloff=0
    1              0.000011     call cursor(self._screenState['oldTopLine'], 0)
    1              0.000062     normal! zt
    1              0.000014     call setpos(".", self._screenState['oldPos'])
    1   0.000085   0.000013     let &scrolloff=old_scrolloff

FUNCTION  264()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 354
Called 3 times
Total time:   0.002035
 Self time:   0.000254

count  total (s)   self (s)
    3              0.000020     let win = winnr()
    3   0.001684   0.000033     call g:NERDTree.CursorToTreeWin()
    3              0.000047     let self._screenState = {}
    3              0.000034     let self._screenState['oldPos'] = getpos(".")
    3              0.000032     let self._screenState['oldTopLine'] = line("w0")
    3              0.000021     let self._screenState['oldWindowSize']= winwidth("")
    3   0.000187   0.000058     call nerdtree#exec(win . "wincmd w")

FUNCTION  266()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 374
Called 125 times
Total time:   0.004096
 Self time:   0.004096

count  total (s)   self (s)
  125              0.002495     let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
  125              0.001438     return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')

FUNCTION  267()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 380
Called 10 times
Total time:   0.596862
 Self time:   0.005097

count  total (s)   self (s)
   10   0.001649   0.000290     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
   10              0.000056     let curLine = line(".")
   10              0.000042     let curCol = col(".")
   10              0.000036     let topLine = line("w0")
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
   10              0.000912     silent 1,$delete _
                            
   10   0.002671   0.000144     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
   10   0.000100   0.000071     if !self.isMinimal()
                                    call setline(line(".")+1, "")
                                    call cursor(line(".")+1, col("."))
   10              0.000008     endif
                            
   10   0.000101   0.000069     if self.getShowBookmarks()
                                    call self._renderBookmarks()
   10              0.000009     endif
                            
                                " add the 'up a dir' line
   10   0.000088   0.000062     if !self.isMinimal()
                                    call setline(line(".")+1, s:UI.UpDirLine())
                                    call cursor(line(".")+1, col("."))
   10              0.000008     endif
                            
                                " draw the header line
   10   0.002610   0.000201     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
   10              0.000249     call setline(line(".")+1, header)
   10              0.000073     call cursor(line(".")+1, col("."))
                            
                                " draw the tree
   10   0.584656   0.001303     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
   10              0.000202     silent 1,1delete _
                            
                                " restore the view
   10              0.000063     let old_scrolloff=&scrolloff
   10   0.000805   0.000146     let &scrolloff=0
   10              0.000056     call cursor(topLine, 1)
   10              0.000446     normal! zt
   10              0.000054     call cursor(curLine, curCol)
   10   0.000630   0.000091     let &scrolloff = old_scrolloff
                            
   10   0.000954   0.000121     setlocal readonly nomodifiable

FUNCTION  <SNR>163_GroupCmd()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 161
Called 15 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
   15              0.000032     if s:supports_sign_groups
   15              0.000021         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <lambda>21()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000034
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000033   0.000021 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>23()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000032
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000031   0.000019 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>25()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000031
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000030   0.000019 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>29()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>262_CheckForBadConfig()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/handlers/eslint.vim line 72
Called 5 times
Total time:   0.001596
 Self time:   0.001596

count  total (s)   self (s)
    5              0.000038     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
   10              0.000032     for l:line in a:lines[:10]
    5              0.001354         let l:match = matchlist(l:line, l:config_error_pattern)
                            
    5              0.000018         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
    5              0.000006         endif
   10              0.000013     endfor
                            
    5              0.000006     return 0

FUNCTION  ale#linter#PreProcess()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 83
Called 6 times
Total time:   0.003878
 Self time:   0.003721

count  total (s)   self (s)
    6              0.000041     if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
    6              0.000008     endif
                            
    6              0.000065     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                            
    6              0.000030     if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
    6              0.000005     endif
                            
    6              0.000029     let l:needs_address = l:obj.lsp is# 'socket'
    6              0.000023     let l:needs_executable = l:obj.lsp isnot# 'socket'
    6              0.000020     let l:needs_command = l:obj.lsp isnot# 'socket'
    6              0.000031     let l:needs_lsp_details = !empty(l:obj.lsp)
                            
    6              0.000016     if empty(l:obj.lsp)
    5              0.000029         let l:obj.callback = get(a:linter, 'callback')
                            
    5   0.000128   0.000074         if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
    5              0.000005         endif
    6              0.000005     endif
                            
    6              0.000052     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
    6              0.000005     endif
                            
    6              0.000013     if !l:needs_executable
                                    if has_key(a:linter, 'executable')|| has_key(a:linter, 'executable_callback')
                                        throw '`executable` and `executable_callback` cannot be used when lsp == ''socket'''
                                    endif
    6              0.000027     elseif has_key(a:linter, 'executable_callback')
                                    let l:obj.executable_callback = a:linter.executable_callback
                            
                                    if !s:IsCallback(l:obj.executable_callback)
                                        throw '`executable_callback` must be a callback if defined'
                                    endif
    6              0.000022     elseif has_key(a:linter, 'executable')
    6              0.000031         let l:obj.executable = a:linter.executable
                            
    6              0.000046         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
    6              0.000005         endif
                                else
                                    throw 'Either `executable` or `executable_callback` must be defined'
    6              0.000005     endif
                            
    6              0.000014     if !l:needs_command
                                    if has_key(a:linter, 'command')|| has_key(a:linter, 'command_callback')|| has_key(a:linter, 'command_chain')
                                        throw '`command` and `command_callback` and `command_chain` cannot be used when lsp == ''socket'''
                                    endif
    6              0.000022     elseif has_key(a:linter, 'command_chain')
                                    let l:obj.command_chain = a:linter.command_chain
                            
                                    if type(l:obj.command_chain) isnot v:t_list
                                        throw '`command_chain` must be a List'
                                    endif
                            
                                    if empty(l:obj.command_chain)
                                        throw '`command_chain` must contain at least one item'
                                    endif
                            
                                    let l:link_index = 0
                            
                                    for l:link in l:obj.command_chain
                                        let l:err_prefix = 'The `command_chain` item ' . l:link_index . ' '
                            
                                        if !s:IsCallback(get(l:link, 'callback'))
                                            throw l:err_prefix . 'must define a `callback` function'
                                        endif
                            
                                        if has_key(l:link, 'output_stream')
                                            if type(l:link.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:link.output_stream) < 0
                                                throw l:err_prefix . '`output_stream` flag must be '   . "'stdout', 'stderr', or 'both'"
                                            endif
                                        endif
                            
                                        if has_key(l:link, 'read_buffer') && !s:IsBoolean(l:link.read_buffer)
                                            throw l:err_prefix . 'value for `read_buffer` must be `0` or `1`'
                                        endif
                            
                                        let l:link_index += 1
                                    endfor
    6              0.000026     elseif has_key(a:linter, 'command_callback')
                                    let l:obj.command_callback = a:linter.command_callback
                            
                                    if !s:IsCallback(l:obj.command_callback)
                                        throw '`command_callback` must be a callback if defined'
                                    endif
    6              0.000021     elseif has_key(a:linter, 'command')
    6              0.000027         let l:obj.command = a:linter.command
                            
    6              0.000041         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
    6              0.000005         endif
                                else
                                    throw 'Either `command`, `executable_callback`, `command_chain` '   . 'must be defined'
    6              0.000005     endif
                            
    6              0.000055     if (   has_key(a:linter, 'command')   + has_key(a:linter, 'command_chain')   + has_key(a:linter, 'command_callback')) > 1
                                    throw 'Only one of `command`, `command_callback`, or `command_chain` '   . 'should be set'
    6              0.000005     endif
                            
    6              0.000012     if !l:needs_address
    6              0.000033         if has_key(a:linter, 'address') || has_key(a:linter, 'address_callback')
                                        throw '`address` or `address_callback` cannot be used when lsp != ''socket'''
    6              0.000005         endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                                elseif has_key(a:linter, 'address_callback')
                                    let l:obj.address_callback = a:linter.address_callback
                            
                                    if !s:IsCallback(l:obj.address_callback)
                                        throw '`address_callback` must be a callback if defined'
                                    endif
                                else
                                    throw '`address` or `address_callback` must be defined for getting the LSP address'
    6              0.000005     endif
                            
    6              0.000013     if l:needs_lsp_details
    1              0.000004         if has_key(a:linter, 'language_callback')
                                        if has_key(a:linter, 'language')
                                            throw 'Only one of `language` or `language_callback` '   . 'should be set'
                                        endif
                            
                                        let l:obj.language_callback = get(a:linter, 'language_callback')
                            
                                        if !s:IsCallback(l:obj.language_callback)
                                            throw '`language_callback` must be a callback for LSP linters'
                                        endif
    1              0.000001         else
                                        " Default to using the filetype as the language.
    1              0.000007             let l:Language = get(a:linter, 'language', a:filetype)
                            
    1              0.000004             if type(l:Language) is v:t_string
                                            " Make 'language_callback' return the 'language' value.
    1              0.000004                 let l:obj.language = l:Language
    1              0.000011                 let l:obj.language_callback = function('s:LanguageGetter')
                                        elseif type(l:Language) is v:t_func
                                            let l:obj.language_callback = l:Language
                                        else
                                            throw '`language` must be a String or Funcref'
    1              0.000001             endif
    1              0.000001         endif
                            
    1              0.000004         if has_key(a:linter, 'project_root')
    1              0.000006             let l:obj.project_root = a:linter.project_root
                            
    1              0.000008             if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function if defined'
    1              0.000001             endif
                                    elseif has_key(a:linter, 'project_root_callback')
                                        let l:obj.project_root_callback = a:linter.project_root_callback
                            
                                        if !s:IsCallback(l:obj.project_root_callback)
                                            throw '`project_root_callback` must be a callback if defined'
                                        endif
                                    else
                                        throw '`project_root` or `project_root_callback` must be defined for LSP linters'
    1              0.000001         endif
                            
    1              0.000004         if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
    1              0.000001         endif
                            
    1              0.000004         if has_key(a:linter, 'initialization_options_callback')
                                        if has_key(a:linter, 'initialization_options')
                                            throw 'Only one of `initialization_options` or '   . '`initialization_options_callback` should be set'
                                        endif
                            
                                        let l:obj.initialization_options_callback = a:linter.initialization_options_callback
                            
                                        if !s:IsCallback(l:obj.initialization_options_callback)
                                            throw '`initialization_options_callback` must be a callback if defined'
                                        endif
    1              0.000004         elseif has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a String or Function if defined'
                                        endif
    1              0.000001         endif
                            
    1              0.000004         if has_key(a:linter, 'lsp_config_callback')
                                        if has_key(a:linter, 'lsp_config')
                                            throw 'Only one of `lsp_config` or `lsp_config_callback` should be set'
                                        endif
                            
                                        let l:obj.lsp_config_callback = a:linter.lsp_config_callback
                            
                                        if !s:IsCallback(l:obj.lsp_config_callback)
                                            throw '`lsp_config_callback` must be a callback if defined'
                                        endif
    1              0.000004         elseif has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
    1              0.000001         endif
    6              0.000006     endif
                            
    6              0.000045     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
    6              0.000071     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
    6              0.000006     endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
    6              0.000036     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
    6   0.000158   0.000103     if !s:IsBoolean(l:obj.lint_file)
                                    throw '`lint_file` must be `0` or `1`'
    6              0.000006     endif
                            
                                " An option indicating that the buffer should be read.
    6              0.000041     let l:obj.read_buffer = get(a:linter, 'read_buffer', !l:obj.lint_file)
                            
    6   0.000135   0.000088     if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
    6              0.000006     endif
                            
    6              0.000019     if l:obj.lint_file && l:obj.read_buffer
                                    throw 'Only one of `lint_file` or `read_buffer` can be `1`'
    6              0.000005     endif
                            
    6              0.000037     let l:obj.aliases = get(a:linter, 'aliases', [])
                            
    6              0.000074     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
    6              0.000005     endif
                            
    6              0.000169     for l:key in filter(keys(a:linter), 'v:val[-9:] is# ''_callback'' || v:val is# ''command_chain''')
                                    if !get(g:, 'ale_ignore_2_4_warnings')
                                        execute 'echom l:key . '' is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
                                    endif
                            
                                    break
    6              0.000009     endfor
                            
    6              0.000015     return l:obj

FUNCTION  syntastic#util#setLastTick()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 406
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000019     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  ale#history#Add()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/history.vim line 12
Called 53 times
Total time:   0.004969
 Self time:   0.004969

count  total (s)   self (s)
   53              0.000328     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
   53              0.000040     endif
                            
   53              0.000439     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   53              0.000239     if len(l:history) >= g:ale_max_buffer_history_size
   33              0.001514         let l:history = l:history[1:]
   53              0.000041     endif
                            
   53              0.000533     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   53              0.001077     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  ale#util#JoinNeovimOutput()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 54
Called 57 times
Total time:   0.002411
 Self time:   0.002359

count  total (s)   self (s)
   57              0.000121     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
   57              0.000036     endif
                            
   57              0.000238     let l:lines = a:data[:-2]
                            
   57              0.000151     if len(a:data) > 1
    5              0.000035         let l:lines[0] = a:last_line . l:lines[0]
    5              0.000015         let l:new_last_line = a:data[-1]
   52              0.000046     else
   52              0.000262         let l:new_last_line = a:last_line . get(a:data, 0, '')
   57              0.000040     endif
                            
   62              0.000177     for l:line in l:lines
    5   0.000136   0.000085         call a:callback(a:job, l:line)
   62              0.000071     endfor
                            
   57              0.000116     return l:new_last_line

FUNCTION  418()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 485
Called 23 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
   23              0.000073   return self.cursors[a:i]

FUNCTION  275()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/ui.vim line 516
Called 8 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    8              0.000050     return '.. (up a dir)'

FUNCTION  276()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/event.vim line 6
Called 1420 times
Total time:   0.017367
 Self time:   0.017367

count  total (s)   self (s)
 1420              0.004405     let newObj = copy(self)
 1420              0.002971     let newObj.nerdtree = a:nerdtree
 1420              0.002555     let newObj.subject = a:subject
 1420              0.002296     let newObj.action = a:action
 1420              0.002238     let newObj.params = a:params
 1420              0.001599     return newObj

FUNCTION  278()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/notifier.vim line 14
Called 1420 times
Total time:   2.815219
 Self time:   0.045387

count  total (s)   self (s)
 1420   0.028109   0.010741     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
 2840   0.033428   0.011153     for listener in s:Notifier.GetListenersForEvent(a:event)
 1420   2.745770   0.015580         call {listener}(event)
 2840              0.002802     endfor

FUNCTION  279()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/notifier.vim line 22
Called 1420 times
Total time:   0.009674
 Self time:   0.009674

count  total (s)   self (s)
 1420              0.004541     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
 1420              0.000766     endif
 1420              0.001820     return s:refreshListenersMap

FUNCTION  <lambda>33()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000037
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000036   0.000023 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>35()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>37()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000033
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000033   0.000022 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>39()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>14_SelectJavascript()
    Defined: ~/config/nvim/.cache/init.vim/.dein/ftdetect/ftdetect.vim line 642
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000048   if getline(1) =~# '^#!.*/bin/\%(env\s\+\)\?node\>'
                                set ft=javascript
    3              0.000004   endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/linter.vim line 523
Called 52 times
Total time:   0.034976
 Self time:   0.002385

count  total (s)   self (s)
   52              0.000742     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
   52   0.034160   0.001569     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>120_truncate_line()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/ui.vim line 143
Called 1422 times
Total time:   0.167374
 Self time:   0.067579

count  total (s)   self (s)
 1422   0.152124   0.052329   let [elements, line_start] = wintabs#memoize#call(function('s:truncate_line_non_memoized'),a:window,a:bufline,a:width,wintabs#getwinvar(a:window, 'wintabs_bufline_start', 0))
 1422              0.010026   call setwinvar(a:window, 'wintabs_bufline_start', line_start)
 1422              0.002879   return elements

FUNCTION  provider#pythonx#Require()
    Defined: /usr/share/nvim/runtime/autoload/provider/pythonx.vim line 8
Called 1 time
Total time:   0.137243
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000005   let ver = (a:host.orig_name ==# 'python') ? 2 : 3
                            
                              " Python host arguments
    1   0.000016   0.000013   let prog = (ver == '2' ?  provider#python#Prog() : provider#python3#Prog())
    1              0.000004   let args = [prog, '-c', 'import sys; sys.path.remove(""); import neovim; neovim.start_host()']
                            
                              " Collect registered Python plugins into args
    1   0.000027   0.000011   let python_plugins = remote#host#PluginsForHost(a:host.name)
    2              0.000007   for plugin in python_plugins
    1              0.000005     call add(args, plugin.path)
    2              0.000003   endfor
                            
    1   0.137168   0.000026   return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE')

FUNCTION  <SNR>109_refresh_tabline()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 243
Called 2 times
Total time:   0.000837
 Self time:   0.000571

count  total (s)   self (s)
    2   0.000188   0.000087     cal s:settabvar(tabpagenr(), "taboo_tab_wd", getcwd())
    2              0.000013     if exists("g:SessionLoad")
                                    return
    2              0.000003     endif
    2              0.000016     let g:Taboo_tabs = ""
    8   0.000078   0.000053     for i in s:tabs()
    6   0.000185   0.000107         if !empty(s:gettabvar(i, "taboo_tab_name"))
    6   0.000200   0.000137             let g:Taboo_tabs .= i."\t".s:gettabvar(i, "taboo_tab_name")."\n"
    6              0.000008         endif
    8              0.000015     endfor
    2              0.000085     exe "set stal=" . &showtabline

FUNCTION  deoplete#init#_channel_initialized()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/init.vim line 88
Called 86 times
Total time:   0.000725
 Self time:   0.000725

count  total (s)   self (s)
   86              0.000476   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  <SNR>18_after_ftplugin()
    Defined: ~/config/nvim/.cache/init.vim/.dein/ftplugin.vim line 30
Called 7 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)

FUNCTION  <SNR>25_format_displaystring()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 152
Called 16 times
Total time:   0.002122
 Self time:   0.001553

count  total (s)   self (s)
   16              0.000513     let g:leaderGuide#displayname = a:map
   32              0.000114     for Fun in g:leaderGuide_displayfunc
   16   0.000735   0.000166         call Fun()
   32              0.000037     endfor
   16              0.000041     let display = g:leaderGuide#displayname
   16              0.000574     unlet g:leaderGuide#displayname
   16              0.000039     return display

FUNCTION  <SNR>109_wincount()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/taboo.vim line 147
Called 240 times
Total time:   0.003129
 Self time:   0.003129

count  total (s)   self (s)
  240              0.001280     let windows = tabpagewinnr(a:tabnr, '$')
  240              0.000450     if a:ubiquitous
  120              0.000232         return windows
  120              0.000120     endif
  120              0.000597     return a:tabnr == tabpagenr() ? windows : ''

FUNCTION  280()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/notifier.vim line 29
Called 1420 times
Total time:   0.022275
 Self time:   0.012601

count  total (s)   self (s)
 1420   0.017248   0.007575     let listenersMap = s:Notifier.GetListenersMap()
 1420              0.004461     return get(listenersMap, a:name, [])

FUNCTION  282()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/autoloclist.vim line 15
Called 7 times
Total time:   0.001466
 Self time:   0.000182

count  total (s)   self (s)
    7   0.000263   0.000098     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    7   0.001195   0.000075     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  285()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/balloons.vim line 19
Called 7 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    7              0.000078     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  287()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/balloons.vim line 36
Called 2 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000029     if has('balloon_eval') && !empty(get(b:, 'syntastic_private_balloons', {}))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    set noballooneval
    2              0.000002     endif
    2              0.000007     unlet! b:syntastic_private_balloons

FUNCTION  289()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 60
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008     return self._filetype

FUNCTION  <SNR>263_exit()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1074
Called 8 times
Total time:   0.000917
 Self time:   0.000128

count  total (s)   self (s)
    8              0.000051   if s:char !=# g:multi_cursor_quit_key
    7              0.000023     return 0
    1              0.000001   endif
    1              0.000002   let exit = 0
    1              0.000002   if s:from_mode ==# 'n'
                                let exit = 1
    1              0.000004   elseif (s:from_mode ==# 'v' || s:from_mode ==# 'V') && g:multi_cursor_exit_from_visual_mode
                                let exit = 1
    1              0.000003   elseif s:from_mode ==# 'i' && g:multi_cursor_exit_from_insert_mode
    1              0.000003     stopinsert
    1              0.000001     let exit = 1
    1              0.000001   endif
    1              0.000001   if exit
    1   0.000802   0.000013     call s:cm.reset(1, 1, 1)
    1              0.000002     return 1
                              endif
                              return 0

FUNCTION  <SNR>263_get_char()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1063
Called 7 times
Total time:   0.075073
 Self time:   0.029601

count  total (s)   self (s)
    7   0.074798   0.029326   let c = (a:0 == 0) ? getchar() : getchar(a:1)
                              " If the character is a number, then it's not a special key
    7              0.000110   if type(c) == 0
    7              0.000055     let c = nr2char(c)
    7              0.000021   endif
    7              0.000033   return c

FUNCTION  ale#util#Tempname()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/util.vim line 295
Called 52 times
Total time:   0.001824
 Self time:   0.001824

count  total (s)   self (s)
   52              0.000160     let l:clear_tempdir = 0
                            
   52              0.000499     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
   52              0.000036     endif
                            
   52              0.000069     try
   52              0.000245         let l:name = tempname() " no-custom-checks
   52              0.000102     finally
   52              0.000093         if l:clear_tempdir
                                        let $TMPDIR = ''
   52              0.000041         endif
   52              0.000073     endtry
                            
   52              0.000093     return l:name

FUNCTION  56()
    Defined: ~/config/nvim/.cache/init.vim/.dein/lib/nerdtree/path.vim line 801
Called 24 times
Total time:   0.005112
 Self time:   0.001894

count  total (s)   self (s)
   24   0.001179   0.000249     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
   24   0.000585   0.000277     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
   24              0.000021     endif
                            
   24   0.001258   0.000402     let toReturn = lead . join(self.pathSegments, s:Path.Slash())
                            
   24   0.000631   0.000289     if !nerdtree#runningWindows()
   24   0.001164   0.000382         let toReturn = escape(toReturn, self._escChars())
   24              0.000028     endif
   24              0.000057     return toReturn

FUNCTION  syntastic#util#rawVar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/syntastic/util.vim line 160
Called 63 times
Total time:   0.000670
 Self time:   0.000670

count  total (s)   self (s)
   63              0.000627     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>151_IsComment()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 193
Called 3060 times
Total time:   0.023383
 Self time:   0.023383

count  total (s)   self (s)
 3060              0.005289     if g:anyfold_identify_comments
 3060              0.008270         if a:lnum <= line('$') && a:lnum > 0
 3060              0.007577             return b:anyfold_commentlines[a:lnum-1]
                                    else
                                        return 0
                                    endif
                                else
                                    return 0
                                endif

FUNCTION  <lambda>43()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>107_CacheErrors()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 451
Called 2 times
Total time:   0.009434
 Self time:   0.001215

count  total (s)   self (s)
    2   0.000085   0.000039     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    2   0.001725   0.000055     call s:ClearCache(a:buf)
    2   0.000155   0.000033     let newLoclist = g:SyntasticLoclist.New([])
    2   0.000044   0.000019     call newLoclist.setOwner(a:buf)
                            
    2   0.000349   0.000027     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    2   0.000079   0.000037         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    2   0.000066   0.000034         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
    2              0.000003         else
    2   0.000073   0.000035             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    2   0.000069   0.000034             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    2              0.000002         endif
    2   0.000086   0.000051         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    2   0.000080   0.000039         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    2   0.004395   0.000046         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    2   0.000111   0.000051         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    2   0.000085   0.000028         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    2   0.000071   0.000027         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    2              0.000005         let names = []
    2              0.000007         let unavailable_checkers = 0
    4              0.000014         for checker in clist
    2   0.000127   0.000105             let cname = checker.getCName()
    2   0.000747   0.000030             if !checker.isAvailable()
    2   0.000121   0.000054                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
    2              0.000014                 let unavailable_checkers += 1
    2              0.000005                 continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    2              0.000005         endfor
                            
                                    " set names {{{3
    2              0.000007         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    2              0.000002         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    2              0.000010         if len(clist) == unavailable_checkers
    2              0.000007             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
    2              0.000002             else
    2   0.000074   0.000033                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
    2              0.000002             endif
    2              0.000002         endif
                                    " }}}3
                            
    2   0.000063   0.000027         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    2              0.000005         if sort_aggregated_errors
    2   0.000070   0.000016             call newLoclist.sort()
    2   0.000067   0.000026             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
    2              0.000002         endif
    2              0.000002     endif
                            
    2   0.000338   0.000015     call newLoclist.deploy()

FUNCTION  <SNR>25_handle_input()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 356
Called 1 time
Total time:   0.689608
 Self time:   0.020247

count  total (s)   self (s)
    1   0.000839   0.000023     call s:winclose()
    1              0.000012     if type(a:input) ==? type({})
                                    let s:current_level += 1
                                    let s:lmap = a:input
                                    call s:start_buffer()
    1              0.000002     else
    1              0.000013         call feedkeys(s:vis.s:reg.s:count, 'ti')
    1              0.000009         if type(a:input) !=? type([])
                                        let last = strpart(s:last_inp[-1], strchars(s:last_inp[-1]) - 1)
                                        if s:last_inp[0] !=? last
                                            execute s:escape_mappings({'rhs': join(s:last_inp, ""), 'noremap': 0})
                                        endif
                                        return
    1              0.000002         endif
    1              0.019942         redraw
    1              0.000004         try
    1   0.668730   0.000185             unsilent execute a:input[0]
                                    catch
                                        unsilent echom v:exception
    1              0.000003         endtry
    1              0.000001     endif

FUNCTION  <SNR>263_revert_mode()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 875
Called 15 times
Total time:   0.001309
 Self time:   0.000364

count  total (s)   self (s)
   15              0.000053   if a:to ==# 'v'
    5   0.001002   0.000056     call s:cm.reapply_visual_selection()
   10              0.000020   elseif a:to ==# 'V'
                                call s:cm.reapply_visual_selection()
                                normal! V
   10              0.000021   elseif a:to ==# 'n' && a:from ==# 'i'
                                stopinsert
   15              0.000013   endif

FUNCTION  <lambda>47()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000049
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000048   0.000028 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#sign#ReadSigns()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 170
Called 5 times
Total time:   0.000320
 Self time:   0.000250

count  total (s)   self (s)
    5              0.000032     redir => l:output
    5   0.000228   0.000158         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
    5              0.000018     redir end
                            
    5              0.000035     return split(l:output, "\n")

FUNCTION  <lambda>49()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000034
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000033   0.000021 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>263_fire_pre_triggers()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 104
Called 5 times
Total time:   0.000212
 Self time:   0.000202

count  total (s)   self (s)
    5              0.000036   if !s:before_function_called
    1   0.000050   0.000040     silent doautocmd User MultipleCursorsPre
    1              0.000013     if exists('*Multiple_cursors_before')
                                  exe "call Multiple_cursors_before()"
    1              0.000002     endif
    1              0.000006     let s:before_function_called = 1
    5              0.000006   endif

FUNCTION  <SNR>79_filename()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 203
Called 2 times
Total time:   0.000234
 Self time:   0.000033

count  total (s)   self (s)
    2   0.000231   0.000030   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/nerdtree/ui_glue.vim line 356
Called 8 times
Total time:   7.159345
 Self time:   0.000398

count  total (s)   self (s)
    8   7.159297   0.000350     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  wintabs#element#len()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs/element.vim line 2
Called 1818 times
Total time:   0.081896
 Self time:   0.032033

count  total (s)   self (s)
 1818   0.076308   0.033346   return wintabs#memoize#call(function('s:len'), a:var)

FUNCTION  <SNR>79_is_file_buffer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 67
Called 23 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
   23              0.000258   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  deoplete#util#has_yarp()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/deoplete/util.vim line 134
Called 86 times
Total time:   0.002475
 Self time:   0.001784

count  total (s)   self (s)
   86   0.002324   0.001633   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  <SNR>7_source_events()
    Defined: ~/config/nvim/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim line 114
Called 12 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   12              0.000058   if empty(a:plugins)
   12              0.000025     return
                              endif
                            
                              let prev_autocmd = execute('autocmd ' . a:event)
                            
                              call dein#autoload#_source(a:plugins)
                            
                              let new_autocmd = execute('autocmd ' . a:event)
                            
                              if a:event ==# 'InsertCharPre'
                                " Queue this key again
                                call feedkeys(v:char)
                                let v:char = ''
                              else
                                if a:event ==# 'BufNew'
                                  " For BufReadCmd plugins
                                  doautocmd <nomodeline> BufReadCmd
                                endif
                                if exists('#' . a:event) && prev_autocmd !=# new_autocmd
                                  execute 'doautocmd <nomodeline>' a:event
                                elseif exists('#User#' . a:event)
                                  execute 'doautocmd <nomodeline> User' a:event
                                endif
                              endif

FUNCTION  <SNR>151_LineIndent()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/anyfold.vim line 324
Called 88 times
Total time:   0.022706
 Self time:   0.004307

count  total (s)   self (s)
   88   0.009006   0.001569     let prev_indent = indent(s:PrevNonBlankLine(a:lnum))
   88   0.008891   0.001350     let next_indent = indent(s:NextNonBlankLine(a:lnum))
   88   0.004350   0.000930     if s:ConsiderLine(a:lnum)
   85              0.000239         return indent(a:lnum)
    3              0.000003     else
    3              0.000024         return max([prev_indent,next_indent])
                                endif

FUNCTION  290()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 64
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000007     return self._name

FUNCTION  291()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 68
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000019     return self._filetype . '/' . self._name

FUNCTION  292()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 78
Called 2 times
Total time:   0.000323
 Self time:   0.000170

count  total (s)   self (s)
    2              0.000007     if a:0
                                    let self._exec = a:1
    2              0.000004     else
    2              0.000011         let suffix = self._name . '_exec'
    2   0.000285   0.000132         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    2              0.000005     endif

FUNCTION  293()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/checker.vim line 89
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000006     return self._exec

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 24
Called 74 times
Total time:   0.001956
 Self time:   0.001956

count  total (s)   self (s)
   74              0.000891   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   74              0.000434   if has_key(dict, a:varname)
   50              0.000232     return dict[a:varname]
   24              0.000037   else
   24              0.000051     if a:0
   23              0.000064       return a:1
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 67
Called 5 times
Total time:   0.002965
 Self time:   0.002738

count  total (s)   self (s)
    5              0.000023     let l:info = get(s:buffer_data, a:buffer, {})
                            
    5              0.000017     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    5   0.000258   0.000031         if ale#util#InSandbox()
                                        return
    5              0.000003         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    5              0.000017         for l:filename in l:info.file_list
                                        call delete(l:filename)
    5              0.000005         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
   57              0.000084         for l:directory in l:info.directory_list
   52              0.002378             call delete(l:directory, 'rf')
   57              0.000078         endfor
                            
    5              0.000025         call remove(s:buffer_data, a:buffer)
    5              0.000004     endif

FUNCTION  <lambda>109()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000031
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>51()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000033
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000032   0.000020 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>53()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>57()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000032
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000032   0.000019 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>59()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>79_exists_file()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 207
Called 21 times
Total time:   0.002641
 Self time:   0.000675

count  total (s)   self (s)
   21   0.002617   0.000651   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>107_BufReadPostHook()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 298
Called 1 time
Total time:   0.000177
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000138   0.000010     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000002     if g:syntastic_check_on_open && buf > 0
    1   0.000029   0.000014         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
    1              0.000003         if index(s:_check_stack, buf) == -1
    1              0.000002             call add(s:_check_stack, buf)
    1              0.000001         endif
    1              0.000000     endif

FUNCTION  <SNR>107_BufWinEnterHook()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic.vim line 343
Called 6 times
Total time:   0.008061
 Self time:   0.000624

count  total (s)   self (s)
    6   0.007376   0.000142     let buf = syntastic#util#fname2buf(a:fname)
    6   0.000439   0.000237     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    6              0.000051     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    3              0.000041         let idx = index(reverse(copy(s:_check_stack)), buf)
    3              0.000014         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
    3              0.000005         endif
    6              0.000007     endif

FUNCTION  <SNR>79_dir()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/utility.vim line 198
Called 18 times
Total time:   0.003567
 Self time:   0.000705

count  total (s)   self (s)
   18   0.003547   0.000685   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 350
Called 5 times
Total time:   0.000666
 Self time:   0.000606

count  total (s)   self (s)
    5              0.000012     let l:command_list = []
    5              0.000013     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    5              0.000023     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    3   0.000095   0.000067         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    3              0.000007         let l:is_dummy_sign_set = 1
    5              0.000003     endif
                            
                                " Place new items first.
    9              0.000031     for [l:line_str, l:info] in items(a:sign_map)
    4              0.000006         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
    4              0.000006             for l:item in l:info.items
    2              0.000005                 let l:item.sign_id = l:info.new_id
    4              0.000003             endfor
                            
    2              0.000006             if index(l:info.current_id_list, l:info.new_id) < 0
    2   0.000057   0.000041                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    2              0.000002             endif
    4              0.000002         endif
    9              0.000009     endfor
                            
                                " Remove signs without new IDs.
    9              0.000021     for l:info in values(a:sign_map)
    6              0.000010         for l:current_id in l:info.current_id_list
    2              0.000004             if l:current_id isnot l:info.new_id
    2   0.000032   0.000025                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
    2              0.000001             endif
    6              0.000004         endfor
    9              0.000007     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    5              0.000013     if l:is_dummy_sign_set && !g:ale_sign_column_always
    3   0.000043   0.000033         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    5              0.000003     endif
                            
    5              0.000008     return l:command_list

FUNCTION  <SNR>25_escape_keys()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 208
Called 19 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   19              0.000067     let ret = substitute(a:inp, "<", "<lt>", "")
   19              0.000047     return substitute(ret, "|", "<Bar>", "")

FUNCTION  <SNR>105__normalise_filetype()
    Defined: ~/config/nvim/.cache/init.vim/.dein/plugin/syntastic/registry.vim line 402
Called 4 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    4              0.000046     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    4              0.000024     let ft = get(g:syntastic_filetype_map, ft, ft)
    4              0.000034     let ft = substitute(ft, '\m-', '_', 'g')
    4              0.000008     return ft

FUNCTION  remote#host#RegisterPlugin()
    Defined: /usr/share/nvim/runtime/autoload/remote/host.vim line 69
Called 1 time
Total time:   0.000083
 Self time:   0.000068

count  total (s)   self (s)
    1   0.000027   0.000012   let plugins = remote#host#PluginsForHost(a:host)
                            
    1              0.000004   for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
    1              0.000001   endfor
                            
    1              0.000006   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
    1              0.000001   endif
                            
    1              0.000002   for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
    1              0.000001   endfor
                            
    1              0.000006   call add(plugins, {'path': a:path, 'specs': a:specs})

FUNCTION  <SNR>166_StopCursorTimer()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/cursor.vim line 55
Called 243 times
Total time:   0.005502
 Self time:   0.005502

count  total (s)   self (s)
  243              0.001330     if s:cursor_timer != -1
  237              0.001904         call timer_stop(s:cursor_timer)
  237              0.001196         let s:cursor_timer = -1
  243              0.000375     endif

FUNCTION  remote#define#FunctionBootstrap()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 145
Called 3 times
Total time:   1.854566
 Self time:   0.002177

count  total (s)   self (s)
    3   1.852060   0.000113   let channel = remote#host#Require(a:host)
                            
    3              0.001252   exe 'autocmd! '.a:group
    3              0.000681   exe 'augroup! '.a:group
    3              0.000010   if channel
    3   0.000537   0.000094     call remote#define#FunctionOnChannel(channel, a:method, a:sync, a:name, a:opts)
                              else
                                echoerr 'Host "'a:host.'" for "'.a:name.'" function is not available'
    3              0.000002   endif

FUNCTION  ale#command#StopJobs()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 187
Called 53 times
Total time:   0.006548
 Self time:   0.003601

count  total (s)   self (s)
   53              0.000405     let l:info = get(s:buffer_data, a:buffer, {})
                            
   53              0.000156     if !empty(l:info)
   47              0.000094         let l:new_map = {}
                            
   94              0.000478         for [l:job_id, l:job_type] in items(l:info.jobs)
   47              0.000175             let l:job_id = str2nr(l:job_id)
                            
   47              0.000195             if a:job_type is# 'all' || a:job_type is# l:job_type
   47   0.003451   0.000504                 call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
   47              0.000040             endif
   94              0.000123         endfor
                            
   47              0.000254         let l:info.jobs = l:new_map
   53              0.000058     endif

FUNCTION  ale#sign#SetSigns()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 416
Called 5 times
Total time:   0.003429
 Self time:   0.000574

count  total (s)   self (s)
    5              0.000024     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    5              0.000003     endif
                            
                                " Find the current markers
    5   0.001132   0.000071     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    5   0.000298   0.000084     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    5   0.000214   0.000057     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    5   0.000831   0.000073     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    5   0.000734   0.000068     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    5              0.000015     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    5              0.000003     endif
                            
   15              0.000021     for l:command in l:command_list
   10              0.000048         silent! execute l:command
   15              0.000010     endfor
                            
                                " Reset the sign column color when there are no more errors.
    5              0.000013     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    5              0.000003     endif

FUNCTION  <SNR>263_exit_visual_mode()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 769
Called 5 times
Total time:   0.000416
 Self time:   0.000416

count  total (s)   self (s)
    5              0.000295   exec "normal! \<Esc>gv\<Esc>"
                            
                              " Call before function if exists only once until it is canceled (<Esc>)
    5              0.000060   if exists('*Multiple_cursors_before') && !s:before_function_called
                                exe "call Multiple_cursors_before()"
                                let s:before_function_called = 1
    5              0.000007   endif

FUNCTION  <SNR>263_select_in_visual_mode()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 789
Called 5 times
Total time:   0.000761
 Self time:   0.000761

count  total (s)   self (s)
    5              0.000030   if a:region[0] == a:region[1]
                                normal! v
    5              0.000008   else
    5              0.000027     call cursor(a:region[1])
    5              0.000189     normal! m`
    5              0.000035     call cursor(a:region[0])
    5              0.000207     normal! v``
    5              0.000012   endif
                            
                              " Unselect and reselect it again to properly set the '< and '> markers
    5              0.000219   exec "normal! \<Esc>gv"

FUNCTION  <SNR>263_feedkeys()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 889
Called 22 times
Total time:   0.001888
 Self time:   0.001888

count  total (s)   self (s)
   26              0.000082   while 1
   26              0.000704     let c = getchar(0)
   26              0.000146     let char_type = type(c)
                                " Checking type is important, when strings are compared with integers,
                                " strings are always converted to ints, and all strings are equal to 0
   26              0.000069     if char_type == 0
   26              0.000043       if c == 0
   22              0.000044         break
    4              0.000003       else
    4              0.000019         let s:saved_keys .= nr2char(c)
    4              0.000007       endif
                                elseif char_type == 1 " char with more than 8 bits (as string)
                                  let s:saved_keys .= c
    4              0.000002     endif
   26              0.000074   endwhile
   22              0.000235   call feedkeys(a:keys)

FUNCTION  ale#completion#GetCompletionPositionForDeoplete()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/completion.vim line 302
Called 38 times
Total time:   0.000859
 Self time:   0.000859

count  total (s)   self (s)
   38              0.000814     return match(a:input, '\k*$')

FUNCTION  <lambda>67()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>69()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  remote#define#notify()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim line 184
Called 251 times
Total time:   0.020730
 Self time:   0.020730

count  total (s)   self (s)
  251              0.002893   if get(s:busy, a:chan, 0) > 0
                                let pending = get(s:pending_notifications, a:chan, [])
                                call add(pending, deepcopy(a:000))
                                let s:pending_notifications[a:chan] = pending
  251              0.000487   else
  251              0.011631     call call('rpcnotify', [a:chan] + a:000)
  251              0.000569   endif

FUNCTION  <SNR>163_BuildSignMap()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/sign.vim line 281
Called 5 times
Total time:   0.000758
 Self time:   0.000565

count  total (s)   self (s)
    5   0.000110   0.000040     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    5              0.000010     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    5              0.000021     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    5              0.000004     else
    5              0.000014         let l:selected_grouped_items = a:grouped_items
    5              0.000003     endif
                            
    5              0.000009     let l:sign_map = {}
    5              0.000012     let l:sign_offset = g:ale_sign_offset
                            
    7              0.000018     for [l:line, l:sign_id, l:name] in a:current_sign_list
    2              0.000019         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
    2              0.000004         if l:sign_id > l:sign_offset
    2              0.000004             let l:sign_offset = l:sign_id
    2              0.000001         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
    2              0.000007         call add(l:sign_info.current_id_list, l:sign_id)
    2              0.000006         call add(l:sign_info.current_name_list, l:name)
                            
    2              0.000007         let l:sign_map[l:line] = l:sign_info
    7              0.000008     endfor
                            
    7              0.000014     for l:group in l:selected_grouped_items
    2              0.000005         let l:line = l:group[0].lnum
    2              0.000017         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
    2   0.000143   0.000022         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
    2              0.000005         let l:sign_info.items = l:group
                            
    2              0.000009         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
    2              0.000003         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
    2              0.000002         else
                                        " This sign name replaces the previous name, so use a new ID.
    2              0.000005             let l:sign_info.new_id = l:sign_offset + 1
    2              0.000004             let l:sign_offset += 1
    2              0.000001         endif
                            
    2              0.000007         let l:sign_map[l:line] = l:sign_info
    7              0.000008     endfor
                            
    5              0.000008     return l:sign_map

FUNCTION  delimitMate#Set()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/delimitMate.vim line 270
Called 276 times
Total time:   0.015610
 Self time:   0.003401

count  total (s)   self (s)
  276   0.015466   0.003256   return call('s:set', a:000)

FUNCTION  <SNR>154_save_last_seen_change()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/diff.vim line 401
Called 4 times
Total time:   0.000293
 Self time:   0.000098

count  total (s)   self (s)
    4   0.000290   0.000094   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>263_display_error()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 1148
Called 8 times
Total time:   0.000560
 Self time:   0.000500

count  total (s)   self (s)
    8   0.000279   0.000219   if s:bad_input == s:cm.size() && ((s:from_mode ==# 'n'    && has_key(g:multi_cursor_normal_maps, s:char[0])) ||  (s:from_mode =~# 'v\|V' && has_key(g:multi_cursor_visual_maps, s:char[0])))
                                " we couldn't replay it anywhere but we're told it's the beginning of a
                                " multi-character map like the `d` in `dw`
                                let s:retry_keys = s:char
    8              0.000013   else
    8              0.000042     let s:retry_keys = ""
    8              0.000023     if s:bad_input > 0
                                  echohl ErrorMsg | echo "Key '".s:char."' cannot be replayed at ". s:bad_input." cursor location".(s:bad_input == 1 ? '' : 's') | echohl Normal
    8              0.000010     endif
    8              0.000008   endif
    8              0.000031   let s:bad_input = 0

FUNCTION  <SNR>263_compare_pos()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/multiple_cursors.vim line 843
Called 5 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                              " If number lines are the same, compare columns
    5              0.000060   return a:l[0] ==# a:r[0] ? a:l[1] - a:r[1] : a:l[0] - a:r[0]

FUNCTION  <lambda>63()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000029   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#job#Start()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/job.vim line 215
Called 52 times
Total time:   0.105140
 Self time:   0.104700

count  total (s)   self (s)
   52   0.001247   0.000808     call ale#job#ValidateArguments(a:command, a:options)
                            
   52              0.000323     let l:job_info = copy(a:options)
   52              0.000131     let l:job_options = {}
                            
   52              0.000207     if has('nvim')
   52              0.000161         if has_key(a:options, 'out_cb')
   52              0.000374             let l:job_options.on_stdout = function('s:NeoVimCallback')
   52              0.000143             let l:job_info.out_cb_line = ''
   52              0.000043         endif
                            
   52              0.000163         if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
   52              0.000043         endif
                            
   52              0.000128         if has_key(a:options, 'exit_cb')
   52              0.000272             let l:job_options.on_exit = function('s:NeoVimCallback')
   52              0.000037         endif
                            
   52              0.096053         let l:job_info.job = jobstart(a:command, l:job_options)
   52              0.000658         let l:job_id = l:job_info.job
                                else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
   52              0.000052     endif
                            
   52              0.000149     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   52              0.000613         let s:job_map[l:job_id] = l:job_info
   52              0.000045     endif
                            
   52              0.000269     return l:job_id

FUNCTION  <SNR>25_string_to_keys()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/leaderGuide.vim line 185
Called 14 times
Total time:   0.000621
 Self time:   0.000621

count  total (s)   self (s)
                                " Avoid special case: <>
   14              0.000087     if match(a:input, '<.\+>') != -1
                                    let retlist = []
                                    let si = 0
                                    let go = 1
                                    while si < len(a:input)
                                        if go
                                            call add(retlist, a:input[si])
                                        else
                                            let retlist[-1] .= a:input[si]
                                        endif
                                        if a:input[si] ==? '<'
                                            let go = 0
                                        elseif a:input[si] ==? '>'
                                            let go = 1
                                        end
                                        let si += 1
                                    endw
                                    return retlist
   14              0.000013     else
   14              0.000145         return split(a:input, '\zs')

FUNCTION  <SNR>51_AddHighlighting()
    Defined: ~/config/nvim/.cache/init.vim/.dein/nerdtree_plugin/git_status.vim line 325
Called 3 times
Total time:   0.002667
 Self time:   0.001902

count  total (s)   self (s)
    3   0.001182   0.000417     let l:synmap = { 'NERDTreeGitStatusModified'    : s:NERDTreeGetIndicator('Modified'), 'NERDTreeGitStatusStaged'      : s:NERDTreeGetIndicator('Staged'), 'NERDTreeGitStatusUntracked'   : s:NERDTreeGetIndicator('Untracked'), 'NERDTreeGitStatusRenamed'     : s:NERDTreeGetIndicator('Renamed'), 'NERDTreeGitStatusIgnored'     : s:NERDTreeGetIndicator('Ignored'), 'NERDTreeGitStatusDirDirty'    : s:NERDTreeGetIndicator('Dirty'), 'NERDTreeGitStatusDirClean'    : s:NERDTreeGetIndicator('Clean') }
                            
   24              0.000106     for l:name in keys(l:synmap)
   21              0.000863         exec 'syn match ' . l:name . ' #' . escape(l:synmap[l:name], '~') . '# containedin=NERDTreeFlags'
   24              0.000047     endfor
                            
    3              0.000066     hi def link NERDTreeGitStatusModified Special
    3              0.000048     hi def link NERDTreeGitStatusStaged Function
    3              0.000058     hi def link NERDTreeGitStatusRenamed Title
    3              0.000051     hi def link NERDTreeGitStatusUnmerged Label
    3              0.000041     hi def link NERDTreeGitStatusUntracked Comment
    3              0.000040     hi def link NERDTreeGitStatusDirDirty Tag
    3              0.000051     hi def link NERDTreeGitStatusDirClean DiffAdd
                                " TODO: use diff color
    3              0.000051     hi def link NERDTreeGitStatusIgnored DiffAdd

FUNCTION  <SNR>159_ExitCallback()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 211
Called 52 times
Total time:   0.017917
 Self time:   0.001077

count  total (s)   self (s)
   52              0.000158     if !has_key(s:buffer_data, a:buffer)
                                    return
   52              0.000029     endif
                            
   52              0.000160     let l:jobs = s:buffer_data[a:buffer].jobs
                            
   52              0.000139     if !has_key(l:jobs, a:data.job_id)
   47              0.000035         return
    5              0.000003     endif
                            
    5              0.000022     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    5              0.000009     if g:ale_history_enabled
    5   0.000340   0.000053         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    5              0.000016         if g:ale_history_log_output && a:data.log_output is 1
    5   0.000250   0.000067             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    5              0.000004         endif
    5              0.000003     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    5              0.000031     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    5   0.016473   0.000103     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    5              0.000015     let l:result = a:data.result
    5              0.000014     let l:result.value = l:value
                            
    5              0.000025     if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
    5              0.000003     endif

FUNCTION  <SNR>119_buflisted()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/wintabs.vim line 509
Called 2660 times
Total time:   0.074133
 Self time:   0.074133

count  total (s)   self (s)
 2660              0.020327   let filetype = getbufvar(a:buffer, '&filetype')
 2660              0.018973   let ignored = index(g:wintabs_ignored_filetypes, filetype) != -1
 2660              0.018624   let empty = bufname(a:buffer) == '' && !getbufvar(a:buffer, '&modified')
 2660              0.012695   return buflisted(a:buffer) && !ignored && !empty

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/gitgutter/hunk.vim line 1
Called 4 times
Total time:   0.000728
 Self time:   0.000192

count  total (s)   self (s)
    4   0.000343   0.000095   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    4   0.000378   0.000090   call s:reset_summary(a:bufnr)

FUNCTION  <lambda>71()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000029
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000028   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>73()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000060
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000060   0.000047 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>75()
    Defined: ~/config/nvim/.cache/init.vim/.dein/autoload/ale/command.vim line 269
Called 1 time
Total time:   0.000030
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000017 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    8   7.159345   0.000398  nerdtree#ui_glue#invokeKeyMap()
    8   7.158947   0.002184  90()
    8   7.063158   0.000547  89()
  678   4.782112   3.916136  174()
    9   3.150998   0.001503  168()
    8   3.145286   0.026254  166()
 1420   2.815219   0.045387  278()
 1420   2.730191   0.038951  NERDTreeGitStatusRefreshListener()
    6   2.551839   0.000636  <SNR>52_descendTree()
    1   2.391179   0.007985  <SNR>47_refreshRoot()
    9   2.235688   0.003129  NERDTreeGitStatusRefresh()
 1420   2.168320   0.100422  NERDTreeGetGitStatusPrefix()
    1   2.119592   0.000042  <SNR>52_openFile()
    1   2.119550   0.000104  119()
    1   2.119447   0.000076  135()
    1   2.119190   0.000040  190()
    1   2.119150   0.000105  191()
    1   2.101593   0.005776  26()
    4   1.989303   0.000375  remote#host#Require()
    3   1.854566   0.002177  remote#define#FunctionBootstrap()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  678   4.782112   3.916136  174()
    1   1.683637   1.676000  provider#node#Detect()
 2286   1.401805   1.210704  144()
   75   0.890506   0.618454  <SNR>151_ReloadFolds()
12608   0.435583   0.390191  35()
 6753   0.697805   0.339308  52()
    2              0.304726  provider#Poll()
30412              0.296636  32()
  307              0.232178  <SNR>126_Highlight_Matching_Pair()
 6304   0.660798   0.225215  nerdtree#compareNodesBySortKey()
 2133   0.466478   0.210827  48()
 5724   0.490242   0.190623  18()
 1426   0.207510   0.179595  <SNR>117_session_save_window()
24995              0.175348  nerdtree#runningWindows()
 6223   0.296099   0.164758  wintabs#memoize#call()
 1422   0.608518   0.156247  wintabs#refresh_buflist()
 2957   0.300507   0.145275  39()
 6696   0.325728   0.144483  57()
 1422   0.347082   0.138928  wintabs#session#save()
11005   0.218461   0.137421  46()

